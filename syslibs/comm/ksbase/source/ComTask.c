
/******************************************************************************
*
*   FILE
*   ----
*   ComTask.c
*
*   History
*   -------
*   2013-01-15   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_ksbase
#define OV_COMPILE_LIBRARY_ksbase
#endif


#include "ksbase.h"
#include "libov/ov_macros.h"
#include "ks_logfile.h"


OV_DLLFNCEXPORT OV_INT ksbase_ComTask_actimode_get(
    OV_INSTPTR_ksbase_ComTask          pobj
) {
    return pobj->v_actimode;
}

OV_DLLFNCEXPORT OV_RESULT ksbase_ComTask_actimode_set(
    OV_INSTPTR_ksbase_ComTask          pobj,
    const OV_INT  value
) {
    pobj->v_actimode = value;
    return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_INT ksbase_ComTask_cycInterval_get(
    OV_INSTPTR_ksbase_ComTask          pobj
) {
    return pobj->v_cycInterval;
}

OV_DLLFNCEXPORT OV_RESULT ksbase_ComTask_cycInterval_set(
    OV_INSTPTR_ksbase_ComTask          pobj,
    const OV_INT  value
) {
    pobj->v_cycInterval = value;
    return OV_ERR_OK;
}

/*
 * Implementing classes need to call this!
 * It links the instance to the RootComTask, thus the task is recognized to be executed.
 */
OV_DLLFNCEXPORT OV_RESULT ksbase_ComTask_constructor(
	OV_INSTPTR_ov_object 	pobj
) {

    OV_RESULT result;
	OV_INSTPTR_ksbase_RootComTask 	rcTask = NULL;
    OV_INSTPTR_ksbase_ComTask 	cTask = NULL;
    OV_TIME_SPAN ts;
    OV_TIME t;

    result = ov_object_constructor(pobj);
    if(Ov_Fail(result))
             return result;
    cTask = Ov_StaticPtrCast(ksbase_ComTask, pobj);
    rcTask = (OV_INSTPTR_ksbase_RootComTask) Ov_GetFirstChild(ov_instantiation, pclass_ksbase_RootComTask);
    if(rcTask)
    {
    	//link for getting called
    	Ov_Link(ksbase_AssocComTaskList,rcTask,cTask);
    	KS_logfile_debug(("Registered %s at %s", pobj->v_identifier, rcTask->v_identifier));
    }
    else{
    	KS_logfile_warning(("%s: No RootComTask object found. Could not register.", pobj->v_identifier));
    }
    //set time for next execution
    ov_time_gettime(&t);
    ts.secs = rcTask->v_cycsecs * cTask->v_cycInterval;
    ts.usecs = rcTask->v_cycusecs * cTask->v_cycInterval;
    if(ts.usecs >= 1000000)
    {
    	ts.secs += (ts.usecs / 1000000);
    	ts.usecs %= 1000000;
    }
    ov_time_add(&(cTask->v_NextExecTime), &(t), &ts);

    return OV_ERR_OK;

}

OV_DLLFNCEXPORT void ksbase_ComTask_destructor(
	OV_INSTPTR_ov_object 	pobj
) {
	OV_INSTPTR_ksbase_RootComTask 	rcTask = NULL;
	OV_INSTPTR_ksbase_ComTask 	cTask = NULL;

		cTask = Ov_StaticPtrCast(ksbase_ComTask, pobj);
		rcTask = (OV_INSTPTR_ksbase_RootComTask) Ov_GetFirstChild(ov_instantiation, pclass_ksbase_RootComTask);
		//unlink
		Ov_Unlink(ksbase_AssocComTaskList,rcTask,cTask);
    /* destroy object */
    ov_object_destructor(pobj);

    return;
}

/**
 * Called by RootComTask
 * Checks if its time to execute typemethod
 */
OV_DLLFNCEXPORT OV_BOOL ksbase_ComTask_calcExec(
	OV_INSTPTR_ksbase_ComTask	this
) {
	//OV_INSTPTR_ksbase_RootComTask rcTask;
	OV_TIME now;

	//rcTask = (OV_INSTPTR_ksbase_RootComTask) Ov_GetFirstChild(ov_instantiation, pclass_ksbase_RootComTask);

	if(this->v_actimode == 0) return FALSE; //disabled ComTask

	ov_time_gettime(&now);
	if(ov_time_compare(&(this->v_NextExecTime), &now) <= 0) {//its time to get called
		return TRUE;
	}
	return FALSE;
}

/**
 * Will be called by calcExec, if it is time
 * Should be overwritten by implementing class (is called by methodtable)
 */
OV_DLLFNCEXPORT void ksbase_ComTask_typemethod(
    OV_INSTPTR_ksbase_ComTask          this
) {
	KS_logfile_warning(("This ComTask has no typemethod - but it should!!! Identifier: %s", this->v_identifier));
	return;
}


OV_DLLFNCEXPORT OV_ACCESS ksbase_ComTask_getaccess(
	OV_INSTPTR_ov_object		pobj,
	const OV_ELEMENT			*pelem,
	const OV_TICKET				*pticket
) {
	/*
	*	local variables
	*/

	/*
	*	switch based on the element's type
	*/
	switch(pelem->elemtype) {
		case OV_ET_VARIABLE:
			if(pelem->elemunion.pvar->v_offset >= offsetof(OV_INST_ov_object,__classinfo)) {
				if(pelem->elemunion.pvar->v_vartype == OV_VT_CTYPE)
					return OV_AC_NONE;
				else
					return OV_AC_READWRITE;
			}
			break;
		default:
			break;
	}

	return ov_object_getaccess(pobj, pelem, pticket);
}
