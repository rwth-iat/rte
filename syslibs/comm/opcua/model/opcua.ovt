#ifndef opcua_OVT_INCLUDED
#define opcua_OVT_INCLUDED


/*	Needed to prevent redefined warnings :-S	*/
#ifdef WIN32
#undef WIN32
#endif

#include "open62541.h"
//#include "opcua_helpers.h"

/*	restore pre-anti-warning state	*/
#ifndef WIN32
#define WIN32
#endif

#define OV_UA_NAMESPACEURI "iec62541-ov.acplt.org"
/* 
	Define your data types here. 
*/
/*
typedef UA_StatusCode (*UA_Nodestore_linkNamespace)(void *handle, UA_UInt16 namespaceIndex);

 * Is called, when the Server doesn't use this nodestore for a namespace with this namespaceIndex anymore.

typedef UA_StatusCode (*UA_Nodestore_unlinkNamespace)(void *handle, UA_UInt16 namespaceIndex);

*/
/**
 * Node Lifecycle
 * ^^^^^^^^^^^^^^
 *
 * The following definitions are used to create empty nodes of the different
 * node types. The memory is managed by the nodestore. Therefore, the node has
 * to be removed via a special deleteNode function. (If the new node is not
 * added to the nodestore.) */
/* Create an editable node of the given NodeClass. */

typedef void (*UA_Nodestore_deleteNodeStore)(void *nodestoreContext);
	
typedef UA_Node * (*UA_Nodestore_newNode)(void *nodestoreContext, UA_NodeClass nodeClass);

/* Delete an editable node. */
typedef void (*UA_Nodestore_deleteNode)(void *nodestoreContext, UA_Node *node);

/**
 * Insert / Get / Replace / Remove
 * ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ */
/* Inserts a new node into the nodestore. If the nodeid is zero, then a fresh
 * numeric nodeid from namespace 1 is assigned. If insertion fails, the node is
 * deleted. */
typedef UA_StatusCode (*UA_Nodestore_insertNode)(void *nodestoreContext, UA_Node *node, UA_NodeId *addedNodeId);

/* Returns an editable copy of a node (needs to be deleted with the deleteNode
   function or inserted / replaced into the nodestore). */
typedef UA_StatusCode (*UA_Nodestore_getNodeCopy)(void *nodestoreContext, const UA_NodeId *nodeId, UA_Node **outNode);

/* To replace a node, get an editable copy of the node, edit and replace with
 * this function. If the node was already replaced since the copy was made,
 * UA_STATUSCODE_BADINTERNALERROR is returned. If the nodeid is not found,
 * UA_STATUSCODE_BADNODEIDUNKNOWN is returned. In both error cases, the editable
 * node is deleted. */
typedef UA_StatusCode (*UA_Nodestore_replaceNode)(void *nodestoreContext, UA_Node *node);

/* Remove a node in the nodestore. */
typedef UA_StatusCode (*UA_Nodestore_removeNode)(void *nodestoreContext, const UA_NodeId *nodeid);

/**
 * Iteration
 * ^^^^^^^^^
 * The following definitions are used to call a callback for every node in the
 * nodestore. */
typedef void (*UA_Nodestore_iterate)(void *nodestoreContext, void* visitorContext, UA_NodestoreVisitor visitor);

/**
 * Release
 * ^^^^^^^^
 * Prototype for implementation of multithreading capable nodestores with reference counters instead of RCU LOCK.
 * Indicates that the node is no longer referenced by the caller.
 */

/* The returned node is immutable. */
typedef const UA_Node * (*UA_Nodestore_getNode)(void *nodestoreContext, const UA_NodeId *nodeid);

typedef void (*UA_Nodestore_releaseNode)(void *nodestoreContext, const UA_Node *node);



typedef UA_Connection* UA_ConnectionPTR;       
typedef UA_Connection** UA_ConnectionPTRPTR;
typedef UA_Server* OV_PTR_UA_Server;
typedef UA_ServerConfig* UA_ServerConfigPTR;
typedef UA_ServerNetworkLayer* UA_ServerNetworkLayerPTR; 
	
//typedef UA_StatusCode opcua_loadInformationModel(UA_Server *server, UA_UInt16 *namespacesSize, UA_Namespace **namespaces);

typedef UA_StatusCode opcua_loadInformationModel(UA_Server *server, UA_UInt16 *namespacesSize, UA_String *namespaces);
	
#endif
