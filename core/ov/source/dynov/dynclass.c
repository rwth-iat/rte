/*
*   The Framework was generated by the ACPLT/OV Builder.
*
*   Builder version: 1.0.1
*   Date of file generation:  10-Apr-2002 (17:18:25)
*/

#ifndef OV_COMPILE_LIBRARY_dynov
#define OV_COMPILE_LIBRARY_dynov
#endif


#include "dynov.h"
#include "libov/ov_macros.h"

OV_DLLFNCEXPORT void dynov_dynclass_uncheck(
        OV_INSTPTR_ov_object          pobj
) {
        OV_INSTPTR_ov_object		        pchild;
	OV_INSTPTR_ov_class			pclass;
	OV_INSTPTR_ov_class			pclass2;
	OV_INSTPTR_dynov_dynvariable          	pdynvar;
	OV_INSTPTR_dynov_dynpart          	pdynpart;
	OV_INSTPTR_dynov_dynoperation          	pdynop;
	OV_INSTPTR_dynov_dynclass		pdynclass;

	pclass = Ov_DynamicPtrCast(ov_class, pobj);
	pdynclass = Ov_DynamicPtrCast(dynov_dynclass, pobj);
	Ov_ForEachChild(ov_containment, pclass, pchild) {
		pdynvar = Ov_DynamicPtrCast(dynov_dynvariable, pchild);
		pdynpart = Ov_DynamicPtrCast(dynov_dynpart, pchild);
		pdynop = Ov_DynamicPtrCast(dynov_dynoperation, pchild);
		if (pdynvar) {
			dynov_dynvariable_uncheck(Ov_PtrUpCast(ov_object, pdynvar));
		}
		if (pdynpart) {
			dynov_dynpart_uncheck(Ov_PtrUpCast(ov_object, pdynpart));
		}
		if (pdynop) {
			dynov_dynoperation_uncheck(Ov_PtrUpCast(ov_object, pdynop));
		}
	}
	if (pclass) {
		pclass2 = Ov_GetParent(ov_inheritance, pclass);
		Ov_Unlink(ov_inheritance, pclass2, pclass);
		pclass->v_classprops = 0;
	}
}

OV_INT get_operation_offset(
	OV_INSTPTR_ov_class pclass,
	OV_INSTPTR_ov_operation pop
) {
    OV_INSTPTR_ov_object		pobj;
	OV_INSTPTR_ov_operation 	pobjop;
	OV_INT				opcnt;
	OV_BOOL				result;

	opcnt = 0;
	result = FALSE;
	while (pclass) {
		for(pobj = Ov_GetFirstChild(ov_containment, pclass); pobj; pobj=Ov_GetNextChild(ov_containment, pobj)) { // iterate over class elements
	                pobjop = Ov_DynamicPtrCast(ov_operation, pobj);
	                if (pobjop) { // class element is an operation
	                        if (get_operation_offset(Ov_GetParent(ov_inheritance, pclass), pobjop)<0) { // pobjop operation is not overwritten
		                        if ((pobjop->v_identifier==pop->v_identifier) && (pobjop->v_cfnctypename==pop->v_cfnctypename)) {
		       						result = TRUE; // searched operation found
		                        	break; // continue with counting operations of base classes
		                        }
		                        opcnt++;
		                	}
					}
		}
	    pclass = Ov_GetParent(ov_inheritance, pclass); // get base class
 	}
	if (result) return (opcnt * sizeof(void*));
	return -1;   // searched operation not found
}

OV_DLLFNCEXPORT OV_BOOL dynov_dynclass_check(
        OV_INSTPTR_ov_object          pobj
) {
    OV_INSTPTR_ov_object		        pchild;
	OV_INSTPTR_ov_class			        pclass;
    OV_INSTPTR_dynov_dynassociation	    pdynassoc;
	OV_INSTPTR_dynov_dynvariable        pdynvar;
	OV_INSTPTR_dynov_dynpart          	pdynpart;
	OV_INSTPTR_dynov_dynoperation       pdynop;
	OV_INSTPTR_dynov_dynclass			pdynclass;
	OV_INSTPTR_dynov_dynclass			pdynclass2;
	OV_INSTPTR_ov_class 				pbaseclass;
    OV_VTBLPTR_dynov_dynoperation       pvtable;
    OV_UINT								offset;

	pdynclass = Ov_DynamicPtrCast(dynov_dynclass, pobj);
	if (!pdynclass) return FALSE;
	pclass = Ov_GetParent(dynov_dyninheritance, pdynclass);
	pdynclass2 = Ov_DynamicPtrCast(dynov_dynclass, pclass);
	if (pclass) {
		if (pdynclass2) if (!pdynclass2->v_isinstantiable) return FALSE;
		pdynclass->v_pvtable = pclass->v_pvtable;
		pdynclass->v_size = pclass->v_size;
		pdynclass->v_staticsize = pclass->v_staticsize;
		pdynclass->v_linktablesize = pclass->v_linktablesize;
	}
	else {
		pdynclass->v_pvtable = pclass_dynov_dynobject->v_pvtable;
		pdynclass->v_size = pclass_dynov_dynobject->v_size;
		pdynclass->v_staticsize = pclass_dynov_dynobject->v_staticsize;
		pdynclass->v_linktablesize = pclass_dynov_dynobject->v_linktablesize;
	}
	Ov_ForEachChild(ov_containment, pdynclass, pchild) {
		pdynvar = Ov_DynamicPtrCast(dynov_dynvariable, pchild);
		pdynpart = Ov_DynamicPtrCast(dynov_dynpart, pchild);
		pdynop = Ov_DynamicPtrCast(dynov_dynoperation, pchild);
		if ((!pdynvar) && (!pdynpart) && (!pdynop)) return FALSE;
		if (pdynvar) {
			if (!dynov_dynvariable_check(Ov_PtrUpCast(ov_object, pdynvar))) return FALSE;
			if (!(pdynvar->v_varprops & OV_VP_DERIVED)) {
				pdynvar->v_offset = pdynclass->v_size;
				pdynclass->v_size += pdynvar->v_size;
			}
		}
		if (pdynpart) {
			if (!dynov_dynpart_check(Ov_PtrUpCast(ov_object, pdynpart))) return FALSE;
			pdynpart->v_offset = pdynclass->v_size;
			pdynclass->v_size += Ov_GetParent(ov_embedment, pdynpart)->v_size;
		}
		if (pdynop) {
		    Ov_GetVTablePtr(dynov_dynoperation, pvtable, pdynop);
		    if (pvtable) pdynop->v_executeable = pvtable->m_check(Ov_PtrUpCast(ov_object, pdynop));
			if (!pdynop->v_executeable) return FALSE;
			pbaseclass = Ov_GetParent(dynov_dyninheritance, pdynclass);
			if (!pbaseclass) pbaseclass = pclass_dynov_dynobject;
			offset = get_operation_offset(Ov_PtrUpCast(ov_class, pdynclass), Ov_PtrUpCast(ov_operation, pdynop));
			if (offset>=0) {
			        *((OV_BYTE*) (pdynclass->v_pvtable) + offset) = NULL;

			}
		}
	}
	pdynclass->v_classprops |= OV_CP_INSTANTIABLE;
	pclass = Ov_GetParent(dynov_dyninheritance, pdynclass);
	if (pclass) {
		if (Ov_Fail(Ov_Link(ov_inheritance, pclass, pdynclass))) return FALSE;
	}
	else {
		if (Ov_Fail(Ov_Link(ov_inheritance, pclass_dynov_dynobject, pdynclass))) return FALSE;
	}
	return TRUE;
}



OV_DLLFNCEXPORT OV_BOOL dynov_dynclass_isinstantiable_get(
             OV_INSTPTR_dynov_dynclass          pobj
) {
             return pobj->v_isinstantiable;
}

OV_DLLFNCEXPORT OV_RESULT dynov_dynclass_isinstantiable_set(
             OV_INSTPTR_dynov_dynclass          pobj,
             const OV_BOOL           value
) {
             OV_INSTPTR_ov_class          pclass;

	     if ((value) && (!pobj->v_isinstantiable)) {
	             pobj->v_isinstantiable = dynov_dynclass_check(Ov_PtrUpCast(ov_object, pobj));
		     if (!pobj->v_isinstantiable) return OV_ERR_CLASSDEFMISMATCH;
	     }
	     else if ((!value) && (pobj->v_isinstantiable)) {
		     if (Ov_GetFirstChild(ov_instantiation, pobj)) return OV_ERR_NOACCESS;
		     Ov_ForEachChild(ov_inheritance, pobj, pclass) {
			     if (pclass->v_classprops & OV_CP_INSTANTIABLE) return OV_ERR_NOACCESS;
		     }
		     dynov_dynclass_uncheck(Ov_PtrUpCast(ov_object, pobj));
		     pobj->v_isinstantiable = FALSE;
	     }

       	 return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_ACCESS dynov_dynclass_getaccess(
	OV_INSTPTR_ov_object	pobj,
	const OV_ELEMENT		*pelem,
	const OV_TICKET			*pticket
) {
	OV_INSTPTR_dynov_dynclass	pdynclass;
	OV_INSTPTR_dynov_dynvariable	pdynvar;
	OV_ACCESS			access;
	OV_ACCESS			access2;
		
	pdynclass = Ov_StaticPtrCast(dynov_dynclass, pobj);
	switch(pelem->elemtype) {
		case OV_ET_VARIABLE:
			if (!ov_string_compare(pelem->elemunion.pvar->v_identifier, "isinstantiable")) return OV_AC_READ | OV_AC_WRITE;
			access = OV_AC_NONE;
			if (ov_activitylock) {
				if (!(pelem->elemunion.pvar->v_varprops & (OV_VP_DERIVED | OV_VP_STATIC)))
					access |= OV_AC_READ | OV_AC_WRITE;
				return access;
			}
			if(pelem->elemunion.pvar->v_varprops & OV_VP_GETACCESSOR) {
				access |= OV_AC_READ;
			}
			if((pelem->elemunion.pvar->v_varprops & OV_VP_SETACCESSOR)
				&& ((pobj->v_objectstate & OV_OS_INIT) 
					|| !(pelem->elemunion.pvar->v_varprops & OV_VP_STATIC))
			) {
				access |= OV_AC_WRITE;
			}
			pdynvar = Ov_DynamicPtrCast(dynov_dynvariable, pelem->elemunion.pvar);
			if (pdynvar)  {
				access |= pdynvar->v_accessrights;
			}
			if (pdynclass->v_isinstantiable) access2 = OV_AC_READ;
			else access2 = OV_AC_READ | OV_AC_WRITE;
			if (!ov_string_compare(pelem->elemunion.pvar->v_identifier, "comment"))
				access = access2;
			if (!ov_string_compare(pelem->elemunion.pvar->v_identifier, "flags"))
				access = access2;
			if (!ov_string_compare(pelem->elemunion.pvar->v_identifier, "classprops"))
				access = OV_AC_READ;
			if (!ov_string_compare(pelem->elemunion.pvar->v_identifier, "size"))
				access = OV_AC_READ;
			if (!ov_string_compare(pelem->elemunion.pvar->v_identifier, "staticsize"))
				access = OV_AC_READ;
			if (!ov_string_compare(pelem->elemunion.pvar->v_identifier, "linktablesize"))
				access = OV_AC_READ;
			return access;
		case OV_ET_CHILDLINK:
			if (pelem->elemunion.passoc == passoc_ov_instantiation)
				return OV_AC_NONE;
			if (pelem->elemunion.passoc == passoc_ov_containment)
				return OV_AC_NONE;
			if (pdynclass->v_isinstantiable) {
				access = OV_AC_NONE;
				access2 = OV_AC_READ;
			}
			else  {
				access = OV_AC_READ | OV_AC_WRITE;
				access2 = OV_AC_NONE;
			}
			if (pelem->elemunion.passoc == passoc_ov_inheritance)
				return access2;
			if (pelem->elemunion.passoc == passoc_dynov_dyninheritance)
				return access;
			return access;
		case OV_ET_PARENTLINK:
			if (!ov_string_compare(pelem->elemunion.passoc->v_identifier, "containment"))
				return OV_AC_READ;
			if (pdynclass->v_isinstantiable) {
				access = OV_AC_READ;
				access2 = OV_AC_READ;
			}
			else  {
				access = OV_AC_READ | OV_AC_WRITE;
				access2 = OV_AC_READ;
			}
			if (pelem->elemunion.passoc == passoc_ov_instantiation)
				return access2;
			if (pelem->elemunion.passoc == passoc_ov_childrelationship)
				return access2;
			if (pelem->elemunion.passoc == passoc_ov_inheritance)
				return access2;
			if (pelem->elemunion.passoc == passoc_ov_parentrelationship)
				return access2;
			if (pelem->elemunion.passoc == passoc_ov_embedment)
				return access2;
			if (pelem->elemunion.passoc == passoc_dynov_dynchildrelationship)
				return access;
			if (pelem->elemunion.passoc == passoc_dynov_dyninheritance)
				return access;
			if (pelem->elemunion.passoc == passoc_dynov_dynparentrelationship)
				return access;
			if (pelem->elemunion.passoc == passoc_dynov_dynembedment)
				return access;
			return access;
		case OV_ET_OPERATION:
			return OV_AC_NONE;
	}
	if ((pdynclass->v_isinstantiable) || (pobj->v_pouterobject)) return OV_AC_READ | OV_AC_INSTANTIABLE;
	return OV_AC_READ | OV_AC_WRITE | OV_AC_DELETEABLE | OV_AC_RENAMEABLE;
}

