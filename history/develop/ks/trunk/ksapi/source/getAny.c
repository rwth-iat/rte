
/******************************************************************************
*
*   FILE
*   ----
*   getAny.c
*
*   History
*   -------
*   2012-06-28   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_ksapi
#define OV_COMPILE_LIBRARY_ksapi
#endif


#include "ksapi.h"
#include "ksapi_logfile.h"
#include "libov/ov_macros.h"
#include "xdrhandling.h"

OV_DLLFNCEXPORT OV_TIME* ksapi_getAny_varTimeStamp_get(
    OV_INSTPTR_ksapi_getAny          pobj
) {
    return &pobj->v_varTimeStamp;
}

OV_DLLFNCEXPORT OV_RESULT ksapi_getAny_varTimeStamp_set(
    OV_INSTPTR_ksapi_getAny          pobj,
    const OV_TIME*  value
) {
    pobj->v_varTimeStamp = *value;
    return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_UINT ksapi_getAny_varQState_get(
    OV_INSTPTR_ksapi_getAny          pobj
) {
    return pobj->v_varQState;
}

OV_DLLFNCEXPORT OV_RESULT ksapi_getAny_varQState_set(
    OV_INSTPTR_ksapi_getAny          pobj,
    const OV_UINT  value
) {
    pobj->v_varQState = value;
    return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_ANY* ksapi_getAny_receiveany_get(
    OV_INSTPTR_ksapi_getAny          pobj
) {
    return &pobj->v_receiveany;
}

OV_DLLFNCEXPORT OV_RESULT ksapi_getAny_receiveany_set(
    OV_INSTPTR_ksapi_getAny          pobj,
    const OV_ANY*  value
) {
    return ov_variable_setanyvalue(&pobj->v_receiveany, value);
}

OV_DLLFNCEXPORT OV_RESULT ksapi_getAny_constructor(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
    OV_INSTPTR_ksapi_getAny pinst = Ov_StaticPtrCast(ksapi_getAny, pobj);
    OV_RESULT    result;

    /* do what the base class does first */
    result = ov_object_constructor(pobj);
    if(Ov_Fail(result))
         return result;

    /* do what */

    pinst->v_receiveany.value.vartype = OV_VT_VOID;
    pinst->v_receiveany.value.valueunion.val_double = 0.0;

    return OV_ERR_OK;
}

OV_DLLFNCEXPORT void ksapi_getAny_destructor(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
    OV_INSTPTR_ksapi_getAny pinst = Ov_StaticPtrCast(ksapi_getAny, pobj);

    /* do what */

    /* destroy object */
    ov_object_destructor(pobj);

    Ov_SetAnyValue(&(pinst->v_receiveany), NULL);

    return;
}

OV_DLLFNCEXPORT void ksapi_getAny_startup(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
    //To avoid a double Startup, which occures, because startup is executed while constructing
    //the object and starting the FB, this check is implemented
    if (pobj->v_objectstate & OV_OS_STARTED) {
    	return;
    }
    /* do what the base class does first */
    ksapi_KSCommon_startup(pobj);

    /* do what */
    ksapi_getAny_receiveany_set(Ov_StaticPtrCast(ksapi_getAny, pobj), NULL);
    return;
}

OV_DLLFNCEXPORT void ksapi_getAny_returnMethodxdr(
		OV_INSTPTR_ksapi_KSCommon	 			kscommon,
		OV_STRING									xdr,
		OV_INT										xdrlength
) {
	OV_INSTPTR_ksapi_getAny pga = Ov_StaticPtrCast(ksapi_getAny, kscommon);
	OV_VTBLPTR_ksapi_getAny   pvtableop;
	OV_UINT i;
	OV_UINT vartype;
	OV_UINT errorcode;
	OV_ANY result;


	result.value.valueunion.val_double = 0.0;
	Ov_GetVTablePtr(ksapi_getAny, pvtableop, pga);

	if(xdr[39] == 0) // OK, found
	{

		Ov_SetAnyValue(&pga->v_receiveany, NULL);
		pga->v_receiveany.value.valueunion.val_double = 0.0;		//clearing all data in valueunion (necessary for setting veclengths and pointers to 0)

		for(i=0; i<4; i++)
			((char*) &vartype)[3-i] = xdr[44+i]; // copy type

		pga->v_receiveany.value.vartype = vartype;

		switch(vartype)
		{
		case OV_VT_BOOL:
			analysegetreply(vartype, xdr, xdrlength, &(pga->v_receiveany.value.valueunion.val_bool),
					&(pga->v_varTimeStamp.secs), &(pga->v_varTimeStamp.usecs), &(pga->v_varQState));
			break;
		case OV_VT_UINT:
			analysegetreply(vartype, xdr, xdrlength, &(pga->v_receiveany.value.valueunion.val_uint),
					&(pga->v_varTimeStamp.secs), &(pga->v_varTimeStamp.usecs), &(pga->v_varQState));
			break;
		case OV_VT_INT:
			analysegetreply(vartype, xdr, xdrlength, &(pga->v_receiveany.value.valueunion.val_int),
					&(pga->v_varTimeStamp.secs), &(pga->v_varTimeStamp.usecs), &(pga->v_varQState));
			break;
		case OV_VT_SINGLE:
			analysegetreply(vartype, xdr, xdrlength, &(pga->v_receiveany.value.valueunion.val_single),
					&(pga->v_varTimeStamp.secs), &(pga->v_varTimeStamp.usecs), &(pga->v_varQState));
			break;

		case OV_VT_DOUBLE:
			analysegetreply(vartype, xdr, xdrlength, &(pga->v_receiveany.value.valueunion.val_double),
					&(pga->v_varTimeStamp.secs), &(pga->v_varTimeStamp.usecs), &(pga->v_varQState));
			break;
		case OV_VT_TIME:
			analysegetreply(vartype, xdr, xdrlength, &(pga->v_receiveany.value.valueunion.val_time),
					&(pga->v_varTimeStamp.secs), &(pga->v_varTimeStamp.usecs), &(pga->v_varQState));
			break;
		case OV_VT_TIME_SPAN:
			analysegetreply(vartype, xdr, xdrlength, &(pga->v_receiveany.value.valueunion.val_time_span),
					&(pga->v_varTimeStamp.secs), &(pga->v_varTimeStamp.usecs), &(pga->v_varQState));
			break;
		case OV_VT_STRING:
			analysegetreply(vartype, xdr, xdrlength, &(result.value.valueunion.val_string),
					&(pga->v_varTimeStamp.secs), &(pga->v_varTimeStamp.usecs), &(pga->v_varQState));
			ov_string_setvalue(&(pga->v_receiveany.value.valueunion.val_string), result.value.valueunion.val_string);
			free(result.value.valueunion.val_string);
			break;
		case OV_VT_BOOL_VEC:
			analysegetvecreply(vartype, xdr, xdrlength, (void**) &(result.value.valueunion.val_bool_vec.value), (int*) &(result.value.valueunion.val_bool_vec.veclen),
					&(pga->v_varTimeStamp.secs), &(pga->v_varTimeStamp.usecs), &(pga->v_varQState));
			Ov_SetDynamicVectorValue(&(pga->v_receiveany.value.valueunion.val_bool_vec),
										result.value.valueunion.val_bool_vec.value, result.value.valueunion.val_bool_vec.veclen, BOOL);
			free(result.value.valueunion.val_bool_vec.value);
			break;
		case OV_VT_UINT_VEC:
			analysegetvecreply(vartype, xdr, xdrlength, (void**) &(result.value.valueunion.val_uint_vec.value), (int*) &(result.value.valueunion.val_uint_vec.veclen),
					&(pga->v_varTimeStamp.secs), &(pga->v_varTimeStamp.usecs), &(pga->v_varQState));
			Ov_SetDynamicVectorValue(&(pga->v_receiveany.value.valueunion.val_uint_vec),
					result.value.valueunion.val_uint_vec.value, result.value.valueunion.val_uint_vec.veclen, UINT);
			free(result.value.valueunion.val_uint_vec.value);
			break;
		case OV_VT_INT_VEC:
			analysegetvecreply(vartype, xdr, xdrlength, (void**) &(result.value.valueunion.val_int_vec.value), (int*) &(result.value.valueunion.val_int_vec.veclen),
					&(pga->v_varTimeStamp.secs), &(pga->v_varTimeStamp.usecs), &(pga->v_varQState));
			Ov_SetDynamicVectorValue(&(pga->v_receiveany.value.valueunion.val_int_vec),
					result.value.valueunion.val_int_vec.value, result.value.valueunion.val_int_vec.veclen, INT);
			free(result.value.valueunion.val_int_vec.value);
			break;
		case OV_VT_SINGLE_VEC:
			analysegetvecreply(vartype, xdr, xdrlength, (void**) &(result.value.valueunion.val_single_vec.value), (int*) &(result.value.valueunion.val_single_vec.veclen),
					&(pga->v_varTimeStamp.secs), &(pga->v_varTimeStamp.usecs), &(pga->v_varQState));
			Ov_SetDynamicVectorValue(&(pga->v_receiveany.value.valueunion.val_single_vec),
					result.value.valueunion.val_single_vec.value, result.value.valueunion.val_single_vec.veclen, SINGLE);
			free(result.value.valueunion.val_single_vec.value);
			break;
		case OV_VT_DOUBLE_VEC:
			analysegetvecreply(vartype, xdr, xdrlength, (void**) &(result.value.valueunion.val_double_vec.value), (int*) &(result.value.valueunion.val_double_vec.veclen),
					&(pga->v_varTimeStamp.secs), &(pga->v_varTimeStamp.usecs), &(pga->v_varQState));
			Ov_SetDynamicVectorValue(&(pga->v_receiveany.value.valueunion.val_double_vec),
					result.value.valueunion.val_double_vec.value, result.value.valueunion.val_double_vec.veclen, DOUBLE);
			free(result.value.valueunion.val_double_vec.value);
			break;
		case OV_VT_TIME_VEC:
			analysegetvecreply(vartype, xdr, xdrlength, (void**) &(result.value.valueunion.val_time_vec.value), (int*) &(result.value.valueunion.val_time_vec.veclen),
					&(pga->v_varTimeStamp.secs), &(pga->v_varTimeStamp.usecs), &(pga->v_varQState));
			Ov_SetDynamicVectorValue(&(pga->v_receiveany.value.valueunion.val_time_vec),
					result.value.valueunion.val_time_vec.value, result.value.valueunion.val_time_vec.veclen, TIME);
			free(result.value.valueunion.val_time_vec.value);
			break;
		case OV_VT_TIME_SPAN_VEC:
			analysegetvecreply(vartype, xdr, xdrlength, (void**) &(result.value.valueunion.val_time_span_vec.value), (int*) &(result.value.valueunion.val_time_span_vec.veclen),
					&(pga->v_varTimeStamp.secs), &(pga->v_varTimeStamp.usecs), &(pga->v_varQState));
			Ov_SetDynamicVectorValue(&(pga->v_receiveany.value.valueunion.val_time_span_vec),
					result.value.valueunion.val_time_span_vec.value, result.value.valueunion.val_time_span_vec.veclen, TIME_SPAN);
			free(result.value.valueunion.val_time_span_vec.value);
			break;
		case OV_VT_STRING_VEC:
			analysegetvecreply(vartype, xdr, xdrlength, (void**) &(result.value.valueunion.val_string_vec.value), (int*) &(result.value.valueunion.val_string_vec.veclen),
					&(pga->v_varTimeStamp.secs), &(pga->v_varTimeStamp.usecs), &(pga->v_varQState));
			Ov_SetDynamicVectorValue(&(pga->v_receiveany.value.valueunion.val_string_vec),
					result.value.valueunion.val_string_vec.value, result.value.valueunion.val_string_vec.veclen, STRING);
			for(i=0; i<result.value.valueunion.val_string_vec.veclen; i++)
				free(result.value.valueunion.val_string_vec.value[i]);
			free(result.value.valueunion.val_string_vec.value);

			break;
		default:
			ov_logfile_error("what the hack is this vartype?! 0x%x", vartype);

		}



		pvtableop->m_returnMethod((OV_INSTPTR_ov_object)kscommon, "Reading completed", 1);


	}
	else //bad luck - no result
	{
		errorcode = xdr[xdrlength-1];
		switch (errorcode)
		{
		case KS_ERR_BADPATH:
			ksapi_logfile_error("\nwrong path\n");
			break;
		default:
			ksapi_logfile_error("\nERROR\n");
		}
		pvtableop->m_returnMethod((OV_INSTPTR_ov_object)kscommon, "error", -1);
	}
	return;
}

