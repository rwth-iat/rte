
/******************************************************************************
 *
 *   FILE
 *   ----
 *   xdrClient.c
 *
 *   History
 *   -------
 *   2013-02-22   File created
 *
 *******************************************************************************
 *
 *   This file is generated by the 'acplt_builder' command
 *
 ******************************************************************************/

/************************************************************************************************************************************************************************
 * The xdrClient Handler is based on a state machine
 * the states are
 * INITIAL:
 * 		nothing is done. one can start from here. typemethod is deactivated.
 * AWAITINGCONNECTION:
 * 		a ks-service was requested. The associated channel is opening a connection.
 * 		the typemethod polls the connection status of the channel. if a connection is opened the request is sent and the state is changed to AWAITINGANSWER
 * 		if the connection does not open withing timeout seconds the typemethod sets an errorstate and deactivates itself
 * AWAITINGANSWER
 * 		the typemethod just calculates the timeout.
 * 		upon receipt of a reply the HandleData function is called by the Channel
 * 		HandleData tries to process the generic part of the message. if handle data fails because the message is incomplete the state is changed to BUSY.
 * 		if it fails for some other reason the state is changed to ERROR and the typemethod is deactivated
 * 		if HandleData succeeds the state is changed to COMPLETED
 * BUSY
 *		the typemethod calls HandleData again to try processing the answer. state changes are the same as in AWAITINGANSWER
 *		the timeout is calculated
 * ERROR
 *		the typemethod is deactivated
 *
 ************************************************************************************************************************************************************************/


#ifndef OV_COMPILE_LIBRARY_ksxdr
#define OV_COMPILE_LIBRARY_ksxdr
#endif


#include "ksxdr.h"
#include "libov/ov_macros.h"
#include "libov/ov_malloc.h"
#include "libov/ov_result.h"
#include "ov_ksserver_backend.h"
#include "KSDATAPACKET_xdrhandling.h"
#include "ksxdr_config.h"
#include "ks_logfile.h"
#include "ksbase_helper.h"
#include "ksxdr_services.h"

static OV_UINT client_xid = 0xd639a74c;	/*	some beating on the keyboard for initialization	*/

/*******************************************************************************************************************************************************************************
 * 				Channel-handling
 *******************************************************************************************************************************************************************************/

OV_RESULT getChannelPointer(OV_INSTPTR_ksxdr_xdrClient this, OV_INSTPTR_ksbase_Channel* ppChannel, OV_VTBLPTR_ksbase_Channel* ppVtblChannel)
{
	OV_STRING OptValTemp = NULL;
	OV_INSTPTR_ov_class pClassChannel = NULL;
	OV_RESULT result;

	/*	check if there is a channel and get pointer to it	*/
	*ppChannel = Ov_GetParent(ksbase_AssocChannelDataHandler, this);
	if(!(*ppChannel))
	{/*	no Channel found. Create one	*/
		/*
		 * Checking KSXDR_USECHANNEL and KS_USECHANNEL options to determine which channel type to use. use TCPChannel per default.
		 */
		ov_memstack_lock();
		OptValTemp = ov_vendortree_getcmdlineoption_value("KSXDR_USECHANNEL");
		if(!OptValTemp)
			OptValTemp = ov_vendortree_getcmdlineoption_value("KS_USECHANNEL");

		if(!OptValTemp)
		{/*	Neither option specified, use TCPChannel as default	*/
			OptValTemp = ov_memstack_alloc(sizeof("TCPChannel"));
			strcpy(OptValTemp, "TCPChannel");
		}

		if(*OptValTemp)
		{	/*	empty option means do not create channel	*/
			pClassChannel = Ov_StaticPtrCast(ov_class, Ov_GetFirstChild(ov_instantiation, pclass_ov_class));
			while(pClassChannel)
			{
				if(ov_string_compare(pClassChannel->v_identifier, OptValTemp) == OV_STRCMP_EQUAL)
					break;
				pClassChannel = Ov_StaticPtrCast(ov_class, Ov_GetNextChild(ov_instantiation, pClassChannel));
			}

			if(pClassChannel)
			{/*	channel found create it	*/
				result = ov_class_createobject(pClassChannel, Ov_StaticPtrCast(ov_domain, this), "channel", OV_PMH_DEFAULT, NULL, NULL, NULL, (OV_INSTPTR_ov_object*) ppChannel);
				if(Ov_Fail(result))
				{
					KS_logfile_error(("%s getChannelPointer: could not create channel for manager communication. reason: %s", this->v_identifier, ov_result_getresulttext(result)));
					return result;
				}
				else
				{
					result = Ov_Link(ksbase_AssocChannelDataHandler, *ppChannel, this);
					if(Ov_Fail(result))
					{
						KS_logfile_error(("%s getChannelPointer: could not link with channel. reason: %s", this->v_identifier, ov_result_getresulttext(result)));
						return result;
					}
					(*ppChannel)->v_ClientHandlerAssociated = KSBASE_CH_NOTNEEDED;

				}
			}
		}
		else
		{
			ov_memstack_unlock();
			*ppChannel = NULL;
			*ppVtblChannel = NULL;
			return OV_ERR_OK;
		}
		ov_memstack_unlock();
	}


	Ov_GetVTablePtr(ksbase_Channel, *ppVtblChannel, *ppChannel);
	if(!(*ppVtblChannel))
	{
		KS_logfile_error(("%s: getChannelPointer: could not get VTable of channel object. Aborting.", this->v_identifier));
		return OV_ERR_BADFACTORY;
	}
	return OV_ERR_OK;
}

/*******************************************************************************************************************************************************************************
 * 				Connection handling and sending
 ******************************************************************************************************************************************************************************/

/*	if there is no connection (open or opening) open one and reset lasteventtime	*/
OV_RESULT initiateConnection(OV_INSTPTR_ksxdr_xdrClient this, OV_INSTPTR_ksbase_Channel pChannel, OV_VTBLPTR_ksbase_Channel pVtblChannel, OV_BOOL isLocal, OV_STRING host, OV_STRING port)
{
	OV_RESULT result;

	if((pChannel->v_ConnectionState != KSBASE_CONNSTATE_OPEN) && (pChannel->v_ConnectionState != KSBASE_CONNSTATE_OPENING))
	{
		if(!port)
			return OV_ERR_BADPARAM;

		if(isLocal)
			result = pVtblChannel->m_OpenLocalConn(pChannel, port);
		else
		{
			if(!host)
				return OV_ERR_BADPARAM;
			result = pVtblChannel->m_OpenConnection(pChannel, host, port);
		}

		if(Ov_Fail(result))
		{
			KS_logfile_error(("%s: initiateConnection: could not open connection", this->v_identifier));
			return result;
		}
		ov_time_gettime(&(this->v_timeLastEvent));
	}
	return OV_ERR_OK;
}

/*	check if connection is open. if so, send and set Client state to busy and reset lasteventtime. if not set client state to awaiting connection. activate typemethod	*/
OV_RESULT trySend(OV_INSTPTR_ksxdr_xdrClient thisCl, OV_INSTPTR_ksbase_Channel pChannel, OV_VTBLPTR_ksbase_Channel pVtblChannel)
{
	OV_RESULT result = OV_ERR_OK;

	if(pChannel->v_ConnectionState == KSBASE_CONNSTATE_OPEN)
	{
		result = pVtblChannel->m_SendData(pChannel);
		if(Ov_Fail(result))
		{
			ksbase_free_KSDATAPACKET(&(thisCl->v_dataToSend));
			ksbase_free_KSDATAPACKET(&(pChannel->v_outData));
			return result;
		}
		ov_time_gettime(&(thisCl->v_timeLastEvent));
		thisCl->v_state = KSBASE_CLST_AWAITINGANSWER;	/*	set state to busy and activate typemethod	*/
		thisCl->v_actimode = 1;
	}
	else
	{
		thisCl->v_state = KSBASE_CLST_AWAITINGCONNECTION;
		thisCl->v_actimode = 1;
	}
	return OV_ERR_OK;
}
/*******************************************************************************************************************************************************************************
 * 				header
 ******************************************************************************************************************************************************************************/
/**
 * creation of rpc message header (call)
 * @param procedureNumber: procedure number to call
 * @param datapacket: datapacket to write into
 * @param xid: xid is returned (using a global counter)
 * @return	errorcode
 */
OV_RESULT ksxdr_generateClientMessageHeader(OV_UINT procedureNumber, OV_BOOL usesStreamProtocol, KS_DATAPACKET* datapacket, OV_UINT* xid, OV_UINT* pindex)
{
	OV_RESULT result;
	OV_UINT varToSet;

	if(!datapacket)
		return OV_ERR_BADPARAM;
	if(datapacket->data && datapacket->writePT)
		*pindex = (datapacket->writePT - datapacket->data);
	else
		*pindex = 0;

	if(usesStreamProtocol)
	{
		/*	reserve space for rpc-header	*/
		varToSet = 0x80000000;
		result = KS_DATAPACKET_write_xdr_u_long(datapacket, &varToSet);
		if(Ov_Fail(result))
			return result;
	}

	varToSet = client_xid++;	/*	write xid (and increment variable)	*/
	result = KS_DATAPACKET_write_xdr_u_long(datapacket, &varToSet);
	if(Ov_Fail(result))
		return result;
	*xid = varToSet;

	varToSet = KSXDR_MSGTYPE_CALL;
	result = KS_DATAPACKET_write_xdr_u_long(datapacket, &varToSet);
	if(Ov_Fail(result))
		return result;

	varToSet = KSXDR_RPCVERSION;
	result = KS_DATAPACKET_write_xdr_u_long(datapacket, &varToSet);
	if(Ov_Fail(result))
		return result;

	varToSet = KSXDR_PROGRAMNUMBER;
	result = KS_DATAPACKET_write_xdr_u_long(datapacket, &varToSet);
	if(Ov_Fail(result))
		return result;

	varToSet = KSXDR_PROGRAMVERSION;
	result = KS_DATAPACKET_write_xdr_u_long(datapacket, &varToSet);
	if(Ov_Fail(result))
		return result;

	result = KS_DATAPACKET_write_xdr_u_long(datapacket, &procedureNumber);
	if(Ov_Fail(result))
		return result;

	/*	rpc auth part (not used)	*/
	varToSet = XDR_AUTH_NONE;
	result = KS_DATAPACKET_write_xdr_u_long(datapacket, &varToSet);
	if(Ov_Fail(result))
		return result;

	result = KS_DATAPACKET_write_xdr_opaque(datapacket, NULL, 0);
	if(Ov_Fail(result))
		return result;

	varToSet = XDR_AUTH_NONE;
	result = KS_DATAPACKET_write_xdr_u_long(datapacket, &varToSet);
	if(Ov_Fail(result))
		return result;

	result = KS_DATAPACKET_write_xdr_opaque(datapacket, NULL, 0);
	if(Ov_Fail(result))
		return result;

	return OV_ERR_OK;
}

/*****************************************************************************************************************************************************************************
 * 						Tickets
 *****************************************************************************************************************************************************************************/
OV_RESULT ksxdr_insertTicket(KS_DATAPACKET* datapacket, const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator)
{
	OV_UINT varToSet;
	OV_VTBLPTR_ksbase_ClientTicketGenerator pVtblTicketGen = NULL;
	OV_RESULT result;

	if(!TicketGenerator)	/*	use none ticket if no Generator specified	*/
	{
		varToSet = OV_TT_NONE;
		result = KS_DATAPACKET_write_xdr_u_long(datapacket, &varToSet);
		if(Ov_Fail(result))
			return result;
	}
	else
	{
		result = KS_DATAPACKET_write_xdr_OV_TICKET_TYPE(datapacket, &(TicketGenerator->v_TicketType));
		if(Ov_Fail(result))
			return result;
		Ov_GetVTablePtr(ksbase_ClientTicketGenerator, pVtblTicketGen, TicketGenerator);
		if(!pVtblTicketGen)
			return OV_ERR_GENERIC;

		return pVtblTicketGen->m_encodeTicket(TicketGenerator, datapacket);
	}
	return OV_ERR_OK;
}

OV_RESULT ksxdr_readBackTicket(KS_DATAPACKET* datapacket, const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator)
{
	OV_RESULT result;
	OV_INT TicketType;
	OV_VTBLPTR_ksbase_ClientTicketGenerator pVtblTicketGen = NULL;

	result = KS_DATAPACKET_read_xdr_long(datapacket, &TicketType);
	if(Ov_Fail(result))
		return result;

	if(!TicketGenerator)
		if( TicketType == OV_TT_NONE)
			return OV_ERR_OK;
		else
			return OV_ERR_GENERIC;
	else
	{
		if(TicketGenerator->v_TicketType != TicketType)
			return OV_ERR_BADAUTH;
		else
		{
			Ov_GetVTablePtr(ksbase_ClientTicketGenerator, pVtblTicketGen, TicketGenerator);
			if(!pVtblTicketGen)
				return OV_ERR_GENERIC;
			return pVtblTicketGen->m_decodeReply(TicketGenerator, datapacket);
		}
	}
}

/*************************************************************************************************************************************************************
 * 	decode header of replies (params are not checked for NULL-pointers)
 *************************************************************************************************************************************************************/

OV_RESULT ksxdr_processServerReplyHeader(KS_DATAPACKET* datapacket, const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator,
		OV_UINT expectedXID, OV_BOOL usesStreamProtocol, OV_UINT* xid, OV_INT* msgAccepted, OV_INT* msgStatus, OV_UINT* functionStatus)
{
	OV_VTBLPTR_ksbase_ClientTicketGenerator	pVtblTicketGenerator = NULL;
	OV_RESULT								result;
	OV_UINT									dummy;
	OV_BYTE*								BeginOfMessage;
	OV_UINT									header;
	OV_UINT									ticketindicator;

	*functionStatus = XDRCL_PROCANS_OK;
	BeginOfMessage = datapacket->readPT;

	if(usesStreamProtocol)
	{
		/*	header	*/
		result = KS_DATAPACKET_read_xdr_u_long(datapacket, &header);
		if(Ov_Fail(result))
			return result;
	}

	/*	xid	*/
	result = KS_DATAPACKET_read_xdr_u_long(datapacket, xid);
	if(Ov_Fail(result))
		return result;

	if(*xid != expectedXID)
	{
		*functionStatus = XDRCL_PROCANS_XIDMISSMATCH;
		KS_logfile_error(("xdrClient: xid (%lu) of received xdr does not match xid (%lu) of last request.", *xid, expectedXID));
		return OV_ERR_BADVALUE;
	}
	/*	messageType	*/
	result = KS_DATAPACKET_read_xdr_u_long(datapacket, &dummy);
	if(Ov_Fail(result))
		return result;
	if(dummy != KSXDR_MSGTYPE_REPLY)
	{
		KS_logfile_error(("xdrClient: received message is not a reply (type is: %0#4x)", dummy));
		return OV_ERR_BADVALUE;
	}
	/***************************************************************************************************************************************************************************
	 * checking if request is in the buffer completely, if not, return ERR_OK and wait until it is complete. While waiting set the receive timeout value to a few seconds
	 * 	(we received a fragmented package so there will come more data. if no data arrives within a second, we can assume the package is broken)
	 ***************************************************************************************************************************************************************************/
	if(usesStreamProtocol == TRUE)
	{
		if(!bufferHoldsCompleteRequest(datapacket, BeginOfMessage, &result))
		{
			if(Ov_Fail(result))
				return result;
			*functionStatus = XDRCL_PROCANS_INCOMPLETE;
			datapacket->readPT = BeginOfMessage; 	/*	reset the read pointer to the place where the message began (to be read again next time)	*/
			return OV_ERR_BADVALUE;		/*	get called again to process the request next time (if it is complete then).
													Yes, this could block the ClientHanlder for a longer time.	*/
		}

		/*
		 * unfragment large xdrs
		 */
		if(!(header & (0x80000000)))	/*	a 0x80 in the first byte means this is the last (or only in this case) fragment. 	*/
		{
			result = unfragmentXDRmessage(datapacket, BeginOfMessage);
			if(Ov_Fail(result))
				return result;

		}
	}


	/*	acceptance	*/
	result = KS_DATAPACKET_read_xdr_long(datapacket, msgAccepted);
	if(Ov_Fail(result))
		return result;
	if(*msgAccepted != XDR_MSG_ACCEPTED)
	{
		/*	rejected decode reason	*/
		/*	reason	*/
		result = KS_DATAPACKET_read_xdr_long(datapacket, msgStatus);
		if(Ov_Fail(result))
			return result;

		if(*msgStatus == XDR_DEN_AUTH_ERROR)
		{/*	rejection because of bad authentication
		 	 throw away 4 bytes (reason) --> we only know generic reasons*/
			datapacket->readPT += 4;

		}
		else
		{/*	rejection because of rpc mismatch --> throw away 8 bytes (version codes)	*/
			datapacket->readPT += 8;
		}
	}

	/*	message accepted	*/
	/*	auth verifier has to be no auth*/
	result = KS_DATAPACKET_read_xdr_u_long(datapacket, &dummy);
	if(Ov_Fail(result))
		return result;
	if(dummy)
	{
		KS_logfile_error(("xdrClient: received message with auth-type not NONE (type is: %0#4x)", dummy));
		return OV_ERR_BADVALUE;
	}

	result = KS_DATAPACKET_read_xdr_u_long(datapacket, &dummy);	/*	no auth data following (length 0)	*/
	if(Ov_Fail(result))
		return result;
	if(dummy)
	{
		KS_logfile_error(("xdrClient: received message with authentication data of length %u", dummy));
		return OV_ERR_BADAUTH;
	}

	/*	message state	*/
	result = KS_DATAPACKET_read_xdr_long(datapacket, msgStatus);
	if(Ov_Fail(result))
		return result;

	if(*msgStatus != XDR_MSGST_SUCCESS)
	{	/*	processing failed	*/
		if(*msgStatus == XDR_MSGST_PROG_MISMATCH)
		{/*rejection because of program version mismatch --> throw away 8 bytes (version numbers)	*/
			datapacket->readPT += 8;
		}
		return OV_ERR_OK;
	}

	/*	handle tickets (call readBack)	*/
	result = KS_DATAPACKET_read_xdr_u_long(datapacket, &ticketindicator);
	if(Ov_Fail(result))
		return result;
	if(ticketindicator)	/*	TicketType != none	*/
	{
		if(!TicketGenerator)
		{
			KS_logfile_error(("processing reply header: found a ticket but no TicketGenerator associated."));
			return OV_ERR_GENERIC;
		}
		Ov_GetVTablePtr(ksbase_ClientTicketGenerator, pVtblTicketGenerator, TicketGenerator);
		if(!pVtblTicketGenerator)
		{
			KS_logfile_error(("processing reply header. ticket part. could not get VtablePointer of %s", TicketGenerator->v_identifier));
			return OV_ERR_GENERIC;
		}
		return pVtblTicketGenerator->m_decodeReply(TicketGenerator, datapacket);
	}

	/*	global part finished	*/
	return OV_ERR_OK;
}

/*******************************************************************************************************************************************************************************
 * 				register
 ******************************************************************************************************************************************************************************/

OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_requestRegister(
		const OV_INSTPTR_ksbase_ClientBase this,
		const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator,
		const OV_STRING servername,
		const OV_UINT	version,
		const OV_UINT port,
		const OV_UINT ttl,
		const OV_INSTPTR_ov_domain	callbackThat,
		void (*callback)(const OV_INSTPTR_ov_domain this, const OV_INSTPTR_ov_domain that)
) {
	/*
	 *   local variables
	 */
	OV_RESULT result;
	OV_UINT varToSet;
	OV_UINT msgindex = 0;
	OV_INSTPTR_ksxdr_xdrClient thisCl = Ov_StaticPtrCast(ksxdr_xdrClient, this);
	OV_INSTPTR_ksbase_Channel	pChannel = NULL;
	OV_VTBLPTR_ksbase_Channel	pVtblChannel = NULL;

	if((thisCl->v_state != KSBASE_CLST_COMPLETED) && (thisCl->v_state != KSBASE_CLST_INITIAL))
		return OV_ERR_NOACCESS;

	/*	set callback function	*/
	thisCl->v_callback.instanceCalled = callbackThat;
	thisCl->v_callback.callbackFunction = callback;

	/*	get pointer to channel and to its Vtable	*/
	result = getChannelPointer(thisCl, &pChannel, &pVtblChannel);
	if(Ov_Fail(result))
	{
		KS_logfile_error(("%s: Could not get Channel pointers.", this->v_identifier));
		return result;
	}
	if(!pChannel || !pVtblChannel)
	{
		KS_logfile_warning(("%s: No Channel found and none should be created. Will do nothing.", this->v_identifier));
		return OV_ERR_OK;
	}

	do{	/*	using a do...while(0) to run this block once and be able to use break-directives to jump out when an error occurs	*/

		/*	generate Header	*/
		result = ksxdr_generateClientMessageHeader(KS_REGISTER, pChannel->v_usesStreamProtocol, &(pChannel->v_outData), &(thisCl->v_sentXID), &msgindex);
		if(Ov_Fail(result))
			break;

		/*	insert Ticket, for register, we use always the none-ticket	*/
		result = ksxdr_insertTicket(&(pChannel->v_outData), TicketGenerator);
		if(Ov_Fail(result))
			break;

		/*	name	*/
		result = KS_DATAPACKET_write_xdr_string(&(pChannel->v_outData), &servername);
		if(Ov_Fail(result))
			break;

		/*	lowest needed version	*/
		result = KS_DATAPACKET_write_xdr_u_long(&(pChannel->v_outData), &version);
		if(Ov_Fail(result))
			break;

		/*	port	*/
		result = KS_DATAPACKET_write_xdr_u_long(&(pChannel->v_outData), &port);
		if(Ov_Fail(result))
			break;

		/*	time to live	*/
		varToSet = 30;	/*	30 seconds ttl	*/
		result = KS_DATAPACKET_write_xdr_u_long(&(pChannel->v_outData), &varToSet);
		if(Ov_Fail(result))
			break;
		/*	set length (if necessary)	*/
		if(pChannel->v_usesStreamProtocol)
			ksxdr_prepend_length(&(pChannel->v_outData), msgindex);

	}while(0);
	if(Ov_Fail(result))
	{
		ksbase_free_KSDATAPACKET(&(pChannel->v_outData));
		return result;
	}

	/*	send created Message	*/
	result = initiateConnection(thisCl, pChannel, pVtblChannel, TRUE, NULL, thisCl->v_ManagerPort);
	if(Ov_Fail(result))
	{
		ksbase_free_KSDATAPACKET(&(pChannel->v_outData));
		return result;
	}

	result = trySend(thisCl, pChannel, pVtblChannel);
	if(Ov_Fail(result))
		return result;


	thisCl->v_sentProcID = KS_REGISTER;

	return OV_ERR_OK;

}

OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_processRegister(
		const OV_INSTPTR_ksbase_ClientBase this,
		const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator,
		OV_RESULT* result
) {
	OV_INSTPTR_ksxdr_xdrClient thisCl = Ov_StaticPtrCast(ksxdr_xdrClient, this);
	return KS_DATAPACKET_read_xdr_OV_RESULT(&(thisCl->v_dataReceived), result);
}

/*******************************************************************************************************************************************************************************
 * 				un-register
 ******************************************************************************************************************************************************************************/

OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_requestUnRegister(
		const OV_INSTPTR_ksbase_ClientBase this,
		const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator,
		const OV_STRING servername,
		const OV_UINT version,
		const OV_INSTPTR_ov_domain	callbackThat,
		void (*callback)(const OV_INSTPTR_ov_domain this, const OV_INSTPTR_ov_domain that)
) {
	/*
	 *   local variables
	 */
	OV_RESULT result = OV_ERR_OK;
	OV_UINT varToSet;


	/*	set ticket Type, for unregister, we use always the none-ticket	*/
	varToSet = OV_TT_NONE;
	//result = KS_DATAPACKET_write_xdr_u_long(datapacket, &varToSet);
	if(Ov_Fail(result))
		return result;

	/*	name	*/
//	result = KS_DATAPACKET_write_xdr_string(datapacket, &servername);
	if(Ov_Fail(result))
		return result;

	/*	server version	*/
	//return KS_DATAPACKET_write_xdr_u_long(datapacket, &version);
	return OV_ERR_OK;

}

OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_processUnRegister(
		const OV_INSTPTR_ksbase_ClientBase this,
		const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator,
		OV_RESULT* result
) {
	/*
	 *   local variables
	 */

	OV_INSTPTR_ksxdr_xdrClient thisCl = Ov_StaticPtrCast(ksxdr_xdrClient, this);
	return KS_DATAPACKET_read_xdr_OV_RESULT(&(thisCl->v_dataReceived), result);
}

/*******************************************************************************************************************************************************************************
 * 				getserver
 ******************************************************************************************************************************************************************************/

OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_requestGetServer(
		const OV_INSTPTR_ksbase_ClientBase this,
		const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator,
		const OV_STRING servername,
		const OV_UINT leastVersion,
		const OV_INSTPTR_ov_domain	callbackThat,
		void (*callback)(const OV_INSTPTR_ov_domain this, const OV_INSTPTR_ov_domain that)
) {
	/*
	 *   local variables
	 */
	OV_RESULT result = OV_ERR_OK;

	/*	Tickethandling	*/
	//result = ksxdr_insertTicket(datapacket, TicketGenerator);
	if(Ov_Fail(result))
		return result;

	/* name	*/
	//result = KS_DATAPACKET_write_xdr_string(datapacket, &servername);
	if(Ov_Fail(result))
		return result;

	/*	least version	*/
	//result = KS_DATAPACKET_write_xdr_u_long(datapacket, &leastVersion);
	if(Ov_Fail(result))
		return result;

	return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_processGetServer(
		const OV_INSTPTR_ksbase_ClientBase this,
		const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator,
		OV_RESULT* result,
		OV_STRING* servername,
		OV_UINT* regVersion,
		OV_STRING* port,
		OV_TIME* expirationTime,
		OV_UINT* serverState
) {
	/*
	 *   local variables
	 */
	OV_RESULT fncresult = 0;
	OV_UINT xdr_port = 0;

	/*	Tickethandling	*/
//	fncresult = ksxdr_readBackTicket(datapacket, TicketGenerator);
	if(Ov_Fail(result))
		return fncresult;

//	fncresult = KS_DATAPACKET_read_xdr_OV_RESULT(datapacket, result);
	if(Ov_Fail(fncresult))
		return fncresult;

	/*	servername	*/
//	fncresult = KS_DATAPACKET_read_xdr_string_tomemstack_wolength(datapacket, servername);
	if(Ov_Fail(fncresult))
		return fncresult;
	/*	version	*/
//	fncresult = KS_DATAPACKET_read_xdr_u_long(datapacket, regVersion);
	if(Ov_Fail(fncresult))
		return fncresult;
	/*	port	*/
//	fncresult = KS_DATAPACKET_read_xdr_u_long(datapacket, &xdr_port);
	if(Ov_Fail(fncresult))
		return fncresult;
	*port = ov_memstack_alloc(12 * sizeof(char));
	if(!(*port))
		return OV_ERR_HEAPOUTOFMEMORY;
	sprintf(*port, "%lu", xdr_port);

	/*	Expiration Time	*/
//	fncresult = KS_DATAPACKET_read_xdr_u_long(datapacket, &(expirationTime->secs));
	if(Ov_Fail(fncresult))
		return fncresult;
//	fncresult = KS_DATAPACKET_read_xdr_u_long(datapacket, &(expirationTime->usecs));
	if(Ov_Fail(fncresult))
		return fncresult;

	/*	state	*/
//	return KS_DATAPACKET_read_xdr_u_long(datapacket, serverState);
	return OV_ERR_OK;
}

/*******************************************************************************************************************************************************************************
 * 				getPP
 ******************************************************************************************************************************************************************************/

OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_requestGetPP(
		const OV_INSTPTR_ksbase_ClientBase this,
		const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator,
		const OV_STRING path,
		const OV_OBJ_TYPE typeMask,
		const OV_STRING	nameMask,
		const OV_UINT dummy,
		const OV_INSTPTR_ov_domain	callbackThat,
		void (*callback)(const OV_INSTPTR_ov_domain this, const OV_INSTPTR_ov_domain that)
) {
	/*
	 *   local variables
	 */

	return OV_ERR_NOTIMPLEMENTED;
}

OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_processGetPP(
		const OV_INSTPTR_ksbase_ClientBase this,
		const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator,
		OV_RESULT* result,
		OV_UINT* items_len,
		OV_OBJ_PROJECTED_PROPS* items_val
) {
	/*
	 *   local variables
	 */

	return OV_ERR_NOTIMPLEMENTED;
}

/*******************************************************************************************************************************************************************************
 * 				getEP
 ******************************************************************************************************************************************************************************/

OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_requestGetEP(
		const OV_INSTPTR_ksbase_ClientBase this,
		const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator,
		const OV_STRING path,
		const OV_OBJ_TYPE typeMask,
		const OV_STRING	nameMask,
		const OV_EP_FLAGS scopeFlags,
		const OV_INSTPTR_ov_domain	callbackThat,
		void (*callback)(const OV_INSTPTR_ov_domain this, const OV_INSTPTR_ov_domain that)
) {
	/*
	 *   local variables
	 */

	return OV_ERR_NOTIMPLEMENTED;
}

OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_processGetEP(
		const OV_INSTPTR_ksbase_ClientBase this,
		const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator,
		OV_RESULT* result,
		OV_UINT* items_len,
		OV_OBJ_ENGINEERED_PROPS* items_val
) {
	/*
	 *   local variables
	 */

	return OV_ERR_NOTIMPLEMENTED;
}

/*******************************************************************************************************************************************************************************
 * 				getVar
 ******************************************************************************************************************************************************************************/

OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_requestGetVar(
		const OV_INSTPTR_ksbase_ClientBase this,
		const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator,
		const OV_UINT items_length,
		const OV_STRING* paths,
		const OV_INSTPTR_ov_domain	callbackThat,
		void (*callback)(const OV_INSTPTR_ov_domain this, const OV_INSTPTR_ov_domain that)
) {
	/*
	 *   local variables
	 */

	return OV_ERR_NOTIMPLEMENTED;
}

OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_processGetVar(
		const OV_INSTPTR_ksbase_ClientBase this,
		const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator,
		OV_RESULT* result,
		OV_UINT* items_len,
		OV_VAR_CURRENT_PROPS* items_val
) {
	/*
	 *   local variables
	 */

	return OV_ERR_NOTIMPLEMENTED;
}

/*******************************************************************************************************************************************************************************
 * 				setVar
 ******************************************************************************************************************************************************************************/

OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_requestSetVar(
		const OV_INSTPTR_ksbase_ClientBase this,
		const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator,
		const OV_UINT items_length,
		const OV_SETVAR_ITEM* items_val,
		const OV_INSTPTR_ov_domain	callbackThat,
		void (*callback)(const OV_INSTPTR_ov_domain this, const OV_INSTPTR_ov_domain that)
) {
	/*
	 *   local variables
	 */

	return OV_ERR_NOTIMPLEMENTED;
}

OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_processSetVar(
		const OV_INSTPTR_ksbase_ClientBase this,
		const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator,
		OV_RESULT* result,
		OV_UINT* items_length,
		OV_RESULT* items_results
) {
	/*
	 *   local variables
	 */

	return OV_ERR_NOTIMPLEMENTED;
}

/*******************************************************************************************************************************************************************************
 * 				getCanonicalPath
 ******************************************************************************************************************************************************************************/

OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_requestGetCanonicalPath(
		const OV_INSTPTR_ksbase_ClientBase this,
		const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator,
		const OV_UINT items_length,
		const OV_STRING* paths,
		const OV_INSTPTR_ov_domain	callbackThat,
		void (*callback)(const OV_INSTPTR_ov_domain this, const OV_INSTPTR_ov_domain that)
) {
	/*
	 *   local variables
	 */

	return OV_ERR_NOTIMPLEMENTED;
}

OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_processGetCanonicalPath(
		const OV_INSTPTR_ksbase_ClientBase this,
		const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator,
		OV_RESULT* result,
		OV_UINT* items_length,
		OV_RESULT* items_results,
		OV_STRING* items_canonicalPaths
) {
	/*
	 *   local variables
	 */

	return OV_ERR_NOTIMPLEMENTED;
}

/*******************************************************************************************************************************************************************************
 * 				createObject
 ******************************************************************************************************************************************************************************/

OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_requestCreateObject(
		const OV_INSTPTR_ksbase_ClientBase this,
		const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator,
		const OV_UINT items_length,
		const OV_CREATEOBJ_ITEM* items_val,
		const OV_INSTPTR_ov_domain	callbackThat,
		void (*callback)(const OV_INSTPTR_ov_domain this, const OV_INSTPTR_ov_domain that)
) {
	/*
	 *   local variables
	 */

	return OV_ERR_NOTIMPLEMENTED;
}

OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_processCreateObject(
		const OV_INSTPTR_ksbase_ClientBase this,
		const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator,
		OV_RESULT* result,
		OV_UINT* items_length,
		OV_CREATEOBJECTITEM_RES* items_val
) {
	/*
	 *   local variables
	 */

	return OV_ERR_NOTIMPLEMENTED;
}

/*******************************************************************************************************************************************************************************
 * 				deleteobject
 ******************************************************************************************************************************************************************************/

OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_requestDeleteObject(
		const OV_INSTPTR_ksbase_ClientBase this,
		const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator,
		const OV_UINT items_length,
		const OV_STRING* paths,
		const OV_INSTPTR_ov_domain	callbackThat,
		void (*callback)(const OV_INSTPTR_ov_domain this, const OV_INSTPTR_ov_domain that)
) {
	/*
	 *   local variables
	 */

	return OV_ERR_NOTIMPLEMENTED;
}

OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_processDeleteObject(
		const OV_INSTPTR_ksbase_ClientBase this,
		const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator,
		OV_RESULT* result,
		OV_UINT* items_length,
		OV_RESULT* items_results
) {
	/*
	 *   local variables
	 */

	return OV_ERR_NOTIMPLEMENTED;
}

/*******************************************************************************************************************************************************************************
 * 				renameObject
 ******************************************************************************************************************************************************************************/

OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_requestRenameObject(
		const OV_INSTPTR_ksbase_ClientBase this,
		const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator,
		const OV_UINT items_length,
		const OV_RENAMEOBJECT_ITEM* items_val,
		const OV_INSTPTR_ov_domain	callbackThat,
		void (*callback)(const OV_INSTPTR_ov_domain this, const OV_INSTPTR_ov_domain that)
) {
	/*
	 *   local variables
	 */

	return OV_ERR_NOTIMPLEMENTED;
}

OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_processRenameObject(
		const OV_INSTPTR_ksbase_ClientBase this,
		const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator,
		OV_RESULT* result,
		OV_UINT* items_length,
		OV_RESULT* items_results
) {
	/*
	 *   local variables
	 */

	return OV_ERR_NOTIMPLEMENTED;
}

/*******************************************************************************************************************************************************************************
 * 				link
 ******************************************************************************************************************************************************************************/

OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_requestLink(
		const OV_INSTPTR_ksbase_ClientBase this,
		const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator,
		const OV_UINT items_length,
		const OV_LINK_ITEM teims_val,
		const OV_INSTPTR_ov_domain	callbackThat,
		void (*callback)(const OV_INSTPTR_ov_domain this, const OV_INSTPTR_ov_domain that)
) {
	/*
	 *   local variables
	 */

	return OV_ERR_NOTIMPLEMENTED;
}

OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_processLink(
		const OV_INSTPTR_ksbase_ClientBase this,
		const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator,
		OV_RESULT* result,
		OV_UINT* items_length,
		OV_RESULT* items_results
) {
	/*
	 *   local variables
	 */

	return OV_ERR_NOTIMPLEMENTED;
}

/*******************************************************************************************************************************************************************************
 * 				unlink
 ******************************************************************************************************************************************************************************/

OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_requestUnLink(
		const OV_INSTPTR_ksbase_ClientBase this,
		const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator,
		const OV_UINT items_length,
		const OV_STRING* link_paths,
		const OV_STRING* element_paths,
		const OV_INSTPTR_ov_domain	callbackThat,
		void (*callback)(const OV_INSTPTR_ov_domain this, const OV_INSTPTR_ov_domain that)
) {
	/*
	 *   local variables
	 */

	return OV_ERR_NOTIMPLEMENTED;
}

OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_processUnLink(
		const OV_INSTPTR_ksbase_ClientBase this,
		const OV_INSTPTR_ksbase_ClientTicketGenerator TicketGenerator,
		OV_RESULT* result,
		OV_UINT* items_length,
		OV_RESULT* items_results
) {
	/*
	 *   local variables
	 */

	return OV_ERR_NOTIMPLEMENTED;
}

/*******************************************************************************************************************************************************************************
 * 				typemethod
 *******************************************************************************************************************************************************************************/

OV_DLLFNCEXPORT void ksxdr_xdrClient_typemethod (
	OV_INSTPTR_ksbase_ComTask	this
) {
	OV_INSTPTR_ksxdr_xdrClient	thisCl = Ov_StaticPtrCast(ksxdr_xdrClient, this);
	OV_INSTPTR_ksbase_Channel	pChannel = NULL;
	OV_VTBLPTR_ksbase_Channel	pVtblChannel = NULL;
	OV_TIME						now;
	OV_TIME_SPAN				tstemp;
	OV_RESULT					result;

	/*
	 * state machine
	 */
	switch(thisCl->v_state)
	{
	case KSBASE_CLST_AWAITINGCONNECTION:	/*	check if connection is open now. if so, send. otherwise calculate timeout and return	*/
		/*	get pointer to channel and to its Vtable	*/
		result = getChannelPointer(thisCl, &pChannel, &pVtblChannel);
		if(Ov_Fail(result))
		{
			KS_logfile_error(("%s: Could not get Channel pointers.", this->v_identifier));
			return;
		}
		result = trySend(thisCl, pChannel, pVtblChannel);
		if(Ov_Fail(result))
			return;

		ov_time_gettime(&now);
		ov_time_diff(&tstemp, &now, &(thisCl->v_timeLastEvent));
		if((tstemp.secs > thisCl->v_timeout) || ((tstemp.secs == thisCl->v_timeout) && (tstemp.usecs > 0)))
		{
			thisCl->v_state = KSBASE_CLST_ERROR | XDRCL_TIMEOUT;
			thisCl->v_actimode = 0;
			ksbase_free_KSDATAPACKET(&(thisCl->v_dataToSend));
			ksbase_free_KSDATAPACKET(&(pChannel->v_outData));
		}
		return;

	case KSBASE_CLST_AWAITINGANSWER:	/*	waiting for answer --> just calculate timeouts	*/
			ov_time_gettime(&now);
			ov_time_diff(&tstemp, &now, &(thisCl->v_timeLastEvent));
			if((tstemp.secs > thisCl->v_timeout) || ((tstemp.secs == thisCl->v_timeout) && (tstemp.usecs > 0)))
			{
				thisCl->v_state = KSBASE_CLST_ERROR | XDRCL_TIMEOUT;
				thisCl->v_actimode = 0;
				ksbase_free_KSDATAPACKET(&(thisCl->v_dataToSend));
			}
			return;

	case KSBASE_CLST_BUSY:	/*	call HandleData again to process data	*/
			/*	calculate timeout	*/
		ov_time_gettime(&now);
		ov_time_diff(&tstemp, &now, &(thisCl->v_timeLastEvent));
		if((tstemp.secs > thisCl->v_timeout) || ((tstemp.secs == thisCl->v_timeout) && (tstemp.usecs > 0)))
		{
			thisCl->v_state = KSBASE_CLST_ERROR | XDRCL_TIMEOUT;
			thisCl->v_actimode = 0;
			ksbase_free_KSDATAPACKET(&(thisCl->v_dataToSend));
			return;
		}
		/*	get pointer to channel and to its Vtable	*/
		result = getChannelPointer(thisCl, &pChannel, &pVtblChannel);
		if(Ov_Fail(result))
		{
			KS_logfile_error(("%s: Could not get Channel pointers.", this->v_identifier));
			return;
		}
		/*	HadleData will do the state change to COMPLETED if the header could be processed and the message is completely received	*/
		result = ksxdr_xdrClient_HandleData(Ov_StaticPtrCast(ksbase_DataHandler, this), &(pChannel->v_inData), NULL);
		if(Ov_Fail(result))
		{
			thisCl->v_state = KSBASE_CLST_ERROR;
			thisCl->v_actimode = 0;
		}
		break;

	case KSBASE_CLST_COMPLETED:	/*	issue the callback	*/
		thisCl->v_actimode = 0;
		KS_logfile_debug(("%s: completed. issuing callback", thisCl->v_identifier));
		thisCl->v_callback.callbackFunction(thisCl->v_callback.instanceCalled, Ov_StaticPtrCast(ov_domain, this));

		if(!thisCl->v_holdConnection)	/*	close connection if not otherwise specified	*/
		{
			result = getChannelPointer(thisCl, &pChannel, &pVtblChannel);
			if(Ov_Fail(result))
			{
				KS_logfile_error(("%s: Could not get Channel pointers.", this->v_identifier));
				return;
			}

			pVtblChannel->m_CloseConnection(pChannel);
		}
		return;

	case KSBASE_CLST_ERROR:
		thisCl->v_actimode = 0;
		return;

	default:
		KS_logfile_debug(("entering default in xdrClient typemethod - this should not happen"));
		thisCl->v_actimode = 0;
		break;
	}

	return;
}

/*******************************************************************************************************************************************************************************
 * 				HandleData
 *******************************************************************************************************************************************************************************/
OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_HandleData(
	OV_INSTPTR_ksbase_DataHandler this,
	KS_DATAPACKET* dataReceived,
	KS_DATAPACKET* answer
) {
	OV_INSTPTR_ksxdr_xdrClient				thisCl = Ov_StaticPtrCast(ksxdr_xdrClient, this);
	OV_INSTPTR_ksbase_Channel				pChannel = NULL;
	OV_INSTPTR_ksbase_ClientTicketGenerator	pTicketGenerator = NULL;
	OV_UINT									xid;
	OV_RESULT								result;
	OV_UINT									procHeaderStatus;

	/*	process header and generic stuff	*/
	pChannel = Ov_GetParent(ksbase_AssocChannelDataHandler, thisCl);
	if(!pChannel)
	{
		KS_logfile_error(("%s: HandleData: no Channel object associated. cannot process data.", this->v_identifier));
		return OV_ERR_GENERIC;
	}

	pTicketGenerator = Ov_GetChild(ksbase_AssocClientToTicketGenerator, thisCl);

	KS_logfile_debug(("length of XDR: %lu\ndata: %p\nreadPT: %p\n", dataReceived->length, dataReceived->data, dataReceived->readPT));

	result = ksxdr_processServerReplyHeader(dataReceived, pTicketGenerator, thisCl->v_sentXID, pChannel->v_usesStreamProtocol, &xid, &(thisCl->v_msgAccepted),
			&(thisCl->v_msgStatus), &procHeaderStatus);
	KS_logfile_debug(("length of XDR: %lu\nreadPT - data: %lu\n", dataReceived->length, dataReceived->readPT-dataReceived->data));
	if(Ov_Fail(result))	/*	processing header failed	*/
	{
		if(procHeaderStatus == XDRCL_PROCANS_INCOMPLETE)
		{	/*	message incomplete --> keep waiting	*/
			thisCl->v_state = KSBASE_CLST_BUSY;
			thisCl->v_actimode = 1;
			return OV_ERR_OK;
		}
		if(procHeaderStatus == XDRCL_PROCANS_XIDMISSMATCH)
		{	/*	XID missmatch detected. free data, deactivate typemethod and set state to error	*/
			KS_logfile_error(("%s: HandleData: XID missmatch detected.", this->v_identifier));
			ksbase_free_KSDATAPACKET(dataReceived);
			thisCl->v_state = KSBASE_CLST_ERROR;
			thisCl->v_actimode = 0;
		}
		return result;
	}

	/*	handling message acceptance and status	*/
	if(thisCl->v_msgAccepted != XDR_MSG_ACCEPTED || thisCl->v_msgStatus != XDR_MSGST_SUCCESS)
	{
		KS_logfile_error(("%s: HandleData: server replied message denied or did not succeed in processing.", this->v_identifier));
		ksbase_free_KSDATAPACKET(dataReceived);
		thisCl->v_state = KSBASE_CLST_ERROR;
		thisCl->v_actimode = 0;
	}
	else
	{
		/*	global part finished. copy data from dataReceived to this->v_dataReveived	*/
		result = ksbase_KSDATAPACKET_append(&(thisCl->v_dataReceived), dataReceived->readPT, (dataReceived->length - (dataReceived->readPT - dataReceived->data)));
		if(Ov_Fail(result))
			return result;
		ksbase_free_KSDATAPACKET(dataReceived);
		thisCl->v_state = KSBASE_CLST_COMPLETED;
		thisCl->v_actimode = 1;
	}
	return OV_ERR_OK;
}

/*******************************************************************************************************************************************************************************
 * 				Startup
 *******************************************************************************************************************************************************************************/

OV_DLLFNCEXPORT void ksxdr_xdrClient_startup(
	OV_INSTPTR_ov_object 	pobj
) {
    /*
    *   local variables
    */
    OV_INSTPTR_ksxdr_xdrClient this = Ov_StaticPtrCast(ksxdr_xdrClient, pobj);

    /* do what the base class does first */
    ov_object_startup(pobj);

    /* do what */
    this->v_dataReceived.data = NULL;
    this->v_dataReceived.length = 0;
    this->v_dataReceived.readPT = NULL;
    this->v_dataReceived.writePT = NULL;
    this->v_dataToSend.data = NULL;
    this->v_dataToSend.length = 0;
    this->v_dataToSend.readPT = NULL;
    this->v_dataToSend.writePT = NULL;
    return;
}

/*******************************************************************************************************************************************************************************
 * 				Shutdown
 *******************************************************************************************************************************************************************************/

OV_DLLFNCEXPORT void ksxdr_xdrClient_shutdown(
	OV_INSTPTR_ov_object 	pobj
) {
	/*
	 *   local variables
	 */
	OV_INSTPTR_ksbase_ClientBase this = Ov_StaticPtrCast(ksbase_ClientBase, pobj);
	/* do what */

	ksxdr_xdrClient_reset(this);
	this->v_cycInterval = 1000000;
	/* set the object's state to "shut down" */
	ov_object_shutdown(pobj);


    return;
}

/*******************************************************************************************************************************************************************************
 * 				Reset
 *******************************************************************************************************************************************************************************/

OV_DLLFNCEXPORT OV_RESULT ksxdr_xdrClient_reset(OV_INSTPTR_ksbase_ClientBase this)
{
	OV_INSTPTR_ksxdr_xdrClient	thisCl = Ov_StaticPtrCast(ksxdr_xdrClient, this);
	OV_RESULT					result;
	OV_INSTPTR_ksbase_Channel 	pChannel = NULL;
	OV_VTBLPTR_ksbase_Channel	pVtblChannel = NULL;

	ksbase_free_KSDATAPACKET(&(thisCl->v_dataReceived));
	ksbase_free_KSDATAPACKET(&(thisCl->v_dataToSend));

	thisCl->v_callback.instanceCalled = NULL;
	thisCl->v_callback.callbackFunction = NULL;

	thisCl->v_actimode = 0;
	thisCl->v_msgAccepted = 0;
	thisCl->v_msgStatus = 0;
	thisCl->v_rpcErrCode = 0;
	thisCl->v_runningKSservice = 0;
	thisCl->v_sentProcID = 0;
	thisCl->v_sentXID = 0;
	thisCl->v_state = KSBASE_CLST_INITIAL;

	ov_string_setvalue(&(thisCl->v_serverPort), "");

	result = getChannelPointer(thisCl, &pChannel, &pVtblChannel);
	if(Ov_Fail(result))
	{
		KS_logfile_error(("%s: Could not get Channel pointers.", this->v_identifier));
		return result;
	}
	pVtblChannel->m_CloseConnection(pChannel);

	return OV_ERR_OK;
}
