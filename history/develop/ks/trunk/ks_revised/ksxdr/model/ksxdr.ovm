#include "ov.ovm"
#include "ksbase.ovm"

LIBRARY ksxdr
	VERSION   = "V0.1 (28-Jan-2013)";
	AUTHOR    = "Lars Evertz";
	COPYRIGHT = "Lehrstuhl für Prozessleittechnik, RWTH Aachen University";
	COMMENT   = "Library for handling ks-requests in XDR-format";
	
	/**
	 *	Checks whether received data is conforming to the ks-xdr protocol
	 *	Criteria are: first byte equals 0x00 (not finished stream-fragment) or 0x80 (last stream-fragment) and program number equals ks program number
	 *	ks-program number is 0x49678 (obtained from Sun)		
	 */
	CLASS xdrIdentificator : CLASS ksbase/ProtocolIdentificator
		IS_INSTANTIABLE;
		COMMENT = "class for identifing xdr-ks communication";
		VARIABLES
			ksProgramnumber	: UINT	
				COMMENT	=	"identification number of ks requests (obtained from Sun). KS RPC program number is 0x49678 (DEC: 300664)"
				INITIALVALUE	=	300664;				/*	0x49678	*/
		END_VARIABLES;
		OPERATIONS
			identify		:	C_FUNCTION <KSBASE_FNC_IDENTIFY>;
			createClientHandler	:	C_FUNCTION	<KSBASE_FNC_CREATECH>;
		END_OPERATIONS;
	END_CLASS;
	
	CLASS xdrClientHandler	:	CLASS ksbase/ClientHandler
	IS_INSTANTIABLE;
	COMMENT	=	"Handler for XDR-ks clients. Processes XDR-messages and calls the respective operations (GETEP, GETVAR, etc.)";
	OPERATIONS
		startup			:	C_FUNCTION <OV_FNC_STARTUP>;
		shutdown		:	C_FUNCTION	<OV_FNC_SHUTDOWN>;
		/**
		 *	The HandleRequest function is called by a Channel after some data has arrived for this ClientHandler. It gets the pointer to the Channel, a pointer to the received data, and a pointer to the outData variable.
		 *	As this functions gets the pointers to the buffers of the Channel object it has to take care of a few things:
		 *		1. If the input data could be processed or if it is invalid it should be freed.
		 *		2. The Writeptr of the received data may not be altered.
		 *		3. The answers always have to be appended to the answer structure (use the ksbase_KSDATAPACKET_append function).
		 *		4. The readptr of the answer data may not be altered.
		 */
		HandleRequest	:	C_FUNCTION	<KSBASE_FNC_HANDLEREQUEST>;	
	END_OPERATIONS;	
	END_CLASS;
	
	CLASS xdrSimpleTicketAuthenticator	:	CLASS ksbase/TicketAuthenticator
	IS_INSTANTIABLE;
	COMMENT	=	"Authenticator for simple tickets transportes via ks-xdr";
	OPERATIONS
		constructor		:	C_FUNCTION	<OV_FNC_CONSTRUCTOR>;
 		startup			:	C_FUNCTION	<OV_FNC_STARTUP>;
 		shutdown		:	C_FUNCTION	<OV_FNC_SHUTDOWN>;
		/*
 		*	These functions conform to the prototypes in a OV_TICKET_VTBL they are linked to the ticket itself to conform to ov-standards.
 		*	The functions do NOT get a this-pointer. Hence TicketAuthenticators have to be Singletons!!! 
 		*/
 		createticket	:	C_FUNCTION	<KSBASE_FNC_CREATETICKET>;
 		deleteticket	:	C_FUNCTION	<KSBASE_FNC_DELETETICKET>;
		encodereply		:	C_FUNCTION	<KSBASE_FNC_ENCODEREPLY>;
		TicketGetaccess		:	C_FUNCTION	<KSBASE_FNC_GETACCESS>;
	END_OPERATIONS;	
	END_CLASS;
	
	
	CLASS xdrManagerCom	:	CLASS ksbase/DataHandler
	IS_INSTANTIABLE;
	COMMENT	=	"Instances of this class register the server at the ks-Manager periodically. If not specified otherwise as commandline option a TCPChannel is used. If the server is Manager itself a direct ov shorcut is used.";
	VARIABLES
		ManagerPort	:	STRING
			COMMENT	=	"Port part of Manager address"
			INITIALVALUE = "7509";
		OwnPort		:	STRING
			COMMENT	=	"Port this server listens on"
			INITIALVALUE	=	"";
		UseShortCut	:	BOOL
			COMMENT	=	"use the ov-shortcut (do not create a channel)"
			INITIALVALUE = FALSE;
		RegisterState	:	UINT
			COMMENT	=	"State of registration: 0 not registered, 1 waiting for answer, 2 registered, 128 register error"
			INITIALVALUE = 0;
		ErrCode		:	INT
			COMMENT	=	"Error Code returned by register command"
			INITIALVALUE = 0;
		msgAccepted	:	INT
			COMMENT	=	"0 = message Accepted by server; otherwise: errorcode"
			INITIALVALUE = 0;
		msgStatus	:	INT
			COMMENT	=	"0 = message could be processed; otherwise: errorcode"
			INITIALVALUE = 0;
		rpcErrCode	:	INT
			COMMENT	=	"reasons for denial"
			INITIALVALUE = 0;
		Tries		:	UINT
			COMMENT	=	"Tries before successfull register. 5 is maximum"
			INITIALVALUE = 0;
		sentXID		:	UINT
			COMMENT	=	"xid of the request sent to be compared with the one of the reply"
			INITIALVALUE = 0;
		sentProcID	:	UINT
			COMMENT	=	"last requested procedure number (used to determine whether a register or an unregister reply is received)"
			INITIALVALUE = 0;
	END_VARIABLES;	
	OPERATIONS
		startup		:	C_FUNCTION	<OV_FNC_STARTUP>;
		shutdown	:	C_FUNCTION	<OV_FNC_SHUTDOWN>;
		HandleData	:	C_FUNCTION	<KSBASE_FNC_HANDLEDATA>;
		typemethod  :	C_FUNCTION	<KSBASE_FNC_TYPEMETHOD>;	
	END_OPERATIONS;
	END_CLASS;
	
	CLASS	xdrClient	:	CLASS	ksbase/ClientBase
		COMMENT	=	"message generation and reply processing for xdr protocol";
		OPERATIONS
			/**
			*	For each ks-service there is a generate function that generates the request message and a process function that processes the server's answer
			*/
			generateRegister	:	C_FUNCTION	<KSBASE_FNC_GENREG>;
			processRegister		:	C_FUNCTION	<KSBASE_FNC_PROCREG>;
			generateUnRegister	:	C_FUNCTION	<KSBASE_FNC_GENUNREG>;
			processUnRegister	:	C_FUNCTION	<KSBASE_FNC_PROCUNREG>;
			generateGetServer	:	C_FUNCTION	<KSBASE_FNC_GENGETSRV>;
			processGetServer	:	C_FUNCTION	<KSBASE_FNC_PROCGETSRV>;
			generateGetPP		:	C_FUNCTION	<KSBASE_FNC_GENGETPP>;
			processGetPP		:	C_FUNCTION	<KSBASE_FNC_PROCGETPP>;
			generateGetEP		:	C_FUNCTION	<KSBASE_FNC_GENGETEP>;
			processGetEP		:	C_FUNCTION	<KSBASE_FNC_PROCGETEP>;
			generateGetVar		:	C_FUNCTION	<KSBASE_FNC_GENGETVAR>;
			processGetVar		:	C_FUNCTION	<KSBASE_FNC_PROCGETVAR>;
			generateSetVar		:	C_FUNCTION	<KSBASE_FNC_GENSETVAR>;
			processSetVar		:	C_FUNCTION	<KSBASE_FNC_PROCSETVAR>;
			generateGetCanonicalPath		:	C_FUNCTION	<KSBASE_FNC_GENGETCANONPATH>;
			processGetCanonicalPath			:	C_FUNCTION	<KSBASE_FNC_PROCGECANONPATH>;
			generateCreateObject			:	C_FUNCTION	<KSBASE_FNC_GENCREATEOBJ>;
			processCreateObject				:	C_FUNCTION	<KSBASE_FNC_PROCCREATEOBJ>;
			generateDeleteObject			:	C_FUNCTION	<KSBASE_FNC_GENDELOBJ>;
			processDeleteObject				:	C_FUNCTION	<KSBASE_FNC_PROCDELOBJ>;
			generateRenameObject			:	C_FUNCTION	<KSBASE_FNC_GENRENAMEOBJ>;
			processRenameObject				:	C_FUNCTION	<KSBASE_FNC_PROCRENAMEOBJ>;
			generateLink		:	C_FUNCTION	<KSBASE_FNC_GENLINK>;
			processLink			:	C_FUNCTION	<KSBASE_FNC_PROCLINK>;
			generateUnLink		:	C_FUNCTION	<KSBASE_FNC_GENUNLINK>;
			processUnLink		:	C_FUNCTION	<KSBASE_FNC_PROCUNLINK>;
		END_OPERATIONS;
	END_CLASS;
	
END_LIBRARY;
