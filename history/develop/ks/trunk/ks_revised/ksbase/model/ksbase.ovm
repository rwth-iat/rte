#include "ov.ovm"

/**
 * Some Classes now have the Flag "v". This means volatile. 
 * This flag will be used in a clean-up function of the ov_runtimeserver to determine if an object needs to be deleted before the server starts up. 
 */

LIBRARY ksbase
	VERSION   = "V0.1 (15-01-2013)";
	AUTHOR    = "Lars Evertz";
	COPYRIGHT = "Lehrstuhl für Prozessleittechnik, RWTH Aachen University";
	COMMENT   = "Generic communication library. Offers tasking and basic management functions. It is independent of protocols and transport bindings.";
	
	////////////////// Scheduling / Tasking components

	CLASS RootComTask : CLASS ov/domain
		IS_INSTANTIABLE;
		COMMENT = "root communication task - cycling all connected tasks. ";
		VARIABLES
			cycsecs	: INT HAS_ACCESSORS  
				COMMENT	=	"seconds for scheduler registration. Please note that we do not calculate the amount of time spent - root task just pauses for this time intervall. If communications need too long there will be a jitter in other timings."
				INITIALVALUE	=	0;
			cycusecs: INT HAS_ACCESSORS  
				COMMENT	=	"usecs for scheduler registration"
				INITIALVALUE	=	1000;
		END_VARIABLES;
		OPERATIONS
			constructor	: C_FUNCTION <OV_FNC_CONSTRUCTOR>;
			startup     : C_FUNCTION <OV_FNC_STARTUP>; //registers execute at ov_scheduler 
			shutdown    : C_FUNCTION <OV_FNC_SHUTDOWN>;//deregisters execute at ov_scheduler
			getaccess	: C_FUNCTION <OV_FNC_GETACCESS>;		//just to make all variables visible on KS	
		END_OPERATIONS;
	END_CLASS;

	CLASS ComTask : CLASS ov/domain
		COMMENT = "communication task baseclass - get called typemethod every $cycInterval by root task. Functionality is implemented by derived classes";
		VARIABLES
			actimode: INT HAS_ACCESSORS 
				COMMENT	=	"0=inactive, 1=active"
				INITIALVALUE	=	1;
			cycIntervalCount	: INT HAS_GET_ACCESSOR
				COMMENT	=	"current wait cycles until next execution"
				INITIALVALUE	=	5;
			cycInterval		: INT HAS_ACCESSORS 
				COMMENT	=	"execution intervall of cycles of RootTasks"
				INITIALVALUE	=	5;
			NextExecTime	:	TIME 
				COMMENT	=	"time of next execution (if cycInterval !=0)";
		END_VARIABLES;
		OPERATIONS
			constructor : C_FUNCTION <OV_FNC_CONSTRUCTOR>; //creates assoc to roottask
			destructor  : C_FUNCTION <OV_FNC_DESTRUCTOR>;  //deletes assoc to roottask
			calcExec    : C_FUNCTION <KSBASE_FNC_CALCEXEC>;       //provides bool if typemethod need to be called. decreases cyc
								      //would be nice to do this check locally by overloading typemethod, by....
			typemethod  : C_FUNCTION <KSBASE_FNC_TYPEMETHOD>;     //gets called by roottask and should be implemented 
			getaccess	: C_FUNCTION <OV_FNC_GETACCESS>;		//just to make all variables visible on KS	
		END_OPERATIONS;
	END_CLASS;



///////////////////// Accessing currently calling client components
/* 
 * Hopefully some of these information is applicable to all clients
 * this is an interface class, which is inherited e.g. by xdrClientlientHandler and httpClientHandler
 * user applications could cast to this class and access information for 
 * determining the currently calling client
*/ 

	CLASS ClientHandler : CLASS ksbase/ComTask
		FLAGS	=	"v";
		COMMENT = "General clienthandler";
	 	VARIABLES
			sourceAdr : 	STRING HAS_GET_ACCESSOR 
				COMMENT	=	"Source adr of client (e.g. IP)";
			ovticket : 	STRING HAS_GET_ACCESSOR
				COMMENT	=	"Ticket - ONLY set during call from client - thus invisible!";
			receivedCalls : INT HAS_GET_ACCESSOR
				COMMENT	=	"Number of received calls from this client"; 
		END_VARIABLES;
		OPERATIONS
			startup			:	C_FUNCTION <OV_FNC_STARTUP>;
			shutdown		:	C_FUNCTION	<OV_FNC_SHUTDOWN>;
			/**
			 *	The HandleRequest function is called by a Channel after some data has arrived for this ClientHandler. It gets the pointer to the Channel, a pointer to the received data, and a pointer to the outData variable.
			 *	As this functions gets the pointers to the buffers of the Channel object it has to take care of a few things:
			 *		1. If the input data could be processed or if it is invalid it should be freed.
			 *		2. The Writeptr of the received data may not be altered.
			 *		3. The answers always have to be appended to the answer structure (use the ksbase_KSDATAPACKET_append function).
			 *		4. The readptr of the answer data may not be altered.
			 */
			HandleRequest	:	C_FUNCTION	<KSBASE_FNC_HANDLEREQUEST>;	
		END_OPERATIONS;
	END_CLASS;
	
	CLASS DataHandler : CLASS ksbase/ComTask
		COMMENT = "DataHandler used for callbacks";
	 	OPERATIONS
			/**
			 *	The HandleData function is called by a Channel after some data has arrived for this DataHandler. It gets the pointer to the Channel, a pointer to the received data, and a pointer to the outData variable.
			 *	As this functions gets the pointers to the buffers of the Channel object it has to take care of a few things:
			 *		1. If the input data could be processed or if it is invalid it should be freed.
			 *		2. The Writeptr of the received data may not be altered.
			 *		3. The answers always have to be appended to the answer structure (use the ksbase_KSDATAPACKET_append function).
			 *		4. The readptr of the answer data may not be altered.
			 */
			HandleData	:	C_FUNCTION	<KSBASE_FNC_HANDLEDATA>;	
		END_OPERATIONS;
	END_CLASS;

/**
 *	Representative for a server. These objects are used by the manager to save the data for all servers on the specific machine.	
*/

	CLASS	ServerRep			:	CLASS	ksbase/ComTask //ov/domain
		IS_INSTANTIABLE;
		FLAGS	=	"v";
		COMMENT	=	"object to save connected server";
		VARIABLES
			/* server data *************************************************/
			name						:	STRING	HAS_ACCESSORS						FLAGS	=	"i"
				COMMENT			=	"name of server"
				INITIALVALUE	=	"";	
			version						:	UINT	HAS_ACCESSORS						FLAGS	=	"i"
				COMMENT			=	"Version of the ks protocol"
				INITIALVALUE	=	2;
			protocols []				:	STRING	HAS_ACCESSORS						FLAGS	=	"i"
				COMMENT			=	"list of protocols a server can handle. Double entries are allowed if they are on different ports.";	
			port []						:	STRING	HAS_ACCESSORS						FLAGS	=	"i"
				COMMENT			=	"list of addresses / ports corresponding to the protocols. List has to be of same length as protocols[]. Could be for example a tcp port or COM1";
			timetolive				:	UINT		HAS_ACCESSORS						FLAGS	=	"i"
				COMMENT			=	"time in which server has to do callback"
				INITIALVALUE	=	0;
			expirationtime			:	TIME		HAS_ACCESSORS						FLAGS	=	"i"
				COMMENT			=	"time at which server has to do callback";
			/* internals ***************************************************/
			regtime					:	TIME	HAS_ACCESSORS							FLAGS =	"i"
				COMMENT			=	"time the server registered at the manager";
			state						:	INT		HAS_ACCESSORS						FLAGS =	"i"
				COMMENT			=	"state of the server; 0: offline; 1: online; 2: inactive"
				INITIALVALUE	=	0;
		END_VARIABLES;
		OPERATIONS
			startup			:	C_FUNCTION <OV_FNC_STARTUP>;
			shutdown		:	C_FUNCTION <OV_FNC_SHUTDOWN>;
			typemethod 		: 	C_FUNCTION <KSBASE_FNC_TYPEMETHOD>;
		END_OPERATIONS;
	END_CLASS;
	
/**
 * Manager Class. Contains operations to handle servers.
 */

	CLASS	Manager				:	CLASS ov/domain
		IS_INSTANTIABLE;
		FLAGS	=	"v";
		COMMENT	=	"Manager. Provides operations for handling servers (register, unregister, getserverdata).";
		OPERATIONS
			register		:	C_FUNCTION <KSBASE_FNC_REGISTER>;
			unregister		:	C_FUNCTION <KSBASE_FNC_UNREGISTER>;
			getserverdata	:	C_FUNCTION <KSBASE_FNC_GETSERVERDATA>;
			getaccess	: C_FUNCTION <OV_FNC_GETACCESS>;		//just to make all variables visible on KS	
		END_OPERATIONS;
	END_CLASS;	


/**
 *	Baseclass for protocol-identificators. Each library supporting a specific protocol needs to derive one identificator from this in oder to determine the protocol used with a channel.
 */
 
	CLASS	ProtocolIdentificator				:	CLASS ov/domain
		COMMENT	=	"Baseclass for Protocol-Identificators. Provides an identify operation. This operation scans a chunk of bytes if the data contained matches a specific protocol.";
		OPERATIONS
			/**
			*	Function to identify the protocol. Gets a pointer to the Channel which received the data. Has to check in inData structure to determine if the protocol fits.
			*/
			identify		:	C_FUNCTION <KSBASE_FNC_IDENTIFY>;
			/**
			*	functions to create the ClientHandler corresponding to the protocol. This is calles after a successfull identification. The function has to create the ClientHandler
			*	and Link it to the Channel calling it with AssocChannelClientHandler.
			*/
			createClientHandler	:	C_FUNCTION	<KSBASE_FNC_CREATECH>;
			getaccess	: C_FUNCTION <OV_FNC_GETACCESS>;		//just to make all variables visible on KS		
		END_OPERATIONS;
	END_CLASS;	

/**
 *Baseclass for channels.
 */
 
 
	 CLASS	Channel					:	CLASS	ksbase/ComTask
		COMMENT	=	"Abstract Interface class, which should be realized by transport libraries";
		VARIABLES
			ConnectionState	:	UINT
				COMMENT	=	"State of the Connection: 0 - closed; 1 - opening; 2 - open; 4 - closing; 8 - sending; 16 - receiving; 32 - awaiting response; 128 - indicates error; 255 generic error"
				INITIALVALUE	=	0;
			address	:	STRING	
				COMMENT	=	"Address to communicate with"
				INITIALVALUE	=	"";
			outData	:	C_TYPE	<KS_DATAPACKET>	
				COMMENT	=	"data to be sent";
			inData	:	C_TYPE	<KS_DATAPACKET>	
				COMMENT	=	"data received";
			END_VARIABLES;	
		OPERATIONS
			//real sending of data
			SendData	:	C_FUNCTION	<KSBASE_FNC_SENDDATA>;
			//initialize inData and outData
			startup	:	C_FUNCTION	<OV_FNC_STARTUP>;
			//free heap memory of inData and outData
			shutdown	:	C_FUNCTION	<OV_FNC_SHUTDOWN>;
		END_OPERATIONS;
	END_CLASS;
	
/**
 *	Baseclass for ticketauthenticators
 *	TicketAuthenticators have to be singletons!!!
 *	The constructor of the baseclass tests if there is already an object of the same type. If so, it returns OV_ERR_ALLREADYEXISTS. For each Protocol and each tickettype only one
 *		authenticator may exist. There has to be a static global pointer to the object to make the ticket-functions find neccessary data.
 */
 
 	CLASS	TicketAuthenticator		:	CLASS	ov/domain
 		COMMENT	=	"Abstract baseclass for ticketauthenticators. For each ks-protocol different authenticators have to be implemented. An authenticator for tickets of simple type is mandatory (ks-specification). TicketAuthenticators have to be singletons!!";
 		VARIABLES
 			TicketType	:	C_TYPE	<OV_TICKET_TYPE>
 				COMMENT	=	"TicketType this authenticator can handle";
 			ticket	:	C_TYPE <OV_TICKET>
 				COMMENT	=	"Ticket this object works with.";
 			access	:	C_TYPE <OV_ACCESS>
 				COMMENT	=	"Acces rights of the last tested ticket";
 		END_VARIABLES;
 		OPERATIONS
 			constructor		:	C_FUNCTION	<OV_FNC_CONSTRUCTOR>;
 			startup			:	C_FUNCTION	<OV_FNC_STARTUP>;
 			shutdown		:	C_FUNCTION	<OV_FNC_SHUTDOWN>;
 			/*
 			*	These functions conform to the prototypes in a OV_TICKET_VTBL they are linked to the ticket itself to conform to ov-standards.
 			*	The functions do NOT get a this-pointer. Hence TicketAuthenticators have to be Singletons!!! 
 			*/
 			createticket	:	C_FUNCTION	<KSBASE_FNC_CREATETICKET>;
 			deleteticket	:	C_FUNCTION	<KSBASE_FNC_DELETETICKET>;
			encodereply		:	C_FUNCTION	<KSBASE_FNC_ENCODEREPLY>;
			TicketGetaccess		:	C_FUNCTION	<KSBASE_FNC_GETACCESS>;
 		END_OPERATIONS;
 	END_CLASS; 	
 
///////////////Assocs

/* 
 * This is the Association, which connects the RootComTask to the real ComTasks
 */
	ASSOCIATION AssocComTaskList : ONE_TO_MANY
		PARENT RootComTask : CLASS ksbase/RootComTask;
		CHILD  comtaskchild  : CLASS ksbase/ComTask;
	END_ASSOCIATION;
	
/* 
 * This is the Association, which connects the a ClientHandler to a Channel
 */
	ASSOCIATION AssocChannelClientHandler : ONE_TO_ONE
		PARENT Channel : CLASS ksbase/Channel;
		CHILD  ClientHandler  : CLASS ksbase/ClientHandler;
	END_ASSOCIATION;
	
/* 
 * This is the Association, which connects a DataHandler to a Channel (used for callbacks)
 */
	ASSOCIATION AssocChannelDataHandler : ONE_TO_ONE
		PARENT Channel : CLASS ksbase/Channel;
		CHILD  DataHandler  : CLASS ksbase/DataHandler;
	END_ASSOCIATION;
	
/* 
 * This Associations points to the Channel taht is currently running its typemethod
 */
	ASSOCIATION AssocCurrentChannel : ONE_TO_ONE
		PARENT ChannelParent : CLASS ksbase/RootComTask;
		CHILD  CurrentChannel  : CLASS ksbase/Channel;
	END_ASSOCIATION;
	
	
END_LIBRARY;
