
/******************************************************************************
 *
 *   FILE
 *   ----
 *   TCPChannel.c
 *
 *   History
 *   -------
 *   2013-01-17   File created
 *
 *******************************************************************************
 *
 *   This file is generated by the 'acplt_builder' command
 *
 ******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_TCPbind
#define OV_COMPILE_LIBRARY_TCPbind
#endif


#include "TCPbind.h"
#include "libov/ov_macros.h"
#include "libov/ov_malloc.h"
#include "TCPbind_helper.h"
#include "ks_logfile.h"
#include "TCPbind_config.h"


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>

#if !OV_SYSTEM_NT
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <netinet/in.h>
#include <unistd.h>
#include <fcntl.h>
/* for select */
#include <sys/select.h>
#else
#include <winsock2.h>
#endif


OV_DLLFNCEXPORT OV_INT TCPbind_TCPChannel_socket_get(
		OV_INSTPTR_TCPbind_TCPChannel          pobj
) {
	return pobj->v_socket;
}

OV_DLLFNCEXPORT OV_RESULT TCPbind_TCPChannel_socket_set(
		OV_INSTPTR_TCPbind_TCPChannel          pobj,
		const OV_INT  value
) {
	OV_INT socket;

	socket = TCPbind_TCPChannel_socket_get(pobj);
	if(socket >= 0 && socket != value)
	{
		CLOSE_SOCKET(socket);
		ks_logfile_debug("TCPChannel/socket %s closing socket %d", pobj->v_identifier, socket);
	}
	pobj->v_socket = value;

	//activate typemethod if a socket is there
	if(value >= 0)
		pobj->v_actimode = 1;

	return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT TCPbind_TCPChannel_SendData(
		OV_INSTPTR_ksbase_Channel this
) {
	/*
	 *   local variables
	 */

	return OV_ERR_OK;
}

OV_DLLFNCEXPORT void TCPbind_TCPChannel_startup(
		OV_INSTPTR_ov_object 	pobj
) {
	/*
	 *   local variables
	 */

	/* do what the base class does first */
	ksbase_Channel_startup(pobj);

	/* do what */
	//get called every 5th cycle before receiving first data (we have some time here)
	Ov_StaticPtrCast(TCPbind_TCPChannel, pobj)->v_cycInterval = 5;

	//set time of creation of the connection
	ov_time_gettime(&(Ov_StaticPtrCast(TCPbind_TCPChannel, pobj)->v_LastReceiveTime));

	return;
}

OV_DLLFNCEXPORT void TCPbind_TCPChannel_shutdown(
		OV_INSTPTR_ov_object 	pobj
) {
	/*
	 *   local variables
	 */
	OV_INSTPTR_TCPbind_TCPChannel this = Ov_StaticPtrCast(TCPbind_TCPChannel, pobj);
	int socket;
	/* do what */

	ks_logfile_debug("tcpclient/shutdown: %s", pobj->v_identifier);
	socket = TCPbind_TCPChannel_socket_get(this);
	if(socket >= 0)
	{
		CLOSE_SOCKET(socket);
		ks_logfile_debug("TCPChannel/shutdown %s closing socket %d", pobj->v_identifier, socket);
		TCPbind_TCPChannel_socket_set(this, -1);
		this->v_ConnectionState = TCPbind_CONNSTATE_CLOSED;
	}

	ksbase_Channel_shutdown(pobj);
	return;

}

OV_DLLFNCEXPORT void TCPbind_TCPChannel_typemethod (
		OV_INSTPTR_ksbase_ComTask	this
) {
	/*
	 *   local variables
	 */
	OV_INSTPTR_TCPbind_TCPChannel thisCh = Ov_StaticPtrCast(TCPbind_TCPChannel, this);
	OV_INT socket = -1;
	fd_set read_flags;
	struct timeval waitd;
	int off = 0;
	int err = 0;
	OV_TIME now;
	OV_TIME_SPAN tstemp;
	OV_TIME ttemp;

	//Associate ClientHandler if needed
	if(thisCh->v_ClientHandlerAssociated == TCPbind_CH_NOTASSOCATIED)
	{
		//TODO identify protocol and create chlienthandlers
	}

	//check timeouts
	ov_time_gettime(&now);
		//TODO check timeouts

	socket = TCPbind_TCPChannel_socket_get(thisCh);

	ks_logfile_debug("TCPChannel typemethod called ");

	if (socket < 0 || thisCh->v_ConnectionState == TCPbind_CONNSTATE_CLOSED) { // check if the socket might be OK.
		ks_logfile_debug("%s/typemethod: no socket set, disabling typemethod",this->v_identifier);
		this->v_actimode = 0;
		thisCh->v_ConnectionState = TCPbind_CONNSTATE_CLOSED;
		return;
	}

	//blocking
	if ((IOCTL_SOCKET(socket, FIONBIO, (char*) &off)) == -1) {
		ks_logfile_error("%s: ioctl(tcpclient) failed (set to blocking)", this->v_identifier);
		return;
	}

	//receive data in chunks (we dont know how much it will be)
	do
	{
		FD_ZERO(&read_flags);
		FD_SET(socket, &read_flags); // get read flags
		waitd.tv_sec = 0;     // Set Timeout
		waitd.tv_usec = 0;    //  do not wait
		err = select(socket + 1, &read_flags, (fd_set*) 0, (fd_set*)0, &waitd);

		ks_logfile_debug("select returned: %d; line %d", err, __LINE__);

		//check if data arrived
		if((err > 0) && FD_ISSET(socket, &read_flags))
		{
			//Data arrived
			//reallocate memory for receiving data
			err = ov_realloc(thisCh->v_inData.data, thisCh->v_inData.length + TCPbind_CHUNKSIZE);
			if(!err)
			{
				ks_logfile_error("%s: failed to allocate memory for received data (length: %u)", this->v_identifier, thisCh->v_inData.length+TCPbind_CHUNKSIZE);
				ov_free(thisCh->v_inData.data);
				thisCh->v_inData.length = 0;
				thisCh->v_inData.data = NULL;
				thisCh->v_inData.readPT = NULL;
				thisCh->v_inData.writePT = NULL;
				return;
			}

			err = recv(socket, thisCh->v_inData.writePT, TCPbind_CHUNKSIZE, 0);		//receive data
			if(err < TCPbind_CHUNKSIZE)
			{
				if(err == 0)
				{
					ks_logfile_debug("%s: nothing received. connection was gracefully closed", this->v_identifier);
					thisCh->v_ConnectionState = TCPbind_CONNSTATE_CLOSED;
					break;
				}
				else if (err == -1)
				{
					ks_logfile_error("%s: error receiving. Deleting data and closing socket.", this->v_identifier);
					ov_free(thisCh->v_inData.data);
					thisCh->v_inData.length = 0;
					thisCh->v_inData.data = NULL;
					thisCh->v_inData.readPT = NULL;
					thisCh->v_inData.writePT = NULL;
					CLOSE_SOCKET(socket);
					TCPbind_TCPChannel_socket_set(this, -1);
					thisCh->v_ConnectionState = TCPbind_CONNSTATE_CLOSED;
					return;
				}

			}

			//update data length
			thisCh->v_inData.length += err;
			//move writept to end of data
			thisCh->v_inData.writePT += err;

		}
	}while(FD_ISSET(socket, &read_flags));

	//update receivetime
	ov_time_gettime(&(thisCh->v_LastReceiveTime));

	//data received...process it
		//TODO process data if necessarry

	return;
}

OV_DLLFNCEXPORT OV_RESULT TCPbind_TCPChannel_OpenConnection(
		OV_INSTPTR_TCPbind_TCPChannel this,
		OV_STRING host,
		OV_INT port,
		OV_INT* socket
) {

	return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT TCPbind_TCPChannel_AssociateClientHandler(
		OV_INSTPTR_TCPbind_TCPChannel this
) {
	return OV_ERR_OK;
}

