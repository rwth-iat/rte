
/******************************************************************************
*
*   FILE
*   ----
*   tcpconnection.c
*
*   History
*   -------
*   2012-02-12   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_httpserv
#define OV_COMPILE_LIBRARY_httpserv
#endif

#include "httpserv.h"
#include "config.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <errno.h>
#include <sys/stat.h>

#if !OV_SYSTEM_NT 
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <netinet/in.h>
#include <unistd.h>
#include <fcntl.h>
#endif

#include "libov/ov_macros.h"
#include "libov/ov_path.h"
#include "libov/ov_logfile.h"


/**
 * Returns the port on which the object is listening.
 */
OV_DLLFNCEXPORT OV_INT httpserv_httpserver_port_get(
		OV_INSTPTR_httpserv_httpserver pobj) {
	return pobj->v_port;
}

/**
 * Sets the port on which the object is listening.
 */
OV_DLLFNCEXPORT OV_RESULT httpserv_httpserver_port_set(
		OV_INSTPTR_httpserv_httpserver pobj, const OV_INT value) {
	CLOSE_SOCKET(pobj->v_listensocket);
	httpserv_httpserver_listensocket_set(pobj, -1);

	pobj->v_port = value;
	return OV_ERR_OK;
}

/**
 * Returns the socket on which the object is listening.
 */
OV_DLLFNCEXPORT OV_INT httpserv_httpserver_listensocket_get(
		OV_INSTPTR_httpserv_httpserver pobj) {
	return pobj->v_listensocket;
}

/**
 * Sets the socket on which the object is listening.
 */
OV_DLLFNCEXPORT OV_RESULT httpserv_httpserver_listensocket_set(
		OV_INSTPTR_httpserv_httpserver pobj, const OV_INT value) {
	pobj->v_listensocket = value;
	return OV_ERR_OK;
}

/**
 * Procedure called on object startup.
 * It creates a managercom-object which takes over the
 * communication with the ks_manager. 
 * It starts the listening on with variable OWNPORT
 * declared port or by default on port 7509.
 */
OV_DLLFNCEXPORT void httpserv_httpserver_startup(OV_INSTPTR_ov_object pobj) {
	OV_INSTPTR_httpserv_httpserver this =
			Ov_StaticPtrCast(httpserv_httpserver, pobj);
	OV_INSTPTR_ov_domain thisdomain = Ov_StaticPtrCast(ov_domain, pobj);
	OV_INSTPTR_ov_domain pclients;
	OV_INSTPTR_ov_domain pstaticfiles;
	OV_INSTPTR_httpserv_httpclient ptcpc;

	pclients = (OV_INSTPTR_ov_domain) Ov_SearchChild(ov_containment, thisdomain, "clients");
	pstaticfiles = (OV_INSTPTR_ov_domain) Ov_SearchChild(ov_containment, thisdomain, "staticfiles");
	ptcpc =  NULL;

	//KSDEVEL ov_logfile_info("STARTUP TCPCONNECTION");


	//store port to object, 8080 is the default port
	httpserv_httpserver_port_set(this, 8080);

	//create clients domain
	if (pclients) {
		ptcpc = (OV_INSTPTR_httpserv_httpclient) Ov_GetFirstChild(ov_containment, pclients);
		while (ptcpc) {
			httpserv_httpclient_shutdown((OV_INSTPTR_ov_object) ptcpc);
			ptcpc = (OV_INSTPTR_httpserv_httpclient) Ov_GetNextChild(ov_containment, pclients);
		}
		Ov_DeleteObject((OV_INSTPTR_ov_object)pclients);
		if (!Ov_OK((Ov_CreateObject(ov_domain, pclients, thisdomain, "clients")))) {
			ov_logfile_error("Fatal: Couldnt create Object clients");
			return;
		}
	} else {
		if (!Ov_OK((Ov_CreateObject(ov_domain, pclients, thisdomain, "clients")))) {
			ov_logfile_error("Fatal: Couldnt create Object clients");
			return;
		}
	}

	//create staticfiles domain
	if (!pstaticfiles) {
		if (!Ov_OK((Ov_CreateObject(ov_domain, pclients, thisdomain, "staticfiles")))) {
			ov_logfile_error("Fatal: Couldnt create Object staticfiles");
			return;
		}
	}

	//register typemethod
	//ComTask Ov_WarnIfNot(Ov_OK(ov_scheduler_register(pobj, httpserv_httpserver_typemethod)));

	return;
}

/**
 * Procedure called on object shutdown. 
 * It closes open socket and deletes created
 * managercom- and manager-objects.
 */
OV_DLLFNCEXPORT void httpserv_httpserver_shutdown(OV_INSTPTR_ov_object pobj) {
	int listensocket;
	OV_INSTPTR_httpserv_httpserver this = Ov_StaticPtrCast(httpserv_httpserver, pobj);
	//close socket
	listensocket = httpserv_httpserver_listensocket_get(this);
	if (!(CLOSE_SOCKET(listensocket)))
		perror("shutdown listen");
	httpserv_httpserver_listensocket_set(this, -1);

	return;
}

/**
 * Procedure periodically called by Root ComTask //ov_scheduler.
 * It takes over the connection-management.
 * If there is an incomming connection-request on
 * listensocket it creates an tcpclient-object which
 * will take over the communication with requesting client.
 */
void httpserv_httpserver_typemethod(OV_INSTPTR_ksserv_ComTask cTask
//ComTask OV_INSTPTR_ov_object	pfb
) {
	OV_INSTPTR_httpserv_httpserver this =
			Ov_StaticPtrCast(httpserv_httpserver, cTask);
	OV_INSTPTR_ov_domain thisdomain = Ov_StaticPtrCast(ov_domain, cTask);
	OV_INSTPTR_httpserv_httpclient ptcpc = NULL;
	OV_INSTPTR_ov_domain
			pclients =
					(OV_INSTPTR_ov_domain) Ov_SearchChild(ov_containment, thisdomain, "clients");
	int listensocket = httpserv_httpserver_listensocket_get(this);
	int receivesocket;
	char clientname[256];
	int cnr = 0;
	int on = 1;
	//int optval = 1;
	char optval = 1; //used by setsockopt for reuseage of tcp connection port
	struct sockaddr_in client_addr;
	int port = httpserv_httpserver_port_get(this);

	//check if we have already an open socket - otherwise create socket
	if (listensocket == -1) {
		//open socket
		listensocket = socket(PF_INET, SOCK_STREAM, 0);
		httpserv_httpserver_listensocket_set(this, listensocket);
		if (listensocket == -1) {
			perror("socket(tcpconnection) failed");
			this->v_status = STATUS_TCPCON_SOCKOPENFAILED;
			return;
		}

		//non-blocking
		//if ((IOCTL_SOCKET(listensocket, FIONBIO, (char*) &on)) == -1) {
		if ((IOCTL_SOCKET(listensocket, FIONBIO, (u_long*) &on)) == -1) {
			perror("ioctl(tcpconnection) failed");
			CLOSE_SOCKET(listensocket);
			httpserv_httpserver_listensocket_set(this, -1);
			this->v_status = STATUS_TCPCON_SOCKNONBLOCKFAILED;
			return;
		}

		//bind
		memset(&client_addr, 0, sizeof(client_addr));
		client_addr.sin_family = AF_INET;
		client_addr.sin_addr.s_addr = htonl(INADDR_ANY);
		client_addr.sin_port = htons(port);

		//test reuseage!
		ov_logfile_info("########## reuseage of used port by setsockopt ");
		setsockopt(listensocket, SOL_SOCKET, SO_REUSEADDR, &optval,	sizeof(optval));

		if ((bind(listensocket, (struct sockaddr*) &client_addr,
				sizeof(client_addr))) == -1) {
			perror("bind(tcpconnection) failed");
			CLOSE_SOCKET(listensocket);
			httpserv_httpserver_listensocket_set(this, -1);
			this->v_status = STATUS_TCPCON_SOCKBINDFAILED;
			return;
		}
		//listen
		if ((listen(listensocket, 3)) == -1) {
			perror("listen(tcpconnection) failed");
			CLOSE_SOCKET(listensocket);
			httpserv_httpserver_listensocket_set(this, -1);
			this->v_status = STATUS_TCPCON_SOCKLISTENFAILED;
			return;
		}


	} //end create socket

	listensocket = httpserv_httpserver_listensocket_get(this);

	//accept
	if ((receivesocket = accept(listensocket, NULL, NULL)) < 0) {
		//ov_logfile_info("No client waiting to connect (accept(tcpconnection) < 0)");
		this->v_status = STATUS_TCPCON_SOCKACCEPTFAILED;
		return;
	}

	//non-blocking
	//if ((IOCTL_SOCKET(receivesocket, FIONBIO, (char*) &on)) == -1) {
	if ((IOCTL_SOCKET(receivesocket, FIONBIO, (u_long*) &on)) == -1) {
		perror("ioctl(receivesocket) failed");
		CLOSE_SOCKET(receivesocket);
		this->v_status = STATUS_TCPCON_SOCKNONBLOCKCLIENTFAILED;
		return;
	}

	//KSDEVEL ov_logfile_info("clientname: %s", clientname);
	//KSDEVEL ov_logfile_info("socket: %d", receivesocket);

	//get first free "tcpclient"-name
	do {
		ptcpc = NULL;
		cnr++;
		sprintf(clientname, "tcpclient%i", cnr);
		ptcpc
				= (OV_INSTPTR_httpserv_httpclient) Ov_SearchChild(ov_containment, pclients, clientname);
	} while (ptcpc);

	//create receiving tcpclient
	if (Ov_OK(Ov_CreateObject(httpserv_httpclient, ptcpc, pclients, clientname))) {
		ov_logfile_info("New client connected, socket %d", receivesocket);
		//copy socket to created tcpclient-object
		httpserv_httpclient_receivesocket_set(ptcpc, receivesocket);
		this->v_status = STATUS_TCPCON_OK;
	} else {
		ov_logfile_error("Creating of TCPClient failed while New client connected, socket %d ", receivesocket);
	}
	return;
}

