
/******************************************************************************
*
*   FILE
*   ----
*   aresWorker.c
*
*   History
*   -------
*   2015-10-29   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_TCPbind
#define OV_COMPILE_LIBRARY_TCPbind
#endif


#include "TCPbind.h"
#include "libov/ov_macros.h"
#include "ks_logfile.h"

#if OV_SYSTEM_NT
#include <windows.h>
#elif OV_SYSTEM_UNIX

#endif

static struct getAddrInfoElemList elemList;

static OV_INSTPTR_TCPbind_aresWorker pAresWorker = NULL;

/*	host and port are copied ad deleted by the worker thread. addrInfo needs to be freed by the caller	*/

OV_DLLFNCEXPORT getAddrInfoElem *TCPbind_aresWorker_insertGetAddrInfo(
	OV_STRING host,
	OV_STRING port,
	struct addrinfo *hints,
	struct addrinfo **addrInfo
) {
	struct getAddrInfoElem *pNewElem, *pOldLast;

	if(!host || !port || !(*host) || !(*port) || !hints || !addrInfo){
		return 0;
	}
	pNewElem = calloc(1, sizeof(getAddrInfoElem));
	if(!pNewElem){
		return 0;
	}

	pNewElem->addrInfo = addrInfo;
	pNewElem->hints = *hints;
	pNewElem->host = calloc(ov_string_getlength(host)+1, sizeof(char));
	pNewElem->port = calloc(ov_string_getlength(port)+1, sizeof(char));
	if(!host || !port){
		return 0;
	}
	strcpy(pNewElem->host, host);
	strcpy(pNewElem->port, port);
	pNewElem->status = AIESTATUS_WAITING;
	/*	last element is never deleted, so the pointer is always valid	*/
	pNewElem->pPrevious = elemList.pLastElem;
	/*	insert Element -> this is the only atomic action	*/
#if OV_SYSTEM_NT
	pOldLast = InterlockedExchangePointer(&(elemList.pLastElem->pNext), pNewElem);
#elif OV_SYSTEM_UNIX

#endif
	/*	this one does not need to be atomic, as no other thread touches this value	*/
	elemList.pLastElem = pNewElem;
    return pNewElem;
}

/********************************************************************************************************************************************/

OV_DLLFNCEXPORT void TCPbind_aresWorker_delGetAddrInfoElem(
	getAddrInfoElem *elem
) {
#if OV_SYSTEM_NT
	LONG statusOld;
	statusOld =  InterlockedExchange(&(elem->delete), AIEDELETE_DO);
#elif OV_SYSTEM_UNIX

#endif
    return;
}

/********************************************************************************************************************************************/

OV_DLLFNCEXPORT OV_RESULT TCPbind_aresWorker_constructor(
	OV_INSTPTR_ov_object 	pobj
) {
    /*
    *   local variables
    */
    OV_INSTPTR_TCPbind_aresWorker pinst = Ov_StaticPtrCast(TCPbind_aresWorker, pobj);
    OV_RESULT    result;

    /* do what the base class does first */
    result = ksbase_ComTask_constructor(pobj);
    if(Ov_Fail(result))
         return result;

    /* do what */
    if(pAresWorker != NULL){
    	KS_logfile_error(("%s: aresWorker needs to be a singleton. will not create.", pinst->v_identifier));
    	return OV_ERR_BADPLACEMENT;
    }
    pAresWorker = pinst;

    return OV_ERR_OK;
}

/********************************************************************************************************************************************/

#if OV_SYSTEM_NT
static volatile LONG runGetAddrInfoThread;
/*	NEVER EVER let this function return STILL_ACTIVE (259) as the parent process would not recognize the function has returned then	*/
DWORD WINAPI getAddrInfoThread( LPVOID lpParam ){
	int ret;
	LONG statusOld;
	struct getAddrInfoElem *pCurrElem;
	struct getAddrInfoElem *pNextElem;

	while(runGetAddrInfoThread){
		if(elemList.pFirstElem){
			pCurrElem = elemList.pFirstElem;
			while(pCurrElem){
				/*	get the next element	*/
				pNextElem = pCurrElem->pNext;
				/*	check if getAddrInfo is to be done, if so, do it	*/
				statusOld =  InterlockedCompareExchange( &(pCurrElem->status), AIESTATUS_WORKING, AIESTATUS_WAITING);
				if(statusOld == AIESTATUS_WAITING){
					//resolve address
					if ((ret = getaddrinfo(pCurrElem->host, pCurrElem->port, &(pCurrElem->hints), pCurrElem->addrInfo)) != 0)
					{
						KS_logfile_error(("aresWorkerThread: getaddrinfo failed"));
						return OV_ERR_GENERIC;
					}
					statusOld =  InterlockedExchange(&(pCurrElem->status), AIESTATUS_DONE);
				}
				/*	check if current element should be deleted	*/
				if(pCurrElem->delete == AIEDELETE_DO){
					/*	only delete if it is NOT the last element	*/
					if(pCurrElem->pNext){
						if(pCurrElem->pPrevious){
							pCurrElem->pPrevious->pNext = pCurrElem->pNext;
						}else{
							elemList.pFirstElem = pCurrElem->pNext;
						}
						pCurrElem->pNext->pPrevious = pCurrElem->pPrevious;
						free(pCurrElem->host);
						free(pCurrElem->port);
						free(pCurrElem);
					}
				}
				/*	go to the next element	*/
				pCurrElem = pNextElem;
			}
		}
		Sleep(10);
	}
	return 0;
}

#elif OV_SYSTEM_UNIX

#endif

/********************************************************************************************************************************************/

OV_DLLFNCEXPORT void TCPbind_aresWorker_startup(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
    OV_INSTPTR_TCPbind_aresWorker pinst = Ov_StaticPtrCast(TCPbind_aresWorker, pobj);
    struct getAddrInfoElem *pNewElem;
#if OV_SYSTEM_NT
	DWORD dwThreadId;
#elif OV_SYSTEM_UNIX

#endif
    /* do what the base class does first */
    ov_object_startup(pobj);

    /* do what */
    pinst->v_cycInterval = 50;	/*	just checks if the thread is running -> not needed so often	*/
    /*	create a dummy element	*/
    pNewElem = calloc(1, sizeof(getAddrInfoElem));
    if(!pNewElem){
    	KS_logfile_error(("%s: creation of dummy element failed", pinst->v_identifier));
    	return;
    }
    pNewElem->status = AIESTATUS_DONE;
    pNewElem->delete = AIEDELETE_DO;
    elemList.pFirstElem = pNewElem;
    elemList.pLastElem = pNewElem;
#if OV_SYSTEM_NT
    runGetAddrInfoThread = 1;
    pinst->v_threadHandle = CreateThread(NULL, 0, getAddrInfoThread, (void*) NULL, 0, &dwThreadId);
	if(pinst->v_threadHandle == 0){
		KS_logfile_error(("%s: creation of getaddrinfo thread failed", pinst->v_identifier));
		return;
	}
#elif OV_SYSTEM_UNIX

#endif
    return;
}

/********************************************************************************************************************************************/

OV_DLLFNCEXPORT void TCPbind_aresWorker_shutdown(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
    OV_INSTPTR_TCPbind_aresWorker pinst = Ov_StaticPtrCast(TCPbind_aresWorker, pobj);
    struct getAddrInfoElem *pCurrElem, *pNextElem;
    /* do what */
#if OV_SYSTEM_NT
    /*	yes, here it waits until the thread is through....	*/
    InterlockedExchange(&(runGetAddrInfoThread), 0);
    if(WaitForSingleObject(pinst->v_threadHandle, 5000) != WAIT_OBJECT_0){
    	KS_logfile_warning(("%s: getaddrinfo thread did not terminate correctly and in time. some memory might be lost."));
    }
#elif OV_SYSTEM_UNIX

#endif
    /*	delete the elements in the list	*/
    if(elemList.pFirstElem){
    	pCurrElem = elemList.pFirstElem;
    	while(pCurrElem){
    		/*	get the next element	*/
    		pNextElem = pCurrElem->pNext;
    		if(pCurrElem->pNext){
    			if(pCurrElem->pPrevious){
    				pCurrElem->pPrevious->pNext = pCurrElem->pNext;
    			}else{
    				elemList.pFirstElem = pCurrElem->pNext;
    			}
    			pCurrElem->pNext->pPrevious = pCurrElem->pPrevious;
    			free(pCurrElem->host);
    			free(pCurrElem->port);
    			free(pCurrElem);
    		}
    		/*	go to the next element	*/
    		pCurrElem = pNextElem;
    	}
    }
    elemList.pFirstElem = NULL;
    elemList.pLastElem = NULL;
    /* set the object's state to "shut down" */
    ov_object_shutdown(pobj);

    return;
}

/********************************************************************************************************************************************/

OV_DLLFNCEXPORT void TCPbind_aresWorker_typemethod (
	OV_INSTPTR_ksbase_ComTask	this
) {
    /*    
    *   local variables
    */
#if OV_SYSTEM_NT
	DWORD exitCode, dwThreadId;
#elif OV_SYSTEM_UNIX

#endif
	OV_INSTPTR_TCPbind_aresWorker pinst = Ov_StaticPtrCast(TCPbind_aresWorker, this);
	/*	TODO check if thread is running, if not restart it.	*/
#if OV_SYSTEM_NT
    if(!GetExitCodeThread(pinst->v_threadHandle, &exitCode)){
    	this->v_actimode = 0;
    	KS_logfile_error(("%s: could not determine status of getaddrinfo thread", pinst->v_identifier));
    	return;
    }
    if(exitCode != STILL_ACTIVE){
    	KS_logfile_warning(("%s: getaddrinfo thread exited -restarting it", pinst->v_identifier));
    	pinst->v_threadHandle = CreateThread(NULL, 0, getAddrInfoThread, (void*) NULL, 0, &dwThreadId);
    	if(pinst->v_threadHandle == 0){
    		KS_logfile_error(("%s: creation of getaddrinfo thread failed", pinst->v_identifier));
    		return;
    	}
    }
#elif OV_SYSTEM_UNIX

#endif
    return;
}

