
/******************************************************************************
 *
 *   FILE
 *   ----
 *   TCPListener.c
 *
 *   History
 *   -------
 *   2013-01-17   File created
 *
 *******************************************************************************
 *
 *   This file is generated by the 'acplt_builder' command
 *
 ******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_TCPbind
#define OV_COMPILE_LIBRARY_TCPbind
#endif


#include "TCPbind.h"
#include "libov/ov_macros.h"
#include "TCPbind_helper.h"
#include "ks_logfile.h"
#include "TCPbind_config.h"
#include "ksbase_helper.h"
#include "libov/ov_vendortree.h"


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>

#if !OV_SYSTEM_NT
#include <arpa/inet.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <unistd.h>
#include <fcntl.h>
#include <netdb.h>
/*	defines if not defined in netdb.h	*/
#ifndef NI_MAXHOST
#define NI_MAXHOST 1025
#endif
#ifndef NI_MAXSERV
#define NI_MAXSERV 32
#endif
/* for select */
#include <sys/select.h>
#else
#undef _WIN32_WINNT
#define _WIN32_WINNT 0x501
#ifndef IPV6_V6ONLY
#define IPV6_V6ONLY 27
#endif
#include <winsock2.h>
#include <ws2tcpip.h>
#endif

OV_DLLFNCEXPORT OV_INT TCPbind_TCPListener_port_get(
		OV_INSTPTR_TCPbind_TCPListener          pobj
) {
	return pobj->v_port;
}

OV_DLLFNCEXPORT OV_RESULT TCPbind_TCPListener_port_set(
		OV_INSTPTR_TCPbind_TCPListener          pobj,
		const OV_INT  value
) {
	if(pobj->v_socket[0] != -1)
	{
		TCPBIND_CLOSE_SOCKET(pobj->v_socket[0]);
		pobj->v_SocketState = 0;
		pobj->v_socket[0] = -1;
	}

	if(pobj->v_socket[1] != -1)
	{
		TCPBIND_CLOSE_SOCKET(pobj->v_socket[1]);
		pobj->v_SocketState = 0;
		pobj->v_socket[1] = -1;
	}

	pobj->v_port = value;
	return OV_ERR_OK;
}



OV_DLLFNCEXPORT OV_RESULT TCPbind_TCPListener_constructor(
		OV_INSTPTR_ov_object 	pobj
) {
	/*
	 *   local variables
	 */
	OV_INSTPTR_TCPbind_TCPListener pinst = Ov_StaticPtrCast(TCPbind_TCPListener, pobj);
	OV_RESULT result;
	/* do what the base class does first */
	result = ksbase_ComTask_constructor(pobj);
	if(Ov_Fail(result))
		return result;
	/* do what */

	//start inactive at construction. Begin listening in typemethod
	pinst->v_actimode = 0;

	return result;
}

OV_DLLFNCEXPORT void TCPbind_TCPListener_shutdown(
		OV_INSTPTR_ov_object 	pobj
) {
	/*
	 *   local variables
	 */
	OV_INSTPTR_TCPbind_TCPListener pinst = Ov_StaticPtrCast(TCPbind_TCPListener, pobj);
	OV_INSTPTR_TCPbind_TCPChannel pChannel = NULL;
	OV_INSTPTR_TCPbind_TCPChannel pNextChannel = NULL;

	/* do what */
	//close socket
	if(pinst->v_socket[0] != -1)
	{
		TCPBIND_CLOSE_SOCKET(pinst->v_socket[0]);
		pinst->v_socket[0] = -1;
	}

	if(pinst->v_socket[1] != -1)
	{
		TCPBIND_CLOSE_SOCKET(pinst->v_socket[1]);
		pinst->v_socket[1] = -1;
	}
	pinst->v_SocketState = 0;
	pinst->v_actimode = 0;

	/*
	 * iterate over all TCPChannels in containment and delete them if they act as Servers (probably all of them)
	 * we cannot use Ov_ForEachChildEx here since we would delete an object before getting the next child
	 */
	pNextChannel = Ov_StaticPtrCast(TCPbind_TCPChannel, Ov_GetFirstChild(ov_containment, Ov_StaticPtrCast(ov_domain, pinst)));
	while(pNextChannel)
	{
		if(Ov_CanCastTo(TCPbind_TCPChannel, pNextChannel))
		{
			pChannel = pNextChannel;
			pNextChannel = Ov_StaticPtrCast(TCPbind_TCPChannel, Ov_GetNextChild(ov_containment, Ov_StaticPtrCast(ov_object, pChannel)));
			if(pChannel->v_ClientHandlerAssociated != KSBASE_CH_NOTNEEDED)
				Ov_DeleteObject(pChannel);
		}
		else
			pNextChannel = Ov_StaticPtrCast(TCPbind_TCPChannel, Ov_GetNextChild(ov_containment, Ov_StaticPtrCast(ov_object, pNextChannel)));

	}


	/* set the object's state to "shut down" */
	ov_object_shutdown(pobj);

	return;
}

typedef enum TCPBIND_PROT {PROTUNDEFINED=0,IPv4=4,IPv6=6} TCPBIND_PROT;

OV_DLLFNCEXPORT void TCPbind_TCPListener_typemethod (
		OV_INSTPTR_ksbase_ComTask	this
) {
	/*
	 *   local variables
	 */
	OV_INSTPTR_TCPbind_TCPListener thisLi = Ov_StaticPtrCast(TCPbind_TCPListener, this);
	OV_INSTPTR_TCPbind_TCPChannel pNewChannel = NULL;
	OV_INSTPTR_ksbase_ProtocolIdentificator pProtIdent = NULL;
	OV_VTBLPTR_ksbase_ProtocolIdentificator pVTBLProtIdent = NULL;
	OV_BOOL protV4only = FALSE;
	struct addrinfo *resultingaddrinfo;
	struct addrinfo hints;
	int ret;
	#define NUMPROT 2
	TCPBIND_PROT Protocolfamily[NUMPROT] = {PROTUNDEFINED, PROTUNDEFINED};
	TCPBIND_SOCKET sockfds[NUMPROT]={TCPBIND_INVALID_SOCKET, TCPBIND_INVALID_SOCKET};
	TCPBIND_SOCKET fd = 0;
	TCPBIND_SOCKET cfd = 0;
	int opt_on = 1;
#if OV_SYSTEM_NT
	DWORD NumberOfBytesReturned = 0;	//used for SIO_LOOPBACK_FAST_PATH
#endif
	struct sockaddr_storage sa_stor;
	socklen_t sockaddsize;
	struct sockaddr* sockaddress = (struct sockaddr*) &sa_stor;
	char hostbuf[NI_MAXHOST];
	char portbuf[NI_MAXSERV];
	int flags = NI_NUMERICHOST | NI_NUMERICSERV;
	fd_set fds;
	TCPBIND_SOCKET highest;
	int i;
	struct timeval waitd;
	struct sockaddr_storage peer;
	socklen_t peers = sizeof(struct sockaddr_storage);
	char buf[NI_MAXHOST];

	/*
	 * If no socket is open, open one and start listening.
	 * This code was copied from ct magazine 19/12. It is meant to make the sockets IPv6 compatible.
	 */
	if(!thisLi->v_SocketState)	//no socket open
	{
		ov_memstack_lock();
		if(!ov_vendortree_getcmdlineoption_value("TCPBIND_NO_IPv6")){
			protV4only = FALSE;
		}else{
			protV4only = TRUE;
		}
		ov_memstack_unlock();
		if(protV4only){
			Protocolfamily[0] = IPv4;
		} else {
			Protocolfamily[0] = IPv4;
			Protocolfamily[1] = IPv6;
		}
		portbuf[0] = '\0';

		for (i = 0; i < NUMPROT; i++){
			memset(&hints, 0, sizeof(struct addrinfo));
			hints.ai_socktype = SOCK_STREAM;
			hints.ai_flags = AI_PASSIVE;
			if(Protocolfamily[i] == IPv4){
				hints.ai_family = AF_INET;
			}else if(Protocolfamily[i] == IPv6){
				hints.ai_family = PF_INET6;
			}else{
				hints.ai_family = PF_UNSPEC;
			}

			if(TCPbind_TCPListener_port_get(thisLi) != -1){
				snprintf(portbuf, NI_MAXSERV, "%" OV_PRINT_INT, TCPbind_TCPListener_port_get(thisLi));
			} else if(portbuf[0] == '\0') {
				snprintf(portbuf, NI_MAXSERV, "%" OV_PRINT_INT, 0);
			} else {
				//reuse port from the last protocol
			}
			ret = getaddrinfo(NULL, portbuf, &hints, &resultingaddrinfo);
			if(ret != 0) {
				KS_logfile_error(("%s: getaddrinfo failed: %d", this->v_identifier, ret));
				thisLi->v_SocketState = TCPbind_CONNSTATE_COULDNOTOPEN;
				return;
			}

			//create an endpoint for communication
			//setting protocol type
			fd = socket(resultingaddrinfo->ai_family, resultingaddrinfo->ai_socktype, resultingaddrinfo->ai_protocol);
			if(fd == TCPBIND_INVALID_SOCKET){
#if OV_SYSTEM_NT
				errno = WSAGetLastError();
#endif
				//error. Try next protocol
				freeaddrinfo(resultingaddrinfo);
				resultingaddrinfo = NULL;
				continue;
			}

			if(resultingaddrinfo->ai_family == AF_INET) {
				KS_logfile_debug(("%s: found IPv4 socket: %d", thisLi->v_identifier, fd));
			} else if (resultingaddrinfo->ai_family == AF_INET6) {
				KS_logfile_debug(("%s: found IPv6 socket: %d", thisLi->v_identifier, fd));
				//restricting this port to V6 only, not IPv4 mapped address like ::ffff:10.1.1.1
				if (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char*)&opt_on, sizeof(opt_on)) == -1) {
					//error. Try next protocol
					freeaddrinfo(resultingaddrinfo);
					resultingaddrinfo = NULL;
					continue;
				}
			} else {
				//Blacklisting other than IPv4 and IPv6, should not get hit
				KS_logfile_debug(("%s: found non INET-socket: %d. closing socket", thisLi->v_identifier, fd));
				TCPBIND_CLOSE_SOCKET(fd);
				freeaddrinfo(resultingaddrinfo);
				resultingaddrinfo = NULL;
				continue;
			}

			if(setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char*)&opt_on, sizeof(opt_on))) {
				KS_logfile_warning(("%s: could not set option SO_REUSEADDR for socket: %d", thisLi->v_identifier, fd));
				KS_logfile_print_sysMsg();
			}

			//setting source address and port
			if (bind(fd, resultingaddrinfo->ai_addr, resultingaddrinfo->ai_addrlen) == TCPBIND_SOCKET_ERROR) {
				freeaddrinfo(resultingaddrinfo);
				resultingaddrinfo = NULL;
				continue;
			}
#if OV_SYSTEM_NT
			//opt in for faster localhost connections on new windows hosts. This has to be before listen
//old includes does not have this new define
#ifndef SIO_LOOPBACK_FAST_PATH
#define SIO_LOOPBACK_FAST_PATH 0x98000010
#endif
			//we are not really interested in errors. Most would be WSAEOPNOTSUPP for pre Windows Server 2012 or Windows 8
			(void)WSAIoctl(cfd, SIO_LOOPBACK_FAST_PATH, &opt_on, sizeof(opt_on), NULL, 0, &NumberOfBytesReturned, 0, 0);
#endif

			//mark the socket as a passive socket, to be able to accept incoming connections to it
			//second parameter is the maximum length to which the queue of pending connections for fd may grow
			if (listen(fd, 5) == TCPBIND_SOCKET_ERROR) {
				freeaddrinfo(resultingaddrinfo);
				resultingaddrinfo = NULL;
				continue;
			}

			//sockaddsize should indicate the amount of space of addr (in bytes) but could be actual size of the last socket address.
			sockaddsize = sizeof(sa_stor);
			//get the current address to which we are bound
			if(getsockname(fd, sockaddress, &sockaddsize) == TCPBIND_SOCKET_ERROR) {
				KS_logfile_error(("%s: getsockname failed", this->v_identifier));
				KS_logfile_print_sysMsg();
				thisLi->v_SocketState = TCPbind_CONNSTATE_COULDNOTOPEN;
				freeaddrinfo(resultingaddrinfo);
				resultingaddrinfo = NULL;
				return;
			}

			//convert the socket address to a corresponding host and service
			if(getnameinfo(sockaddress, sockaddsize, hostbuf, sizeof(hostbuf), portbuf, sizeof(portbuf), flags) != 0) {
				KS_logfile_error(("%s: getnameinfo failed", this->v_identifier));
				KS_logfile_print_sysMsg();
				thisLi->v_SocketState = TCPbind_CONNSTATE_COULDNOTOPEN;
				freeaddrinfo(resultingaddrinfo);
				resultingaddrinfo = NULL;
				return;
			}

			KS_logfile_debug(("%s: listening on %s on port %s (socket: %d)",this->v_identifier, hostbuf, portbuf, fd));

			if(Protocolfamily[i] == IPv4){
				sockfds[0] = fd;
			}else if(Protocolfamily[i] == IPv6){
				sockfds[1] = fd;
			}

			freeaddrinfo(resultingaddrinfo);
			resultingaddrinfo = NULL;
		//End of loop --> sockets are open
		}

		if(sockfds[0] == TCPBIND_INVALID_SOCKET && sockfds[1] == TCPBIND_INVALID_SOCKET){
			KS_logfile_error(("%s: failed to open socket: %d", thisLi->v_identifier, errno));
			ks_logfile_print_sysMsg();
			thisLi->v_SocketState = TCPbind_CONNSTATE_COULDNOTOPEN;
			return;
		}
		if(TCPbind_TCPListener_port_get(thisLi) == -1) {
			TCPbind_TCPListener_port_set(thisLi, atoi(portbuf));
		}
		//remembering IPv4 socket
		OV_TCPBIND_SETSOCKET2INT(sockfds[0], thisLi->v_socket[0]);

		//remembering IPv6 socket
		OV_TCPBIND_SETSOCKET2INT(sockfds[1], thisLi->v_socket[1]);

		//the OV variable can hold only a valid socket or -1 (no INVALID_SOCKET even on windows)
		if(thisLi->v_socket[0] != -1 || thisLi->v_socket[1] != -1) {
			thisLi->v_SocketState = KSBASE_CONNSTATE_OPEN;
		} else {
			thisLi->v_SocketState = KSBASE_CONNSTATE_COULDNOTOPEN;
		}
	}
	/**
	 * Socket is open now
	 */
	if(thisLi->v_SocketState == TCPbind_CONNSTATE_OPEN) {
		OV_TCPBIND_SETINT2SOCKET(thisLi->v_socket[0], sockfds[0]);
		OV_TCPBIND_SETINT2SOCKET(thisLi->v_socket[1], sockfds[1]);
		highest = 0;
		FD_ZERO(&fds);
		for (i = 0; i < NUMPROT; i++) {
			if(sockfds[i] != TCPBIND_INVALID_SOCKET){
				FD_SET(sockfds[i], &fds);
				highest = (sockfds[i] > highest ? sockfds[i] : highest);
			}
		}

		waitd.tv_sec = 0;     // Set Timeout
		waitd.tv_usec = 0;    //  do not wait
		ret = select(highest+1, &fds, NULL, NULL, &waitd);
		if(ret == TCPBIND_SOCKET_ERROR) {
			KS_logfile_debug(("%s: select returned: %d; line %d",this->v_identifier, ret, __LINE__));
#if OV_SYSTEM_NT
			errno = WSAGetLastError();
#endif
			KS_logfile_error(("%s: select returned error %d", this->v_identifier, errno));
			KS_logfile_print_sysMsg();
		}

		if(ret>0)	//data arrived on the socket(s)
		{
			for (i = 0; (i < 2); i++) {
				if ((sockfds[i] == TCPBIND_INVALID_SOCKET) || (!FD_ISSET(sockfds[i], &fds))){
					continue;
				}

				cfd = accept(sockfds[i], (struct sockaddr*)&peer, &peers);
				if(cfd != TCPBIND_INVALID_SOCKET){
					if (getnameinfo((struct sockaddr*)&peer, peers, buf, sizeof(buf), NULL, 0, NI_NUMERICHOST))
					{
						KS_logfile_error(("%s: getnameinfo for newly connected client failed", this->v_identifier));
						KS_logfile_print_sysMsg();
					}

					KS_logfile_debug(("%s: new client connected: %s", this->v_identifier, buf));

					//disable nagle for the receivesocket
					(void)setsockopt(cfd, IPPROTO_TCP, TCP_NODELAY, (char*) &opt_on, sizeof(opt_on));

					//create receiving TCPChannel
					if (Ov_OK(Ov_CreateIDedObject(TCPbind_TCPChannel, pNewChannel, Ov_StaticPtrCast(ov_domain, this), "TCPChannel"))){
						KS_logfile_debug(("%s: New Channel created: %s to handle client %s", this->v_identifier, pNewChannel->v_identifier, buf));
						//copy socket to created object
						TCPbind_TCPChannel_socket_set(pNewChannel, cfd);
						if(Ov_Fail(ov_string_setvalue(&(pNewChannel->v_address), buf)))
						{
							KS_logfile_error(("%s: failed to set address for TCHChannel %s", this->v_identifier, pNewChannel->v_identifier));
						}
						pNewChannel->v_ConnectionState = TCPbind_CONNSTATE_OPEN;
						/*	check for local connection and set flag appropriately	*/
						if((ov_string_compare(buf, "127.0.0.1") == OV_STRCMP_EQUAL)
								|| (ov_string_compare(buf, "::1") == OV_STRCMP_EQUAL))
							pNewChannel->v_isLocal = TRUE;

						if(thisLi->v_ChannelNeedsClientHandler)
						{
							pNewChannel->v_ClientHandlerAssociated = KSBASE_CH_NOTASSOCATIED;
							pProtIdent = Ov_GetChild(TCPbind_AssocSpecificClientHandler, thisLi);
							if(pProtIdent)
							{
								Ov_GetVTablePtr(ksbase_ProtocolIdentificator, pVTBLProtIdent, pProtIdent);
								if(!pVTBLProtIdent)
								{
									KS_logfile_error(("%s: error getting VTablePtr for %s", this->v_identifier, pProtIdent->v_identifier));
								}
								else
								{
									if(Ov_Fail(pVTBLProtIdent->m_createClientHandler(pProtIdent, Ov_StaticPtrCast(ksbase_Channel, pNewChannel))))
									{
										KS_logfile_error(("%s: error creating ClientHandler for %s. (ProtocolIdentificator %s)", this->v_identifier, pNewChannel->v_identifier, pProtIdent->v_identifier));
									} else {
										pNewChannel->v_ClientHandlerAssociated = KSBASE_CH_ASSOCIATED;
									}
								}
							}
						}
						else
						{
							pNewChannel->v_ClientHandlerAssociated = KSBASE_CH_NOTNEEDED;
						}

					} else {
						KS_logfile_error(("%s: Creation of TCPChannel for %s failed (socket %d).", this->v_identifier, buf, cfd));
					}
				}
				else
				{
					KS_logfile_error(("%s: Activity on socket, but accept returned %d --> no Channel created", this->v_identifier, cfd));
					KS_logfile_print_sysMsg();
				}
			}
		}
	}
	return;
}

