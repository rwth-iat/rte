#include "ov.ovm"
#include "ksbase.ovm"

LIBRARY iec62541
	VERSION   = "V0.1 (DD-Mon-YYYY)";
	AUTHOR    = "";
	COPYRIGHT = "";
	COMMENT   = "";
	
	/**
	 *	Checks whether received data complies with a OPC UA opening of a connection
	 *	criteria are:	1.	"HEL" in first three byets of message
	 *					2.	ProtocolVersion is not larger than the highes specified version number of iec62541 				
	 *					3.	Message size (starting in byte 5) is larger than 32
	 *					4.	Message size equals 32 + plus the given size in the EndpointUrl length field	
	 */
	CLASS uaIdentificator : CLASS ksbase/ProtocolIdentificator
		IS_INSTANTIABLE;
		COMMENT = "class for identifing ua communication";
		VARIABLES
			ident				:	STRING
				COMMENT			= "first bytes of initial package"
				INITIALVALUE	= "HEL";
			msgMinSize			:	UINT
				COMMENT			= "Minimum size of a valid message"
				INITIALVALUE	= 32;
			highestOPCVersion	: UINT
				COMMENT			= "Highest specified OPC uA Version number"
				INITIALVALUE	= 0;
		END_VARIABLES;
		OPERATIONS
			constructor		:	C_FUNCTION	<OV_FNC_CONSTRUCTOR>;
			identify		:	C_FUNCTION	<KSBASE_FNC_IDENTIFY>;
			createClientHandler	:	C_FUNCTION	<KSBASE_FNC_CREATECH>;
		END_OPERATIONS;
	END_CLASS;
	
	/**
		Documentation of uaClientHandler.
	*/
	CLASS uaClientHandler : CLASS ksbase/ClientHandler
		IS_INSTANTIABLE;
		VARIABLES
			serverProtocolVersion	:	UINT
				COMMENT			= "Latest version of OPC UA TCP protocol supported by this server"
				INITIALVALUE	= 0;
			serverReceiveBufferSize	:	UINT
				COMMENT			= "Largest message (chunk) this server can receive"
				INITIALVALUE	= 65536;
			serverSendBufferSize	: UINT
				COMMENT			= "Largest message (chunk) this server will send"
				INITIALVALUE	= 65536;
			serverMaxMessageSize	: UINT
				COMMENT			= "Maximum size for any response message sent to this server"
				INITIALVALUE	= 65536;
			serverMaxChunkCount		: UINT
				COMMENT			= "Maximum number of chunks this server can handle"
				INITIALVALUE	= 1;
			serverEndpointUrl []	: STRING
				COMMENT			= "URL this clients wants to connect to";			
			clientProtocolVersion	:	UINT
				COMMENT			= "Latest version of OPC UA TCP protocol supported by tjhe client"
				INITIALVALUE	= 0;
			clientReceiveBufferSize	:	UINT
				COMMENT			= "Largest message (chunk) the client can receive"
				INITIALVALUE	= 0;
			clientSendBufferSize	: UINT
				COMMENT			= "Largest message (chunk) the client will send"
				INITIALVALUE	= 0;
			clientMaxMessageSize	: UINT
				COMMENT			= "Maximum size for any response message sent to this client"
				INITIALVALUE	= 0;
			clientMaxChunkCount		: UINT
				COMMENT			= "Maximum number of chunks this client can handle"
				INITIALVALUE	= 0;
			clientEndpointUrl		: STRING
				COMMENT			= "URL this clients wants to connect to"
				INITIALVALUE	= "";
		END_VARIABLES;
		OPERATIONS
			startup			:	C_FUNCTION <OV_FNC_STARTUP>;
			shutdown		:	C_FUNCTION	<OV_FNC_SHUTDOWN>;
			/**
			 *	The HandleRequest function is called by a Channel after some data has arrived for this ClientHandler. It gets the pointer to the Channel, a pointer to the received data, and a pointer to the outData variable.
			 *	As this functions gets the pointers to the buffers of the Channel object it has to take care of a few things:
			 *		1. If the input data could be processed or if it is invalid it should be freed.
			 *		2. The Writeptr of the received data may not be altered.
			 *		3. The answers always have to be appended to the answer structure (use the ksbase_KSDATAPACKET_append function).
			 *		4. The readptr of the answer data may not be altered.
			 */
			HandleRequest	:	C_FUNCTION	<KSBASE_FNC_HANDLEREQUEST>;	
		END_OPERATIONS;
	END_CLASS;
	
	CLASS uaSimpleTicketAuthenticator	:	CLASS ksbase/TicketAuthenticator
	IS_INSTANTIABLE;
	COMMENT	=	"Authenticator for simple tickets transportes via upc ua";
	OPERATIONS
		constructor		:	C_FUNCTION	<OV_FNC_CONSTRUCTOR>;
 		startup			:	C_FUNCTION	<OV_FNC_STARTUP>;
 		shutdown		:	C_FUNCTION	<OV_FNC_SHUTDOWN>;
		/*
 		*	These functions conform to the prototypes in a OV_TICKET_VTBL they are linked to the ticket itself to conform to ov-standards.
 		*	The functions do NOT get a this-pointer. Hence TicketAuthenticators have to be Singletons!!! 
 		*/
 		createticket	:	C_FUNCTION	<KSBASE_FNC_CREATETICKET>;
 		deleteticket	:	C_FUNCTION	<KSBASE_FNC_DELETETICKET>;
		encodereply		:	C_FUNCTION	<KSBASE_FNC_ENCODEREPLY>;
		TicketGetaccess		:	C_FUNCTION	<KSBASE_FNC_GETACCESS>;
	END_OPERATIONS;	
	END_CLASS;
	
	/**
		Add associations and their documentation here.
		Association syntax is:
	*/
	//ASSOCIATION assocName : ONE_TO_MANY
	//	PARENT parentVarName : CLASS ov/object;
	//	CHILD  childVarName : CLASS ov/object;
	//END_ASSOCIATION;
	
END_LIBRARY;
