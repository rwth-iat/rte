#include "ov.ovm"
#include "ksbase.ovm"

LIBRARY iec62541
	VERSION   = "V0.1 (DD-Mon-YYYY)";
	AUTHOR    = "";
	COPYRIGHT = "";
	COMMENT   = "";
	
	CLASS uaServer		:	CLASS ov/domain
		IS_INSTANTIABLE;
		COMMENT = "Holds all necessarry data for a server - singleton. can only be instantiated once";
		VARIABLES
			endpointName		:	STRING
				HAS_SET_ACCESSOR
				COMMENT			=	"Name of the endpoint this server represents"
				INITIALVALUE	=	"OV_UA";
			endpointUrl			:	C_TYPE	<UA_String>;
			serverData			:	C_TYPE	<UA_Server>
				COMMENT	=	"Stack-specific representation of server data";
			nodeStoreNs0		:	C_TYPE	<UA_ExternalNodeStore>;
			nodeStoreNsOV		:	C_TYPE	<UA_ExternalNodeStore>;
		END_VARIABLES;	
		OPERATIONS
			constructor			:	C_FUNCTION <OV_FNC_CONSTRUCTOR>;
			destructor			:	C_FUNCTION <OV_FNC_DESTRUCTOR>;
			startup				:	C_FUNCTION <OV_FNC_STARTUP>;
			shutdown			:	C_FUNCTION <OV_FNC_SHUTDOWN>;
			getaccess			:	C_FUNCTION <OV_FNC_GETACCESS>;
		END_OPERATIONS;
	END_CLASS;
	
	CLASS uaNamespace0		:	CLASS ov/domain
		IS_INSTANTIABLE;
		COMMENT = "Holds the 0 namespace of the uaServer - singleton. can only be instantiated once";
		VARIABLES
			
		END_VARIABLES;	
		OPERATIONS
			constructor		:	C_FUNCTION	<OV_FNC_CONSTRUCTOR>;
			startup			:	C_FUNCTION	<OV_FNC_STARTUP>;
			getNodePtr		:	C_FUNCTION	<UA_FNC_GETNODEPTR>;
			addNodes		:	C_FUNCTION	<UA_FNC_ADDNODES>;
			addReferences	:	C_FUNCTION	<UA_FNC_ADDREFERENCES>;
			deleteNodes		:	C_FUNCTION	<UA_FNC_DELETENODES>;
			deleteReferences :	C_FUNCTION	<UA_FNC_DELETEREFERENCES>;
			readNodes		:	C_FUNCTION	<UA_FNC_READNODES>;
			writeNodes		:	C_FUNCTION	<UA_FNC_WRITENODES>;
			browseNodes		:	C_FUNCTION	<UA_FNC_BROWSENODES>;
		END_OPERATIONS;
	END_CLASS;
	
	
	
	CLASS uaBaseNodeType	:	CLASS ov/domain
		VARIABLES
			NodeId		:	UINT;	/*	used in the findNode function , BrowseName and DisplayName mirror the objects identifier	*/	
			WriteMask	:	UINT;
		END_VARIABLES;	
		OPERATIONS
			getaccess	:	C_FUNCTION <OV_FNC_GETACCESS>;
		END_OPERATIONS;
	END_CLASS;
	
	CLASS uaReferenceTypeNode	:	CLASS	iec62541/uaBaseNodeType
		IS_INSTANTIABLE;
		VARIABLES
			IsAbstract	:	BOOL
				INITIALVALUE	=	FALSE;
			Symmetric	:	BOOL
				INITIALVALUE	=	FALSE;	
		END_VARIABLES;	
	END_CLASS;
	
	CLASS uaReferenceNode	:	CLASS	iec62541/uaBaseNodeType
		IS_INSTANTIABLE;
		VARIABLES
			Type	:	UINT
				INITIALVALUE	=	31;	
		END_VARIABLES;	
	END_CLASS;
	
	CLASS uaObjectNode	:	CLASS	iec62541/uaBaseNodeType
		IS_INSTANTIABLE;
		VARIABLES
			EventNotifier	:	UINT
				INITIALVALUE	=	0;
			Type	:	UINT
				INITIALVALUE	=	58;
		END_VARIABLES;	
	END_CLASS;
	
	CLASS uaObjectTypeNode	:	CLASS	iec62541/uaBaseNodeType
		IS_INSTANTIABLE;
		VARIABLES
			IsAbstract	:	BOOL
				INITIALVALUE	=	FALSE;	
		END_VARIABLES;	
	END_CLASS;
	
	CLASS uaVariableNode	:	CLASS	iec62541/uaBaseNodeType
		IS_INSTANTIABLE;
		VARIABLES
			Value		:	ANY;
			DataType	:	UINT;
			ValueRank	:	INT;
			ArrayDimensions	:	INT
				INITIALVALUE	=	0;
			AccessLevel	:	UINT
				INITIALVALUE	=	1; /*	read access	*/
			Historizing	:	BOOL
				INITIALVALUE	=	FALSE;
			Type	:	UINT
				INITIALVALUE	=	63;
		END_VARIABLES;	
	END_CLASS;
	
	CLASS uaVariableTypeNode	:	CLASS	iec62541/uaBaseNodeType
		IS_INSTANTIABLE;
		VARIABLES
			Value		:	ANY;
			DataType	:	UINT;
			ValueRank	:	INT;
			ArrayDimensions	:	INT
				INITIALVALUE	=	0;
			IsAbstract	:	BOOL
				INITIALVALUE	=	FALSE;		
		END_VARIABLES;	
	END_CLASS;
	
	CLASS uaDataTypeNode	:	CLASS	iec62541/uaBaseNodeType
		IS_INSTANTIABLE;
		VARIABLES
			IsAbstract	:	BOOL
				INITIALVALUE	=	FALSE;		
		END_VARIABLES;	
	END_CLASS;
	
	/**
	 *	Checks whether received data complies with a OPC UA opening of a connection
	 *	criteria are:	1.	"HEL" in first three bytes of message
	 *					2.	ProtocolVersion is not larger than the highest specified version number of iec62541 				
	 *					3.	Message size (starting in byte 5) is larger than 32
	 *					4.	Message size equals 32 + plus the given size in the EndpointUrl length field	
	 */
	CLASS uaIdentificator : CLASS ksbase/ProtocolIdentificator
		IS_INSTANTIABLE;
		COMMENT = "class for identifing ua communication";
		VARIABLES
			ident				:	STRING
				COMMENT			= "first bytes of initial package"
				INITIALVALUE	= "HEL";
			msgMinSize			:	UINT
				COMMENT			= "Minimum size of a valid message"
				INITIALVALUE	= 32;
			highestOPCVersion	: UINT
				COMMENT			= "Highest specified OPC uA Version number"
				INITIALVALUE	= 0;
		END_VARIABLES;
		OPERATIONS
			constructor		:	C_FUNCTION	<OV_FNC_CONSTRUCTOR>;
			identify		:	C_FUNCTION	<KSBASE_FNC_IDENTIFY>;
			createClientHandler	:	C_FUNCTION	<KSBASE_FNC_CREATECH>;
		END_OPERATIONS;
	END_CLASS;
	
	/**
		Documentation of uaClientHandler.
	*/
	CLASS uaClientHandler : CLASS ksbase/ClientHandler
		IS_INSTANTIABLE;
		VARIABLES
			serverProtocolVersion	:	UINT
				IS_DERIVED
				HAS_ACCESSORS
				COMMENT			= "Latest version of OPC UA TCP protocol supported by this server";
			serverReceiveBufferSize	:	UINT
				IS_DERIVED
				HAS_ACCESSORS
				COMMENT			= "Largest message (chunk) this server can receive";
			serverSendBufferSize	: UINT
				IS_DERIVED
				HAS_ACCESSORS
				COMMENT			= "Largest message (chunk) this server will send";
			serverMaxMessageSize	: UINT
				IS_DERIVED
				HAS_ACCESSORS
				COMMENT			= "Maximum size for any response message sent to this server";
			serverMaxChunkCount		: UINT
				IS_DERIVED
				HAS_ACCESSORS
				COMMENT			= "Maximum number of chunks this server can handle";
			serverEndpointUrl []	: STRING
				COMMENT			= "URL this clients wants to connect to";			
			clientProtocolVersion	:	UINT
				IS_DERIVED
				HAS_ACCESSORS
				COMMENT			= "Latest version of OPC UA TCP protocol supported by the client";
			clientReceiveBufferSize	:	UINT
				IS_DERIVED
				HAS_ACCESSORS
				COMMENT			= "Largest message (chunk) the client can receive";
			clientSendBufferSize	: UINT
				IS_DERIVED
				HAS_ACCESSORS
				COMMENT			= "Largest message (chunk) the client will send";
			clientMaxMessageSize	: UINT
				IS_DERIVED
				HAS_ACCESSORS
				COMMENT			= "Maximum size for any response message sent to this client";
			clientMaxChunkCount		: UINT
				IS_DERIVED
				HAS_ACCESSORS
				COMMENT			= "Maximum number of chunks this client can handle";
			clientEndpointUrl		: STRING
				COMMENT			= "URL this clients wants to connect to"
				INITIALVALUE	= "";
			connectionData		:	C_TYPE <ov_UA_Connection>;
		END_VARIABLES;
		OPERATIONS
			constructor			:	C_FUNCTION <OV_FNC_CONSTRUCTOR>;
			destructor			:	C_FUNCTION <OV_FNC_DESTRUCTOR>;
			startup			:	C_FUNCTION <OV_FNC_STARTUP>;
			shutdown		:	C_FUNCTION	<OV_FNC_SHUTDOWN>;
			/**
			 *	The HandleRequest function is called by a Channel after some data has arrived for this ClientHandler. It gets the pointer to the Channel, a pointer to the received data, and a pointer to the outData variable.
			 *	As this functions gets the pointers to the buffers of the Channel object it has to take care of a few things:
			 *		1. If the input data could be processed or if it is invalid it should be freed.
			 *		2. The Writeptr of the received data may not be altered.
			 *		3. The answers always have to be appended to the answer structure (use the ksbase_KSDATAPACKET_append function).
			 *		4. The readptr of the answer data may not be altered.
			 */
			HandleRequest	:	C_FUNCTION	<KSBASE_FNC_HANDLEREQUEST>;	
		END_OPERATIONS;
	END_CLASS;
	
	CLASS uaSimpleTicketAuthenticator	:	CLASS ksbase/TicketAuthenticator
	IS_INSTANTIABLE;
	COMMENT	=	"Authenticator for simple tickets transportes via upc ua";
	OPERATIONS
		constructor		:	C_FUNCTION	<OV_FNC_CONSTRUCTOR>;
 		startup			:	C_FUNCTION	<OV_FNC_STARTUP>;
 		shutdown		:	C_FUNCTION	<OV_FNC_SHUTDOWN>;
		/*
 		*	These functions conform to the prototypes in a OV_TICKET_VTBL they are linked to the ticket itself to conform to ov-standards.
 		*	The functions do NOT get a this-pointer. Hence TicketAuthenticators have to be Singletons!!! 
 		*/
 		createticket	:	C_FUNCTION	<KSBASE_FNC_CREATETICKET>;
 		deleteticket	:	C_FUNCTION	<KSBASE_FNC_DELETETICKET>;
		encodereply		:	C_FUNCTION	<KSBASE_FNC_ENCODEREPLY>;
		TicketGetaccess		:	C_FUNCTION	<KSBASE_FNC_GETACCESS>;
	END_OPERATIONS;	
	END_CLASS;
	
	CLASS nodeStoreFunctions	:	CLASS ov/object
	COMMENT	=	"Implementations of nodestore functions to build up the interface between stack an ov-data";
	OPERATIONS
		addNodes		:	C_FUNCTION	<UA_FNC_ADDNODES>;
		addReferences	:	C_FUNCTION	<UA_FNC_ADDREFERENCES>;
		deleteNodes		:	C_FUNCTION	<UA_FNC_DELETENODES>;
		deleteReferences :	C_FUNCTION	<UA_FNC_DELETEREFERENCES>;
		readNodes		:	C_FUNCTION	<UA_FNC_READNODES>;
		writeNodes		:	C_FUNCTION	<UA_FNC_WRITENODES>;
		browseNodes		:	C_FUNCTION	<UA_FNC_BROWSENODES>;
	END_OPERATIONS;	
	END_CLASS;
	
	/**
		Add associations and their documentation here.
		Association syntax is:
	*/
	ASSOCIATION Reference1 : ONE_TO_MANY
		PARENT node1		: CLASS iec62541/uaBaseNodeType;
		CHILD  reference1	: CLASS iec62541/uaReferenceNode;
	END_ASSOCIATION;
	
	ASSOCIATION Reference2 : ONE_TO_MANY
		PARENT node2		: CLASS iec62541/uaBaseNodeType;
		CHILD  reference2	: CLASS iec62541/uaReferenceNode;
	END_ASSOCIATION;
	
END_LIBRARY;
