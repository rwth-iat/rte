
/******************************************************************************
 *
 *   FILE
 *   ----
 *   nodeStoreFunctions.c
 *
 *   History
 *   -------
 *   2014-10-21   File created
 *
 *******************************************************************************
 *
 *   This file is generated by the 'acplt_builder' command
 *
 ******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_iec62541
#define OV_COMPILE_LIBRARY_iec62541
#endif



#include "libov/ov_macros.h"
#include "ksbase.h"
#include "iec62541.h"
#include "iec62541_helpers.h"
#include "NoneTicketAuthenticator.h"
#include "libov/ov_path.h"
#include "libov/ov_memstack.h"



OV_DLLFNCEXPORT UA_Int32 iec62541_nodeStoreFunctions_addNodes(
		UA_AddNodesItem *nodesToAdd,
		UA_UInt32 *indices,
		UA_UInt32 indicesSize,
		UA_AddNodesResult* addNodesResults,
		UA_DiagnosticInfo *diagnosticInfos
) {
	return UA_STATUSCODE_BADNOTIMPLEMENTED;
}

OV_DLLFNCEXPORT UA_Int32 iec62541_nodeStoreFunctions_addReferences(
		UA_AddReferencesItem* referencesToAdd,
		UA_UInt32 *indices,
		UA_UInt32 indicesSize,
		UA_StatusCode *addReferencesResults,
		UA_DiagnosticInfo diagnosticInfos
) {
	return UA_STATUSCODE_BADNOTIMPLEMENTED;
}

OV_DLLFNCEXPORT UA_Int32 iec62541_nodeStoreFunctions_deleteNodes(
		UA_DeleteNodesItem *nodesToDelete,
		UA_UInt32 *indices,
		UA_UInt32 indicesSize,
		UA_StatusCode *deleteNodesResults,
		UA_DiagnosticInfo *diagnosticInfos
) {
	return UA_STATUSCODE_BADNOTIMPLEMENTED;
}

OV_DLLFNCEXPORT UA_Int32 iec62541_nodeStoreFunctions_deleteReferences(
		UA_DeleteReferencesItem *referenceToDelete,
		UA_UInt32 *indices,
		UA_UInt32 indicesSize,
		UA_StatusCode deleteReferencesresults,
		UA_DiagnosticInfo diagnosticInfos
) {
	return UA_STATUSCODE_BADNOTIMPLEMENTED;
}

OV_DLLFNCEXPORT UA_Int32 iec62541_nodeStoreFunctions_readNodes(
		UA_ReadValueId *readValueIds,
		UA_UInt32 *indices,
		UA_UInt32 indicesSize,
		UA_DataValue *readNodesResults,
		UA_Boolean timeStampToReturn,
		UA_DiagnosticInfo *diagnosticInfos
) {

	OV_TICKET *pTicket = NULL;
	OV_PATH path;
	OV_STRING tmpString;
	OV_RESULT result;
	OV_INSTPTR_ov_object	pobj = NULL;
	OV_VTBLPTR_ov_object	pVtblObj = NULL;
	OV_ANY					value = {.value.vartype = OV_VT_VOID, .value.valueunion.val_string = NULL};
	OV_ANY					emptyAny = {.value.vartype = OV_VT_VOID, .value.valueunion.val_string = NULL};
	pTicket = ksbase_NoneAuth->v_ticket.vtbl->createticket(NULL, OV_TT_NONE);


	for(OV_UINT i = 0; i<indicesSize;i++){
		switch(readValueIds[indices[i]].attributeId){
		case UA_ATTRIBUTEID_NODEID:

			break;

		case UA_ATTRIBUTEID_NODECLASS:

			break;

		case UA_ATTRIBUTEID_BROWSENAME:
			break;

		case UA_ATTRIBUTEID_DISPLAYNAME:
			break;

		case UA_ATTRIBUTEID_DESCRIPTION:
			break;

		case UA_ATTRIBUTEID_WRITEMASK:
			break;

		case UA_ATTRIBUTEID_USERWRITEMASK:
			break;

		case UA_ATTRIBUTEID_ISABSTRACT:
			break;

		case UA_ATTRIBUTEID_SYMMETRIC:
			break;

		case UA_ATTRIBUTEID_INVERSENAME:
			break;

		case UA_ATTRIBUTEID_CONTAINSNOLOOPS:
			break;

		case UA_ATTRIBUTEID_EVENTNOTIFIER:
			break;

		case UA_ATTRIBUTEID_VALUE:
			if(readValueIds[indices[i]].nodeId.identifierType != UA_NODEIDTYPE_STRING){
				readNodesResults[indices[i]].status = UA_STATUSCODE_BADNODEIDINVALID;
				break;
			}
			ov_memstack_lock();
			tmpString = ov_memstack_alloc(readValueIds[indices[i]].nodeId.identifier.string.length + 1);
			if(!tmpString){
				readNodesResults[indices[i]].status = UA_STATUSCODE_BADOUTOFMEMORY;
				ov_memstack_unlock();
				break;
			}
			memcpy(tmpString,readValueIds[indices[i]].nodeId.identifier.string.data,readValueIds[indices[i]].nodeId.identifier.string.length);
			tmpString[readValueIds[indices[i]].nodeId.identifier.string.length] = 0;
			result = ov_path_resolve(&path,NULL,tmpString, 2);
			if(Ov_Fail(result)){
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(result);
				ov_memstack_unlock();
				break;
			}
			/*
			 *	get the vtable pointer of the object the variable belongs to
			 */
			pobj = path.elements[path.size-1].pobj;
			Ov_GetVTablePtr(ov_object, pVtblObj, pobj);
			if((!pVtblObj) || (ov_activitylock)){
				pVtblObj = pclass_ov_object->v_pvtable;
			}
			/*
			 *	test if we have access to this variable
			 */
			if(!(pVtblObj->m_getaccess(pobj, &(path.elements[path.size-1]), pTicket) & OV_AC_READ)) {
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_NOACCESS);
				ov_memstack_unlock();
				break;
			}
			switch(path.elements[path.size-1].elemtype) {
				case OV_ET_MEMBER:
				case OV_ET_VARIABLE:
					/*
					 *	get the variable's value, timestamp and time
					 */
					readNodesResults[indices[i]].status = ov_resultToUaStatusCode((pVtblObj->m_getvar)(pobj, &(path.elements[path.size-1]), &value));
					value.value.vartype &= OV_VT_KSMASK;
					if(readNodesResults[indices[i]].status == UA_STATUSCODE_GOOD){
						readNodesResults[indices[i]].status = ov_AnyToVariant(&value, &(readNodesResults[indices[i]].value));
						readNodesResults[indices[i]].encodingMask = UA_DATAVALUE_ENCODINGMASK_VARIANT;
						ov_variable_setanyvalue(&value, &emptyAny);
					}
					ov_memstack_unlock();
					break;
				default:
					readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADPATH);
					ov_memstack_unlock();
					break;
				}
			break;

			case UA_ATTRIBUTEID_DATATYPE:
				break;

			case UA_ATTRIBUTEID_VALUERANK:
				break;

			case UA_ATTRIBUTEID_ARRAYDIMENSIONS:
				break;

			case UA_ATTRIBUTEID_ACCESSLEVEL:
				break;

			case UA_ATTRIBUTEID_USERACCESSLEVEL:
				break;

			case UA_ATTRIBUTEID_MINIMUMSAMPLINGINTERVAL:
				break;

			case UA_ATTRIBUTEID_HISTORIZING:
				break;

			case UA_ATTRIBUTEID_EXECUTABLE:
				break;

			case UA_ATTRIBUTEID_USEREXECUTABLE:
				break;

			default:
				break;
		}

		//if(retval != UA_STATUSCODE_GOOD) {
		//	readNodesResults[indices].encodingMask = UA_DATAVALUE_ENCODINGMASK_STATUSCODE;
		//	readNodesResults[indices].status       = UA_STATUSCODE_BADNOTREADABLE;
		// }
	}
	return UA_STATUSCODE_GOOD;
}

OV_DLLFNCEXPORT UA_Int32 iec62541_nodeStoreFunctions_writeNodes(
		UA_WriteValue *writeValues,
		UA_UInt32 *indices,
		UA_UInt32 indicesSize,
		UA_StatusCode *writeNodesResults,
		UA_DiagnosticInfo *diagnosticInfo
) {
	return UA_STATUSCODE_BADNOTIMPLEMENTED;

}

OV_DLLFNCEXPORT UA_Int32 iec62541_nodeStoreFunctions_browseNodes(
		UA_UInt32 requestedMaxReferencesPerNode,
		UA_BrowseDescription *browseDescriptions,
		UA_Int32 *indices,
		UA_UInt32 indicesSize,
		UA_BrowseResult *browseResults,
		UA_DiagnosticInfo *diagnosticInfos
) {
	return UA_STATUSCODE_BADNOTIMPLEMENTED;
}

