
/******************************************************************************
 *
 *   FILE
 *   ----
 *   nodeStoreFunctions.c
 *
 *   History
 *   -------
 *   2014-10-21   File created
 *
 *******************************************************************************
 *
 *   This file is generated by the 'acplt_builder' command
 *
 ******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_iec62541
#define OV_COMPILE_LIBRARY_iec62541
#endif



#include "libov/ov_macros.h"
#include "ksbase.h"
#include "iec62541.h"
#include "iec62541_helpers.h"
#include "NoneTicketAuthenticator.h"
#include "libov/ov_path.h"
#include "libov/ov_memstack.h"

OV_DLLFNCEXPORT UA_Int32 iec62541_nodeStoreFunctions_readNodes(
		UA_ReadValueId *readValueIds,
		UA_UInt32 *indices,
		UA_UInt32 indicesSize,
		UA_DataValue *readNodesResults,
		UA_Boolean timeStampToReturn,
		UA_DiagnosticInfo *diagnosticInfos
) {

	OV_TICKET *pTicket = NULL;
	OV_PATH path;
	OV_INSTPTR_ov_object	pobj = NULL;
	OV_VTBLPTR_ov_object	pVtblObj = NULL;
	OV_ACCESS				access;
	OV_ANY					value = {.value.vartype = OV_VT_VOID, .value.valueunion.val_string = NULL};
	OV_ANY					emptyAny = {.value.vartype = OV_VT_VOID, .value.valueunion.val_string = NULL};
	pTicket = ksbase_NoneAuth->v_ticket.vtbl->createticket(NULL, OV_TT_NONE);


	for(OV_UINT i = 0; i<indicesSize;i++){
		switch(readValueIds[indices[i]].attributeId){
		/*******************************************************************************************************************************************
		 * NODEID - every type of node has one. we return the full canonical path to this node (including a part's name)
		 *******************************************************************************************************************************************/
		case UA_ATTRIBUTEID_NODEID:
			ov_memstack_lock();
			readNodesResults[indices[i]].status = iec62541_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			readNodesResults[indices[i]].status = iec62541_nodeStoreFunctions_getVtblPointerAndCheckAccess(&(path.elements[path.size-1]), pTicket, &pobj, &pVtblObj, &access);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			if(access & OV_AC_READ){
				UA_NodeId	*nodeId;
				OV_STRING 	tempStr1 = NULL;
				OV_STRING 	tempStr2 = NULL;
				nodeId = UA_NodeId_new();
				if(!nodeId){
					readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
					ov_memstack_unlock();
					break;
				}
				nodeId->namespaceIndex = readValueIds[indices[i]].nodeId.namespaceIndex;
				nodeId->identifierType = UA_NODEIDTYPE_STRING;
				switch(path.elements[path.size-1].elemtype){
				case OV_ET_OBJECT:
					readNodesResults[indices[i]].status = UA_String_copycstring(ov_path_getcanonicalpath(pobj, 2) , &(nodeId->identifier.string));
					break;
				case OV_ET_VARIABLE:
				case OV_ET_MEMBER:
				case OV_ET_OPERATION:
					tempStr1 = ov_path_getcanonicalpath(path.elements[path.size-1].pobj, 2);
					if(!tempStr1){
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
						break;
					}
					if(!path.elements[path.size-1].elemunion.pobj){
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
						break;
					}
					tempStr2 = ov_memstack_alloc((strlen(tempStr1) + 1 + strlen(path.elements[path.size-1].elemunion.pobj->v_identifier) + 1) * sizeof(char));
					if(!tempStr1){
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
						break;
					}
					sprintf(tempStr2, "%s.%s", tempStr1, path.elements[path.size-1].elemunion.pobj->v_identifier);
					readNodesResults[indices[i]].status = UA_String_copycstring(tempStr2 , &(nodeId->identifier.string));
					break;
				case OV_ET_PARENTLINK:
					tempStr1 = ov_path_getcanonicalpath(path.elements[path.size-1].pobj, 2);
					if(!tempStr1){
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
						break;
					}
					if(!path.elements[path.size-1].elemunion.passoc){
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
						break;
					}
					tempStr2 = ov_memstack_alloc((strlen(tempStr1) + 1 + strlen(path.elements[path.size-1].elemunion.passoc->v_parentrolename) + 1) * sizeof(char));
					if(!tempStr1){
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
						break;
					}
					sprintf(tempStr2, "%s.%s", tempStr1, path.elements[path.size-1].elemunion.passoc->v_parentrolename);
					readNodesResults[indices[i]].status = UA_String_copycstring(tempStr2 , &(nodeId->identifier.string));
					break;
				case OV_ET_CHILDLINK:
					tempStr1 = ov_path_getcanonicalpath(path.elements[path.size-1].pobj, 2);
					if(!tempStr1){
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
						break;
					}
					if(!path.elements[path.size-1].elemunion.passoc){
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
						break;
					}
					tempStr2 = ov_memstack_alloc((strlen(tempStr1) + 1 + strlen(path.elements[path.size-1].elemunion.passoc->v_childrolename) + 1) * sizeof(char));
					if(!tempStr1){
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
						break;
					}
					sprintf(tempStr2, "%s.%s", tempStr1, path.elements[path.size-1].elemunion.passoc->v_childrolename);
					readNodesResults[indices[i]].status = UA_String_copycstring(tempStr2 , &(nodeId->identifier.string));
					break;
				default:
					readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADOBJTYPE);
					break;
				}
				readNodesResults[indices[i]].value.vt = &UA_TYPES[UA_NODEID];
				readNodesResults[indices[i]].value.storage.data.arrayLength = 1;
				readNodesResults[indices[i]].value.storage.data.dataPtr = nodeId;
				readNodesResults[indices[i]].value.storage.data.arrayDimensionsLength = 1;
				readNodesResults[indices[i]].value.storage.data.arrayDimensions = NULL;
				readNodesResults[indices[i]].encodingMask = UA_DATAVALUE_ENCODINGMASK_VARIANT;
			} else {
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_NOACCESS);
			}
			ov_memstack_unlock();
			break;
			/***************************************************************************************************************************************************
			 * NODECLASS - every type of node has one. we differentiate between Obejcts, Objecttypes (classes), variableTypes (instance of ov/variable) and
			 * 		referenceTypes (instances of ov/assiciation)
			 ***************************************************************************************************************************************************/
		case UA_ATTRIBUTEID_NODECLASS:
			ov_memstack_lock();
			readNodesResults[indices[i]].status = iec62541_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			readNodesResults[indices[i]].status = iec62541_nodeStoreFunctions_getVtblPointerAndCheckAccess(&(path.elements[path.size-1]), pTicket, &pobj, &pVtblObj, &access);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			if(access & OV_AC_READ){
				UA_NodeClass 	*nodeClass;
				nodeClass = UA_NodeClass_new();
				if(!nodeClass){
					readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
					ov_memstack_unlock();
					break;
				}
				switch(path.elements[path.size-1].elemtype){
				case OV_ET_OBJECT:
					if(Ov_GetParent(ov_instantiation, pobj) == pclass_ov_class){
						*nodeClass = UA_NODECLASS_OBJECTTYPE;
					} else if(Ov_GetParent(ov_instantiation, pobj) == pclass_ov_variable){
						*nodeClass = UA_NODECLASS_VARIABLETYPE;
					} else if(Ov_GetParent(ov_instantiation, pobj) == pclass_ov_association){
						*nodeClass = UA_NODECLASS_REFERENCETYPE;
					} else {
						*nodeClass = UA_NODECLASS_OBJECT;
					}
					break;
				case OV_ET_VARIABLE:
				case OV_ET_MEMBER:
					*nodeClass = UA_NODECLASS_VARIABLE;
					break;
				case OV_ET_OPERATION:
					*nodeClass = UA_NODECLASS_METHOD;
					break;
				case OV_ET_CHILDLINK:
				case OV_ET_PARENTLINK:
				default:
					*nodeClass = UA_NODECLASS_UNSPECIFIED;
					break;
				}
				readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
				readNodesResults[indices[i]].value.vt = &UA_TYPES[UA_NODECLASS];
				readNodesResults[indices[i]].value.storage.data.arrayLength = 1;
				readNodesResults[indices[i]].value.storage.data.dataPtr = nodeClass;
				readNodesResults[indices[i]].value.storage.data.arrayDimensionsLength = 1;
				readNodesResults[indices[i]].value.storage.data.arrayDimensions = NULL;
				readNodesResults[indices[i]].encodingMask = UA_DATAVALUE_ENCODINGMASK_VARIANT;
			} else {
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_NOACCESS);
			}
			break;
			/***************************************************************************************************************************************************
			 * BROWSENAME and DISPLYNAME - every type of node has these two. For us they're the same
			 * we return the objects identifier
			 ***************************************************************************************************************************************************/
		case UA_ATTRIBUTEID_BROWSENAME:
		case UA_ATTRIBUTEID_DISPLAYNAME:
			ov_memstack_lock();
			readNodesResults[indices[i]].status = iec62541_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			readNodesResults[indices[i]].status = iec62541_nodeStoreFunctions_getVtblPointerAndCheckAccess(&(path.elements[path.size-1]), pTicket, &pobj, &pVtblObj, &access);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			if(access & OV_AC_READ){
				if(pobj){
					value.value.vartype = OV_VT_STRING;
					value.value.valueunion.val_string = pobj->v_identifier;
					readNodesResults[indices[i]].status = ov_AnyToVariant(&value, &(readNodesResults[indices[i]].value));
					readNodesResults[indices[i]].encodingMask = UA_DATAVALUE_ENCODINGMASK_VARIANT;
					value = emptyAny;
				} else {
					readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADOBJTYPE);
				}
			} else {
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_NOACCESS);
			}
			ov_memstack_unlock();
			break;
			/**********************************************************************************************************************************************************
			 * DESCRIPTION - every type of node has one. We rturn the objects comment (from the class / variable)
			 **********************************************************************************************************************************************************/
		case UA_ATTRIBUTEID_DESCRIPTION:
			ov_memstack_lock();
			readNodesResults[indices[i]].status = iec62541_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			readNodesResults[indices[i]].status = iec62541_nodeStoreFunctions_getVtblPointerAndCheckAccess(&(path.elements[path.size-1]), pTicket, &pobj, &pVtblObj, &access);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			if(access & OV_AC_READ){
				if(pobj){
					value.value.vartype = OV_VT_STRING;
					value.value.valueunion.val_string = pVtblObj->m_getcomment(pobj, &(path.elements[path.size-1]));
					readNodesResults[indices[i]].status = ov_AnyToVariant(&value, &(readNodesResults[indices[i]].value));
					readNodesResults[indices[i]].encodingMask = UA_DATAVALUE_ENCODINGMASK_VARIANT;
					value = emptyAny;
				}
			} else {
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_NOACCESS);
			}
			ov_memstack_unlock();
			break;
			/**********************************************************************************************************************************************************
			 * WRITEMASK and USERWRITEMAS - every type of node has these two. For objects we return writable names (a rename will do it). Nothing more
			 **********************************************************************************************************************************************************/
		case UA_ATTRIBUTEID_WRITEMASK:
		case UA_ATTRIBUTEID_USERWRITEMASK:
		{
			UA_UInt32 *writeMask;
			writeMask = UA_UInt32_new();
			if(!writeMask){
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
				break;
			}
			ov_memstack_lock();
			readNodesResults[indices[i]].status = iec62541_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			if(readValueIds[indices[i]].attributeId == UA_ATTRIBUTEID_WRITEMASK){
				readNodesResults[indices[i]].status = iec62541_nodeStoreFunctions_getVtblPointerAndCheckAccess(&(path.elements[path.size-1]), NULL, &pobj, &pVtblObj, &access);
			} else {
				readNodesResults[indices[i]].status = iec62541_nodeStoreFunctions_getVtblPointerAndCheckAccess(&(path.elements[path.size-1]), pTicket, &pobj, &pVtblObj, &access);
			}
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			writeMask = 0;
			if(path.elements[path.size-1].elemtype != OV_ET_VARIABLE){
				if(access & OV_AC_WRITE){
					*writeMask |= (1<<2);	/*	BrowseName	*/
					*writeMask |= (1<<6);	/*	DisplayName	*/
				}
			}
			readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
			readNodesResults[indices[i]].value.vt = &UA_TYPES[UA_UINT32];
			readNodesResults[indices[i]].value.storage.data.arrayLength = 1;
			readNodesResults[indices[i]].value.storage.data.dataPtr = writeMask;
			readNodesResults[indices[i]].value.storage.data.arrayDimensionsLength = 1;
			readNodesResults[indices[i]].value.storage.data.arrayDimensions = NULL;
			readNodesResults[indices[i]].encodingMask = UA_DATAVALUE_ENCODINGMASK_VARIANT;
			ov_memstack_unlock();
		}
		break;
		/*********************************************************************************************************************************************
		 * ISABSTRACT - Objecttypes, VariableTypes and ReferenceTypes have it. ov only knows abstract Objecttypes which is returned. Other types return FALSE
		 *********************************************************************************************************************************************/
		case UA_ATTRIBUTEID_ISABSTRACT:
		{
			UA_Boolean *isAbstract;
			isAbstract = UA_Boolean_new();
			if(!isAbstract){
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
				break;
			}
			ov_memstack_lock();
			readNodesResults[indices[i]].status = iec62541_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			readNodesResults[indices[i]].status = iec62541_nodeStoreFunctions_getVtblPointerAndCheckAccess(&(path.elements[path.size-1]), pTicket, &pobj, &pVtblObj, &access);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			if(path.elements[path.size-1].elemtype == OV_ET_OBJECT){
				if(Ov_GetParent(ov_instantiation, pobj) == pclass_ov_class){
					if(!(Ov_StaticPtrCast(ov_class, pobj)->v_classprops & OV_CP_INSTANTIABLE)){
						*isAbstract = UA_TRUE; /*	is instantiable is the negation of isAbstract	*/
					} else {
						*isAbstract = UA_FALSE;
					}
				} else if(Ov_GetParent(ov_instantiation, pobj) == pclass_ov_variable){
					*isAbstract = UA_FALSE;
				} else if(Ov_GetParent(ov_instantiation, pobj) == pclass_ov_association){
					*isAbstract = UA_FALSE;
				} else {
					readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADOBJTYPE);
					ov_memstack_unlock();
					break;
				}
			} else {
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADOBJTYPE);
				ov_memstack_unlock();
				break;
			}
			readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
			readNodesResults[indices[i]].value.vt = &UA_TYPES[UA_BOOLEAN];
			readNodesResults[indices[i]].value.storage.data.arrayLength = 1;
			readNodesResults[indices[i]].value.storage.data.dataPtr = isAbstract;
			readNodesResults[indices[i]].value.storage.data.arrayDimensionsLength = 1;
			readNodesResults[indices[i]].value.storage.data.arrayDimensions = NULL;
			readNodesResults[indices[i]].encodingMask = UA_DATAVALUE_ENCODINGMASK_VARIANT;
			ov_memstack_unlock();
		}
		break;
		/*********************************************************************************************************************************************
		 * SYMMETRIC - References have it. ov only knows directed references, so we return FALSE
		 *********************************************************************************************************************************************/
		case UA_ATTRIBUTEID_SYMMETRIC:
		{
			UA_Boolean *isSymmetric;
			isSymmetric = UA_Boolean_new();
			if(!isSymmetric){
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
				break;
			}
			ov_memstack_lock();
			readNodesResults[indices[i]].status = iec62541_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			readNodesResults[indices[i]].status = iec62541_nodeStoreFunctions_getVtblPointerAndCheckAccess(&(path.elements[path.size-1]), pTicket, &pobj, &pVtblObj, &access);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			if(path.elements[path.size-1].elemtype == OV_ET_OBJECT){
				if(Ov_GetParent(ov_instantiation, pobj) == pclass_ov_association){
					*isSymmetric = UA_FALSE;	/*	all ov_associations have a direction	*/
				} else {
					readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADOBJTYPE);
					ov_memstack_unlock();
					break;
				}
			} else {
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADOBJTYPE);
				ov_memstack_unlock();
				break;
			}
			readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
			readNodesResults[indices[i]].value.vt = &UA_TYPES[UA_BOOLEAN];
			readNodesResults[indices[i]].value.storage.data.arrayLength = 1;
			readNodesResults[indices[i]].value.storage.data.dataPtr = isSymmetric;
			readNodesResults[indices[i]].value.storage.data.arrayDimensionsLength = 1;
			readNodesResults[indices[i]].value.storage.data.arrayDimensions = NULL;
			readNodesResults[indices[i]].encodingMask = UA_DATAVALUE_ENCODINGMASK_VARIANT;
			ov_memstack_unlock();
		}
		break;
		/*********************************************************************************************************************************************
		 * INVERSENAME - Reference have it. but ov does not know it
		 *********************************************************************************************************************************************/
		case UA_ATTRIBUTEID_INVERSENAME:	/*	optional and not really a meaningfull mirror in ov (as we define a reference as an assiciation whereas UA defines a reference as one end of an association)	*/
			readNodesResults[indices[i]].status = UA_STATUSCODE_BADNOTIMPLEMENTED;
			break;
			/*********************************************************************************************************************************************
			 * CONTAINSNOLOOPS - Views have it. ov has no views
			 *********************************************************************************************************************************************/
		case UA_ATTRIBUTEID_CONTAINSNOLOOPS:	/*	ov has no view nodes	*/
			readNodesResults[indices[i]].status = UA_STATUSCODE_BADNOTIMPLEMENTED;
			break;
			/*********************************************************************************************************************************************
			 * EVENTNOTIFIER - Objects have it. ov does not support notification, so we return 0
			 *********************************************************************************************************************************************/
		case UA_ATTRIBUTEID_EVENTNOTIFIER:
		{
			UA_Byte *eventNotifer;
			eventNotifer = UA_Byte_new();
			if(!eventNotifer){
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
				break;
			}
			ov_memstack_lock();
			readNodesResults[indices[i]].status = iec62541_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			eventNotifer = 0;

			readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
			readNodesResults[indices[i]].value.vt = &UA_TYPES[UA_BYTE];
			readNodesResults[indices[i]].value.storage.data.arrayLength = 1;
			readNodesResults[indices[i]].value.storage.data.dataPtr = eventNotifer;
			readNodesResults[indices[i]].value.storage.data.arrayDimensionsLength = 1;
			readNodesResults[indices[i]].value.storage.data.arrayDimensions = NULL;
			readNodesResults[indices[i]].encodingMask = UA_DATAVALUE_ENCODINGMASK_VARIANT;
			ov_memstack_unlock();
		}
		break;
		/*********************************************************************************************************************************************
		 * VALUE - Variables and VariableTypes have it. First return the current value the latter return the default value
		 *********************************************************************************************************************************************/
		case UA_ATTRIBUTEID_VALUE:
			ov_memstack_lock();
			readNodesResults[indices[i]].status = iec62541_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			pobj = path.elements[path.size-1].pobj;
			Ov_GetVTablePtr(ov_object, pVtblObj, pobj);
			if((!pVtblObj) || (ov_activitylock)){
				pVtblObj = pclass_ov_object->v_pvtable;
			}
			access = (pVtblObj)->m_getaccess(path.elements[path.size-1].pobj, &(path.elements[path.size-1]), pTicket);
			if(access & OV_AC_READ){
				switch(path.elements[path.size-1].elemtype) {
				case OV_ET_MEMBER:
				case OV_ET_VARIABLE:
					readNodesResults[indices[i]].status = ov_resultToUaStatusCode((pVtblObj->m_getvar)(pobj, &(path.elements[path.size-1]), &value));
					value.value.vartype &= OV_VT_KSMASK;
					if(readNodesResults[indices[i]].status == UA_STATUSCODE_GOOD){
						readNodesResults[indices[i]].status = ov_AnyToVariant(&value, &(readNodesResults[indices[i]].value));
						readNodesResults[indices[i]].encodingMask = UA_DATAVALUE_ENCODINGMASK_VARIANT;
						value = emptyAny;
					}
					break;
				case OV_ET_OBJECT:
					/*	Variables are defined by instances of ov/variable	*/
					if(Ov_GetParent(ov_instantiation, pobj) == pclass_ov_variable){
						readNodesResults[indices[i]].status = ov_AnyToVariant(ov_variable_initialvalue_get(Ov_StaticPtrCast(ov_variable,pobj)), &(readNodesResults[indices[i]].value));
						readNodesResults[indices[i]].encodingMask = UA_DATAVALUE_ENCODINGMASK_VARIANT;
					} else {
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADPATH);
					}
					break;
				default:
					readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADPATH);
					break;
				}
				ov_memstack_unlock();
			}
			break;
			/*********************************************************************************************************************************************
			 * DATATYPE - Variables and VariableTypes have it.
			 *********************************************************************************************************************************************/
		case UA_ATTRIBUTEID_DATATYPE:
		{
			UA_NodeId *dataType;
			ov_memstack_lock();
			readNodesResults[indices[i]].status = iec62541_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			pobj = path.elements[path.size-1].pobj;
			Ov_GetVTablePtr(ov_object, pVtblObj, pobj);
			if((!pVtblObj) || (ov_activitylock)){
				pVtblObj = pclass_ov_object->v_pvtable;
			}
			access = (pVtblObj)->m_getaccess(path.elements[path.size-1].pobj, &(path.elements[path.size-1]), pTicket);
			if(access & OV_AC_READ){
				switch(path.elements[path.size-1].elemtype) {
				case OV_ET_MEMBER:
				case OV_ET_VARIABLE:
					pobj = Ov_StaticPtrCast(ov_object, path.elements[path.size-1].elemunion.pvar);
					if(Ov_GetParent(ov_instantiation, pobj) == pclass_ov_variable){
						dataType = ov_varTypeToNodeId(((OV_INSTPTR_ov_variable)pobj)->v_vartype);
						if(!dataType){
							readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
							break;
						} else {
							readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
						}
					}
					ov_memstack_unlock();
					break;
				case OV_ET_OBJECT:
					/*	Variables are defined by instances of ov/variable	*/
					if(Ov_GetParent(ov_instantiation, pobj) == pclass_ov_variable){
						dataType = ov_varTypeToNodeId(ov_variable_vartype_get(Ov_StaticPtrCast(ov_variable,pobj)));
						if(!dataType){
							readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
							break;
						} else {
							readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
						}
					} else {
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADPATH);
						break;
					}
				default:
					readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADPATH);
					break;
				}
			}
			if(readNodesResults[indices[i]].status == UA_STATUSCODE_GOOD){
				readNodesResults[indices[i]].value.vt = &UA_TYPES[UA_NODEID];
				readNodesResults[indices[i]].value.storage.data.arrayLength = 1;
				readNodesResults[indices[i]].value.storage.data.dataPtr = dataType;
				readNodesResults[indices[i]].value.storage.data.arrayDimensionsLength = 1;
				readNodesResults[indices[i]].value.storage.data.arrayDimensions = NULL;
				readNodesResults[indices[i]].encodingMask = UA_DATAVALUE_ENCODINGMASK_VARIANT;
			}
			ov_memstack_unlock();
		}
		break;
		/*********************************************************************************************************************************************
		 * VALUERANK - Variables and VariableTypes have it. returns the number of dimensions a variable has (scalar, one dimensional array, or both possible)
		 *********************************************************************************************************************************************/
		case UA_ATTRIBUTEID_VALUERANK:
		{
			UA_Int32 *valueRank;
			valueRank = UA_Int32_new();
			if(!valueRank){
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
				break;
			}
			ov_memstack_lock();
			readNodesResults[indices[i]].status = iec62541_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			pobj = path.elements[path.size-1].pobj;
			Ov_GetVTablePtr(ov_object, pVtblObj, pobj);
			if((!pVtblObj) || (ov_activitylock)){
				pVtblObj = pclass_ov_object->v_pvtable;
			}
			access = (pVtblObj)->m_getaccess(path.elements[path.size-1].pobj, &(path.elements[path.size-1]), pTicket);
			if(access & OV_AC_READ){
				switch(path.elements[path.size-1].elemtype) {
				case OV_ET_MEMBER:
				case OV_ET_VARIABLE:
					pobj = Ov_StaticPtrCast(ov_object, path.elements[path.size-1].elemunion.pvar);
					if(Ov_GetParent(ov_instantiation, pobj) == pclass_ov_variable){
						switch((((OV_INSTPTR_ov_variable)pobj)->v_vartype) & OV_VT_KSMASK){
						case OV_VT_ANY:
						case OV_VT_VOID:
							*valueRank = -3;	/*	scalar or one dimension	*/
							readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
							break;
						default:
							if((((OV_INSTPTR_ov_variable)pobj)->v_vartype) & OV_VT_ISVECTOR){
								*valueRank = 1;	/*	one dimension	*/
								readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
							} else {
								*valueRank = -1;	/*	scalar	*/
								readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
							}
							break;
						}
					}
					break;
				case OV_ET_OBJECT:
					if(Ov_GetParent(ov_instantiation, pobj) == pclass_ov_variable){
						switch((((OV_INSTPTR_ov_variable)pobj)->v_vartype) & OV_VT_KSMASK){
						case OV_VT_ANY:
						case OV_VT_VOID:
							*valueRank = -3;	/*	scalar or one dimension	*/
							readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
							break;
						default:
							if((((OV_INSTPTR_ov_variable)pobj)->v_vartype) & OV_VT_ISVECTOR){
								*valueRank = 1;	/*	one dimension	*/
								readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
							} else {
								*valueRank = -1;	/*	scalar	*/
								readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
							}
							break;
						}
					}
					break;
				default:
					readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADPATH);
					break;
				}
			}
			if(readNodesResults[indices[i]].status == UA_STATUSCODE_GOOD){
				readNodesResults[indices[i]].value.vt = &UA_TYPES[UA_INT32];
				readNodesResults[indices[i]].value.storage.data.arrayLength = 1;
				readNodesResults[indices[i]].value.storage.data.dataPtr = valueRank;
				readNodesResults[indices[i]].value.storage.data.arrayDimensionsLength = 1;
				readNodesResults[indices[i]].value.storage.data.arrayDimensions = NULL;
				readNodesResults[indices[i]].encodingMask = UA_DATAVALUE_ENCODINGMASK_VARIANT;
			}
			ov_memstack_unlock();
		}
		break;
		/*********************************************************************************************************************************************
		 * ARRAYDIMENSIONS - Variables and VariableTypes have it. returns the number elements each dimension of a variable can take
		 *********************************************************************************************************************************************/
		case UA_ATTRIBUTEID_ARRAYDIMENSIONS:
		{
			UA_Int32 *arrayDimensions;
			UA_Int32 arrayLength;
			ov_memstack_lock();
			readNodesResults[indices[i]].status = iec62541_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			pobj = path.elements[path.size-1].pobj;
			Ov_GetVTablePtr(ov_object, pVtblObj, pobj);
			if((!pVtblObj) || (ov_activitylock)){
				pVtblObj = pclass_ov_object->v_pvtable;
			}
			access = (pVtblObj)->m_getaccess(path.elements[path.size-1].pobj, &(path.elements[path.size-1]), pTicket);
			if(access & OV_AC_READ){
				switch(path.elements[path.size-1].elemtype) {
				case OV_ET_MEMBER:
				case OV_ET_VARIABLE:
					pobj = Ov_StaticPtrCast(ov_object, path.elements[path.size-1].elemunion.pvar);
					if(Ov_CanCastTo(ov_variable, pobj)){
						switch((((OV_INSTPTR_ov_variable)pobj)->v_vartype) & OV_VT_KSMASK){
						case OV_VT_ANY:
						case OV_VT_VOID:
							arrayLength = 0;
							readNodesResults[indices[i]].status = UA_Array_new((void **)&arrayDimensions, arrayLength, &UA_TYPES[UA_INT32]);	/*	scalar or one dimension	*/
							break;
						default:
							if(((OV_INSTPTR_ov_variable)pobj)->v_veclen == 1){
								/*	scalar	*/
								arrayLength = 0;
								readNodesResults[indices[i]].status = UA_Array_new((void **)&arrayDimensions, arrayLength, &UA_TYPES[UA_INT32]);
							} else {
								/*	vector	*/
								arrayLength = 1;
								readNodesResults[indices[i]].status = UA_Array_new((void **)&arrayDimensions, arrayLength, &UA_TYPES[UA_INT32]);
								if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
									break;
								}
								readNodesResults[indices[i]].status = UA_Array_copy(&(((OV_INSTPTR_ov_variable)pobj)->v_veclen), arrayLength, &UA_TYPES[UA_INT32], (void**)&arrayDimensions);
								break;
							}
						}
					}
					break;
				case OV_ET_OBJECT:
					pobj = Ov_StaticPtrCast(ov_object, path.elements[path.size-1].pobj);
					if(Ov_CanCastTo(ov_variable, pobj)){
						switch((((OV_INSTPTR_ov_variable)pobj)->v_vartype) & OV_VT_KSMASK){
						case OV_VT_ANY:
						case OV_VT_VOID:
							arrayLength = 0;
							readNodesResults[indices[i]].status = UA_Array_new((void **)&arrayDimensions, arrayLength, &UA_TYPES[UA_INT32]);	/*	scalar or one dimension	*/
							break;
						default:
							if(((OV_INSTPTR_ov_variable)pobj)->v_veclen == 1){
								/*	scalar	*/
								arrayLength = 0;
								readNodesResults[indices[i]].status = UA_Array_new((void **)&arrayDimensions, arrayLength, &UA_TYPES[UA_INT32]);
							} else {
								/*	vector	*/
								arrayLength = 1;
								readNodesResults[indices[i]].status = UA_Array_new((void **)&arrayDimensions, arrayLength, &UA_TYPES[UA_INT32]);
								if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
									break;
								}
								readNodesResults[indices[i]].status = UA_Array_copy(&(((OV_INSTPTR_ov_variable)pobj)->v_veclen), arrayLength, &UA_TYPES[UA_INT32], (void**)&arrayDimensions);
								break;
							}
						}
					}
					break;
				default:
					readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADPATH);
					break;
				}
				if(readNodesResults[indices[i]].status == UA_STATUSCODE_GOOD){
					readNodesResults[indices[i]].value.vt = &UA_TYPES[UA_INT32];
					readNodesResults[indices[i]].value.storage.data.arrayLength = arrayLength;
					readNodesResults[indices[i]].value.storage.data.dataPtr = arrayDimensions;
					readNodesResults[indices[i]].value.storage.data.arrayDimensionsLength = 1;
					readNodesResults[indices[i]].value.storage.data.arrayDimensions = NULL;
					readNodesResults[indices[i]].encodingMask = UA_DATAVALUE_ENCODINGMASK_VARIANT;
				}
				ov_memstack_unlock();
			}
		}
		break;
		/*****************************************************************************************************************************************************
		 * ACCESSLEVEL and USERACCESSLEVEL - variables have it. We return the rights of current read and current write according to the ov-access flags
		 * 		all other types of access are unknown to ov and so denied
		 ****************************************************************************************************************************************************/
		case UA_ATTRIBUTEID_ACCESSLEVEL:
		case UA_ATTRIBUTEID_USERACCESSLEVEL:
		{
			UA_Byte *accessLevel;
			accessLevel = UA_Byte_new();
			if(!accessLevel){
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
				break;
			}
			ov_memstack_lock();
			readNodesResults[indices[i]].status = iec62541_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			if(readValueIds[indices[i]].attributeId == UA_ATTRIBUTEID_ACCESSLEVEL){
				readNodesResults[indices[i]].status = iec62541_nodeStoreFunctions_getVtblPointerAndCheckAccess(&(path.elements[path.size-1]), NULL, &pobj, &pVtblObj, &access);
			} else {
				readNodesResults[indices[i]].status = iec62541_nodeStoreFunctions_getVtblPointerAndCheckAccess(&(path.elements[path.size-1]), pTicket, &pobj, &pVtblObj, &access);
			}
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			*accessLevel = 0;
			if(access & OV_AC_READ){
				*accessLevel |= (1<<0);
			}
			if(access & OV_AC_WRITE){
				*accessLevel |= (1<<1);
			}

			readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
			readNodesResults[indices[i]].value.vt = &UA_TYPES[UA_BYTE];
			readNodesResults[indices[i]].value.storage.data.arrayLength = 1;
			readNodesResults[indices[i]].value.storage.data.dataPtr = accessLevel;
			readNodesResults[indices[i]].value.storage.data.arrayDimensionsLength = 1;
			readNodesResults[indices[i]].value.storage.data.arrayDimensions = NULL;
			readNodesResults[indices[i]].encodingMask = UA_DATAVALUE_ENCODINGMASK_VARIANT;
			ov_memstack_unlock();
		}
		break;

		/********************************************************************************************************************************************************
		 * MINIMUMSAMPLINGINTERVAL - variables have it. ov has no means to get such a value from a variables.
		 * 		despite we can determine cyctimes of fbs or comtasks, this is not visible in the ov metamodel
		 ********************************************************************************************************************************************************/
		case UA_ATTRIBUTEID_MINIMUMSAMPLINGINTERVAL:
		{
			UA_Double *interval;
			interval = UA_Double_new();
			if(!interval){
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
				break;
			}
			ov_memstack_lock();
			readNodesResults[indices[i]].status = iec62541_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			*interval =  -1;

			readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
			readNodesResults[indices[i]].value.vt = &UA_TYPES[UA_DOUBLE];
			readNodesResults[indices[i]].value.storage.data.arrayLength = 1;
			readNodesResults[indices[i]].value.storage.data.dataPtr = interval;
			readNodesResults[indices[i]].value.storage.data.arrayDimensionsLength = 1;
			readNodesResults[indices[i]].value.storage.data.arrayDimensions = NULL;
			readNodesResults[indices[i]].encodingMask = UA_DATAVALUE_ENCODINGMASK_VARIANT;
			ov_memstack_unlock();
		}
		break;
		/********************************************************************************************************************************************************
		* HISTORIZING - variables have it. ov has no means to get such a value from a variables.
		* 		despite we can have histories using the ov/kshistlib this is not part of the ov-metamodel
		*********************************************************************************************************************************************************/
		case UA_ATTRIBUTEID_HISTORIZING:
		{
			UA_Boolean *historizing;
			historizing = UA_Boolean_new();
			if(!historizing){
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
				break;
			}
			ov_memstack_lock();
			readNodesResults[indices[i]].status = iec62541_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			historizing = UA_FALSE;

			readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
			readNodesResults[indices[i]].value.vt = &UA_TYPES[UA_BOOLEAN];
			readNodesResults[indices[i]].value.storage.data.arrayLength = 1;
			readNodesResults[indices[i]].value.storage.data.dataPtr = historizing;
			readNodesResults[indices[i]].value.storage.data.arrayDimensionsLength = 1;
			readNodesResults[indices[i]].value.storage.data.arrayDimensions = NULL;
			readNodesResults[indices[i]].encodingMask = UA_DATAVALUE_ENCODINGMASK_VARIANT;
			ov_memstack_unlock();
		}
		break;
		/****************************************************************************************************************************************************
		 * EXECUTABLE and USEREXECUTABLE - methods have it. methods (or operations) in ov are generally not accessable from the outside world
		 * 		despite services are accessible from the outside world, they are specific instances of user-defined classes and not part of the ov-metamodel
		 ****************************************************************************************************************************************************/
		case UA_ATTRIBUTEID_EXECUTABLE:
		case UA_ATTRIBUTEID_USEREXECUTABLE:
		{
			UA_Boolean *executable;
			executable = UA_Boolean_new();
			if(!executable){
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
				break;
			}
			ov_memstack_lock();
			readNodesResults[indices[i]].status = iec62541_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			if(path.elements[path.size-1].elemtype == OV_ET_OPERATION){
				*executable = UA_FALSE;
				readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
				readNodesResults[indices[i]].value.vt = &UA_TYPES[UA_BOOLEAN];
				readNodesResults[indices[i]].value.storage.data.arrayLength = 1;
				readNodesResults[indices[i]].value.storage.data.dataPtr = executable;
				readNodesResults[indices[i]].value.storage.data.arrayDimensionsLength = 1;
				readNodesResults[indices[i]].value.storage.data.arrayDimensions = NULL;
				readNodesResults[indices[i]].encodingMask = UA_DATAVALUE_ENCODINGMASK_VARIANT;
				ov_memstack_unlock();
			} else {
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADOBJTYPE);
				ov_memstack_unlock();
				break;
			}
		}
		break;
		/*****************************************************************************************************************************************************
		 * wtf???
		 ****************************************************************************************************************************************************/
		default:
			readNodesResults[indices[i]].status = UA_STATUSCODE_BADATTRIBUTEIDINVALID;
			break;
		}

		if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD) {
			readNodesResults[indices[i]].encodingMask = UA_DATAVALUE_ENCODINGMASK_STATUSCODE;
		}
	}
	return UA_STATUSCODE_GOOD;
}

