
/******************************************************************************
*
*   FILE
*   ----
*   Clamp.c
*
*   History
*   -------
*   2011-02-07   File created
*
*******************************************************************************
*
*   This file is generated by the 'fb_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_kbuslib
#define OV_COMPILE_LIBRARY_kbuslib
#endif


#include "kbuslib.h"
#include "kbusl.h"
#include "libov/ov_macros.h"
#include "libov/ov_logfile.h"


OV_DLLFNCEXPORT OV_RESULT kbuslib_Clamp_ByteAddress_set(OV_INSTPTR_kbuslib_Clamp pobj, const OV_UINT value)
{
	OV_INSTPTR_ov_object potherClamp;
	OV_INSTPTR_ov_domain	pParent;
	
	/*if clamp is an output, iterate over all clamps of the same type; 
		if there is a clamp with the same number inside the same container -> set Error*/
	
	 
	if((Ov_CanCastTo(kbuslib_AnalogOUT, pobj) || Ov_CanCastTo(kbuslib_SpecialOUT, pobj))
		&& value != pobj->v_ByteAddress)
	{
		pParent = Ov_GetParent(ov_containment, pobj);
		
		Ov_ForEachChild(ov_containment, pParent, potherClamp)
		{
			if((Ov_CanCastTo(kbuslib_AnalogOUT, potherClamp) || Ov_CanCastTo(kbuslib_SpecialOUT, potherClamp))
				&& ((Ov_StaticPtrCast(kbuslib_Clamp, potherClamp)->v_ByteAddress >= value 
						&& Ov_StaticPtrCast(kbuslib_Clamp, potherClamp)->v_ByteAddress 
							<= value + pobj->v_ByteWidth - 1)
					|| (Ov_StaticPtrCast(kbuslib_Clamp, potherClamp)->v_ByteAddress + 
							Ov_StaticPtrCast(kbuslib_Clamp, potherClamp)->v_ByteWidth - 1 >= value
						&& Ov_StaticPtrCast(kbuslib_Clamp, potherClamp)->v_ByteAddress + 
							Ov_StaticPtrCast(kbuslib_Clamp, potherClamp)->v_ByteWidth - 1
							<= value + pobj->v_ByteWidth - 1)))
				
			{
				ov_logfile_error("%s: this space in the OUTput image is already served by %s", pobj->v_identifier, 
					Ov_StaticPtrCast(kbuslib_Clamp, potherClamp)->v_identifier);
				pobj->v_Error = FALSE;
				pobj->v_ErrorCode = KBUS_ERROR_OUTPUT_EXISTS;
				ov_string_setvalue(&pobj->v_ErrorString, KBUS_ERRORSTR_OUTPUT_EXISTS);
				return(OV_ERR_BADPARAM);
			}
		}
	}
	
	if(Ov_CanCastTo(kbuslib_DigitalOUT, pobj) && value != pobj->v_ByteAddress && !(pobj->v_ByteAddress))	/*	the first set is always allowed	*/
	{
		Ov_ForEachChild(ov_instantiation, pclass_kbuslib_DigitalOUT, potherClamp)
		{
			if(Ov_GetParent(ov_containment, pobj) == Ov_GetParent(ov_containment, potherClamp)
				&& Ov_StaticPtrCast(kbuslib_Clamp, potherClamp)->v_ByteAddress == value
				&& Ov_StaticPtrCast(kbuslib_Clamp, potherClamp)->v_BitOffset == pobj->v_BitOffset)
			{
				ov_logfile_error("%s: this digital OUT is already served by %s", pobj->v_identifier, 
					Ov_StaticPtrCast(kbuslib_Clamp, potherClamp)->v_identifier);
				pobj->v_Error = FALSE;
				pobj->v_ErrorCode = KBUS_ERROR_OUTPUT_EXISTS;
				ov_string_setvalue(&pobj->v_ErrorString, KBUS_ERRORSTR_OUTPUT_EXISTS);
				return(OV_ERR_BADPARAM);
			}
		}
	}
	
	pobj->v_ByteAddress = value;
	return(OV_ERR_OK);
}


OV_DLLFNCEXPORT OV_RESULT kbuslib_Clamp_BitOffset_set(OV_INSTPTR_kbuslib_Clamp pobj, const OV_UINT value)
{
	OV_INSTPTR_ov_object potherClamp;
	
	if(Ov_CanCastTo(kbuslib_DigitalOUT, pobj))
	{
		if(value <= 7)
		{	
			if((Ov_CanCastTo(kbuslib_DigitalOUT, pobj)) && (value != pobj->v_BitOffset) && !(pobj->v_BitOffset))	/*	the first set is always allowed	*/
			{
				Ov_ForEachChild(ov_instantiation, pclass_kbuslib_DigitalOUT, potherClamp)
				{
					if(Ov_GetParent(ov_containment, pobj) == Ov_GetParent(ov_containment, potherClamp)
						&& Ov_StaticPtrCast(kbuslib_Clamp, potherClamp)->v_ByteAddress == pobj->v_ByteAddress
						&& Ov_StaticPtrCast(kbuslib_Clamp, potherClamp)->v_BitOffset == value)
					{
						ov_logfile_error("%s: this digital OUT is already served by %s", pobj->v_identifier, 
							Ov_StaticPtrCast(kbuslib_Clamp, potherClamp)->v_identifier);
						pobj->v_Error = FALSE;
						pobj->v_ErrorCode = KBUS_ERROR_OUTPUT_EXISTS;
						ov_string_setvalue(&pobj->v_ErrorString, KBUS_ERRORSTR_OUTPUT_EXISTS);
						return(OV_ERR_BADPARAM);
					}
				}
			}
			
			pobj->v_BitOffset = value;
			return(OV_ERR_OK);	
			
		}
		else
		{
			ov_logfile_error("%s: BitOffsets larger than 7 are not allowed", pobj->v_identifier);
			pobj->v_Error = FALSE;
			pobj->v_ErrorCode = KBUS_ERROR_BAD_PARAM;
			ov_string_setvalue(&pobj->v_ErrorString, KBUS_ERRORSTR_BAD_PARAM);
			return(OV_ERR_BADPARAM);
		}
	}
	else
	{
		if(value == 0)
			return OV_ERR_OK;
		else
		{
			ov_logfile_error("%s: BitOffset different from 0 can be set only for digital IOs", pobj->v_identifier);
			pobj->v_BitOffset = 0;
			pobj->v_Error = FALSE;
			pobj->v_ErrorCode = KBUS_ERROR_PARAM_CHANGE_NOT_ALLOWED;
			ov_string_setvalue(&pobj->v_ErrorString, KBUS_ERRORSTR_PARAM_CHANGE_NOT_ALLOWED);
			return(OV_ERR_NOACCESS);
		}
	}
	
	
}


OV_DLLFNCEXPORT OV_RESULT kbuslib_Clamp_ByteWidth_set(OV_INSTPTR_kbuslib_Clamp pobj, const OV_UINT value)
{
	OV_INSTPTR_ov_object potherClamp;
	OV_INSTPTR_ov_domain pparent;
	
	
	if(Ov_CanCastTo(kbuslib_SpecialOUT, pobj) || Ov_CanCastTo(kbuslib_SpecialIN, pobj))
	{
		if(value != pobj->v_ByteWidth)
		{
			pparent = Ov_GetParent(ov_containment, pobj);
		
			Ov_ForEachChild(ov_containment, pparent, potherClamp)
			{
				
				if((Ov_CanCastTo(kbuslib_SpecialOUT, pobj)
					&& (Ov_StaticPtrCast(ov_object, pobj) != potherClamp)
					&& (Ov_CanCastTo(kbuslib_AnalogOUT, potherClamp)
							|| Ov_CanCastTo(kbuslib_SpecialOUT, potherClamp))
					&& ((Ov_StaticPtrCast(kbuslib_Clamp, potherClamp)->v_ByteAddress >= pobj->v_ByteAddress 
							&& Ov_StaticPtrCast(kbuslib_Clamp, potherClamp)->v_ByteAddress 
								<= pobj->v_ByteAddress + value - 1)
						|| (Ov_StaticPtrCast(kbuslib_Clamp, potherClamp)->v_ByteAddress + 
								Ov_StaticPtrCast(kbuslib_Clamp, potherClamp)->v_ByteWidth - 1 >= pobj->v_ByteAddress
							&& Ov_StaticPtrCast(kbuslib_Clamp, potherClamp)->v_ByteAddress + 
								Ov_StaticPtrCast(kbuslib_Clamp, potherClamp)->v_ByteWidth - 1
									<= pobj->v_ByteAddress + value - 1))))
				
				{
					ov_logfile_error("%s: this space in the process image is already served by %s", pobj->v_identifier, 
						Ov_StaticPtrCast(kbuslib_Clamp, potherClamp)->v_identifier);
					pobj->v_Error = FALSE;
					pobj->v_ErrorCode = KBUS_ERROR_BAD_PARAM;
					ov_string_setvalue(&pobj->v_ErrorString, KBUS_ERRORSTR_BAD_PARAM);
					return(OV_ERR_BADPARAM);
				}
				
				
			}
		}
		
		pobj->v_ByteWidth = value;
		return(OV_ERR_OK);
	}
	else
	{	
		if((value == 2) && (Ov_CanCastTo(kbuslib_AnalogOUT, pobj) || Ov_CanCastTo(kbuslib_AnalogIN, pobj)))
		{
			pobj->v_ByteWidth = value;
			return OV_ERR_OK;
		}
		else
			if((value == 0) && (Ov_CanCastTo(kbuslib_DigitalOUT, pobj) || Ov_CanCastTo(kbuslib_DigitalIN, pobj)))
			{
				pobj->v_ByteWidth = value;
				return OV_ERR_OK;
			}
			else
			{
		
				ov_logfile_error("%s: This value is legitim for special IOs only", pobj->v_identifier);
				pobj->v_Error = FALSE;
				pobj->v_ErrorCode = KBUS_ERROR_PARAM_CHANGE_NOT_ALLOWED;
				ov_string_setvalue(&pobj->v_ErrorString, KBUS_ERRORSTR_PARAM_CHANGE_NOT_ALLOWED);
				return(OV_ERR_NOACCESS);
			}
	}
}


OV_DLLFNCEXPORT void kbuslib_Clamp_startup(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
    OV_INSTPTR_ov_class pBusMngr = NULL;
	OV_INSTPTR_kbuslib_BusManager pUsedManager = NULL;
	OV_INSTPTR_kbuslib_BusManager ptmpManager = NULL;
	OV_INSTPTR_ov_domain pParentContainer = NULL;
	OV_INSTPTR_kbuslib_Clamp pinst = Ov_StaticPtrCast(kbuslib_Clamp, pobj);

    /* do what the base class does first */
    fb_functionblock_startup(pobj);

    /* do what */
	
	/*Iterate over all possible Managers */
	Ov_ForEachChild(ov_inheritance, pclass_kbuslib_BusManager, pBusMngr)
	{
		ptmpManager = Ov_StaticPtrCast(kbuslib_BusManager, Ov_GetFirstChild(ov_instantiation, pBusMngr));	/*get the Manager used in the Database*/
		if(ptmpManager)
		{
			if(Ov_GetNextChild(ov_instantiation, ptmpManager))		/*if there is more than one Manager of the same type: Error*/
			{
				ov_logfile_error("%s: Error: There is more than one Bus Manager.", pinst->v_identifier);
				ov_string_setvalue(&pinst->v_ErrorString, KBUS_ERRORSTR_MANAGER);
				pinst->v_ErrorCode = KBUS_ERROR_MANAGER;
				pinst->v_Error = FALSE;
				return;
			}
			if(!pUsedManager)
			{
				pUsedManager = ptmpManager;
			}
			else						/*if a Manager is already found and a second Manager of a different type is found: Error*/
			{
				ov_logfile_error("%s: Error: There is more than one Bus Manager.", pinst->v_identifier);
				ov_string_setvalue(&pinst->v_ErrorString, KBUS_ERRORSTR_MANAGER);
				pinst->v_ErrorCode = KBUS_ERROR_MANAGER;
				pinst->v_Error = FALSE;
				return;
			}
		}
	}
	
	if(pUsedManager)
	{
		pParentContainer = Ov_GetParent(ov_containment, pinst);		/*if the clamp instance is contained in another instance, */
		if(pParentContainer != Ov_StaticPtrCast(ov_domain, pUsedManager))
		{
			if(pParentContainer)										/*this link is deleted and the clamp is moved into the Managers container*/
			{
				Ov_Unlink(ov_containment, pParentContainer, pinst);
			}

			if(Ov_Fail(Ov_Link(ov_containment, Ov_StaticPtrCast(ov_domain, pUsedManager), pinst)))
			{
				ov_logfile_error("%s: moving clamp into manager failed, probably the identifier already exists or there is not enough memory",
					pinst->v_identifier);
				ov_string_setvalue(&pinst->v_ErrorString, KBUS_ERRORSTR_IDENTIFIER_EXISTS);
				pinst->v_ErrorCode = KBUS_ERROR_IDENTIFIER_EXISTS;
				pinst->v_Error = FALSE;
			
				Ov_Link(ov_containment, pParentContainer, pinst);
				return;		
			}
		}
		
		
		
		

	}
	else
	{
		ov_logfile_error("%s: Error: No Bus Manager found. Automatic configuration not possible", pinst->v_identifier);
		ov_string_setvalue(&pinst->v_ErrorString, KBUS_ERRORSTR_NO_MANAGER);
		pinst->v_ErrorCode = KBUS_ERROR_NO_MANAGER;
		pinst->v_Error = FALSE;
		return;
	}
	
	ov_string_setvalue(&pinst->v_ErrorString, KBUS_ERRORSTR_NOERROR);
	pinst->v_ErrorCode = KBUS_ERROR_NOERROR;
	pinst->v_Error = TRUE;
	pinst->v_actimode = 1;
	pinst->v_iexreq = 1;

    return;
}

OV_DLLFNCEXPORT void kbuslib_Clamp_typemethod(
	OV_INSTPTR_fb_functionblock	pfb,
	OV_TIME						*pltc
) {
    /*    
    *   local variables
    */

	OV_INSTPTR_ov_domain pParentContainer = NULL;

	pParentContainer = Ov_GetParent(ov_containment, (Ov_StaticPtrCast(ov_object, pfb)));
	if(!Ov_CanCastTo(kbuslib_BusManager,pParentContainer))
		pfb->v_actimode = 0;
	
    return;
}

