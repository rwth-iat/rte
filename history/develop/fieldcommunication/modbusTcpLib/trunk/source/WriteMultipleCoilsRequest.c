
/******************************************************************************
 *
 *   FILE
 *   ----
 *   WriteMultipleCoilsRequest.c
 *
 *   History
 *   -------
 *   2015-04-29   File created
 *
 *******************************************************************************
 *
 *   This file is generated by the 'acplt_builder' command
 *
 ******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_modbusTcpLib
#define OV_COMPILE_LIBRARY_modbusTcpLib
#endif


#include "modbusTcpLib.h"
#include "libov/ov_macros.h"
#include "libov/ov_memstack.h"
#include "ksbase_helper.h"


OV_DLLFNCEXPORT OV_RESULT modbusTcpLib_WriteMultipleCoilsRequest_handleResponse(
		OV_INSTPTR_modbusTcpLib_Request	thisReq,
		OV_UINT		dataLength,
		OV_BYTE*	dataToHandle
) {
	/*
	 *   local variables
	 */

	return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT modbusTcpLib_WriteMultipleCoilsRequest_constructor(
		OV_INSTPTR_ov_object 	pobj
) {
	/*
	 *   local variables
	 */
	OV_INSTPTR_modbusTcpLib_WriteMultipleCoilsRequest pinst = Ov_StaticPtrCast(modbusTcpLib_WriteMultipleCoilsRequest, pobj);
	OV_RESULT    result;

	/* do what the base class does first */
	result = ov_object_constructor(pobj);
	if(Ov_Fail(result))
		return result;

	/* do what */
	pinst->v_requestID = modbusTcpLib_ModbusTcpManager_getReqId();
	pinst->v_requestType = 15;

	return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT modbusTcpLib_WriteMultipleCoilsRequest_addItem(
		OV_INSTPTR_modbusTcpLib_Request	pRequest,
		OV_INT	address,
		OV_BOOL data
) {

	return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT modbusTcpLib_WriteMultipleCoilsRequest_sendRequest(
		OV_INSTPTR_modbusTcpLib_Request thisReq
) {
	KS_DATAPACKET request;
	OV_INSTPTR_TCPbind_TCPChannel	pChannel = NULL;
	OV_VTBLPTR_TCPbind_TCPChannel	pVtblChannel	=	NULL;
	OV_INSTPTR_ov_domain			pDomain	=	NULL;
	OV_INSTPTR_modbusTcpLib_Slave	pSlave	=	NULL;
	OV_RESULT result;
	OV_INSTPTR_modbusTcpLib_IOChannel	pIOChannel = NULL;
	OV_UINT	iterator;

	pSlave = Ov_DynamicPtrCast(modbusTcpLib_Slave, pDomain->v_pouterobject);
	ov_memstack_lock();
	request.length = 7 + 6 + thisReq->v_requestedItems / 8;
	if(thisReq->v_requestedItems % 8){
		request.length++;
	}
	request.data = ov_memstack_alloc(request.length);
	if(!request.data){
		return OV_ERR_HEAPOUTOFMEMORY;
	}
	for(iterator = 0; iterator < request.length; iterator++){
		request.data[iterator] = 0;
	}
	request.readPT = request.data;
	request.writePT = request.data;
	/*	MBAP header	*/
	modbusTcpLib_Request_writeWord(thisReq->v_requestID, request.writePT);
	request.writePT += 2;
	modbusTcpLib_Request_writeWord(0, request.writePT);	//	protocol identification; has to be 0
	request.writePT += 2;
	modbusTcpLib_Request_writeWord(request.length - 6, request.writePT);	// number of bytes following
	request.writePT += 2;
	*request.writePT = (OV_BYTE)(thisReq->v_unitIdentifier & 0xFF);
	request.writePT += 1;
	/*	request	*/
	*request.writePT = (OV_BYTE)(thisReq->v_requestType & 0xFF);
	request.writePT += 1;
	modbusTcpLib_Request_writeWord(thisReq->v_requestStartAddr, request.writePT);
	request.writePT += 2;
	modbusTcpLib_Request_writeWord(thisReq->v_requestedItems, request.writePT);
	request.writePT += 2;
	*request.writePT = (OV_BYTE)((thisReq->v_requestedItems / 8) & 0xFF);
	request.writePT += 1;
	pIOChannel = Ov_GetChild(modbusTcpLib_requestToChannel, thisReq);
	if(!pIOChannel){
		return OV_ERR_GENERIC;
	}
	do{
		if(((pIOChannel->v_address - thisReq->v_requestStartAddr)) <= thisReq->v_requestedItems){
			if(Ov_CanCastTo(modbusTcpLib_DO, pIOChannel)){
				modbusTcpLib_Request_writeBit(Ov_StaticPtrCast(modbusTcpLib_DO, pIOChannel)->v_SP, (pIOChannel->v_address - thisReq->v_requestStartAddr), request.writePT);
			}
		} else {
			pIOChannel->v_error = TRUE;
			pIOChannel->v_errorCode = 0xFF;
			modbusTcpLib_IOChannel_setErrorText(pIOChannel);
			Ov_LinkPlaced(modbusTcpLib_errorChannels, pSlave, pIOChannel, OV_PMH_END);
		}
		pIOChannel = Ov_GetNextChild(modbusTcpLib_toNextChannel, pIOChannel);
	}while(pIOChannel);
	/*	get channel	*/
	pDomain = Ov_GetParent(ov_containment, thisReq);
	if(!pDomain){
		ov_memstack_unlock();
		return OV_ERR_BADPLACEMENT;
	}

	pChannel = &pSlave->p_channel;
	Ov_GetVTablePtr(TCPbind_TCPChannel, pVtblChannel, pChannel);
	if(!pVtblChannel){
		ov_memstack_unlock();
		return OV_ERR_GENERIC;
	}
	/*	copy data and send	*/
	result = ksbase_KSDATAPACKET_append(&(pChannel->v_outData), request.data, request.length);
	ov_memstack_unlock();
	if(Ov_OK(result)){
		pVtblChannel->m_SendData(Ov_PtrUpCast(ksbase_Channel, pChannel));
	}
	ov_time_gettime(&thisReq->v_validTill);
	thisReq->v_validTill.secs += pSlave->v_timeout;
	return result;
}

