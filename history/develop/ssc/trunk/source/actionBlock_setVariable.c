/*
*   The Framework was generated by the ACPLT/OV Builder.
*
*   Builder version: 1.0.4
*   Date of file generation:  15-Jul-2011 (13:34:12)
*/

#ifndef OV_COMPILE_LIBRARY_ssc
#define OV_COMPILE_LIBRARY_ssc
#endif

#include "ov.h"
#include "ssc.h"
#include "ssclib.h"
//#include "string.h"
#include "libov/ov_macros.h"
#include "libov/ov_path.h"


static void extractBehindSeperator(OV_STRING *string, OV_STRING *end,char sep)

{ 	OV_STRING old=NULL;
	OV_STRING secondhalf=NULL;
	//OV_STRING firsthalf=NULL;
//

	ov_string_setvalue(&old,*string);
	//ov_logfile_debug("string %s", old);
	OV_UINT len=ov_string_getlength(old);
	for(int i =0;i<len-1;i++){
			//ov_logfile_debug("string %c", old[len-i]);
		if(old[len-i]==sep){
			//firsthalf=ov_malloc((len-i));
			//secondhalf=ov_malloc((i+2));
			//memcpy(firsthalf,string,len-i);
			//memcpy(secondhalf,old[len-i],i+1);
			ov_string_setvalue(&secondhalf,&old[len-i+1]);
			old[len-i] = '\0';

//			ov_realloc(old,(len-i+2));
			//memcpy(old,&secondhalf[i+1],1);
			break;
		}
	}

//	OV_INSTPTR_Merkmalserver_Merkmal MerkmalTemp = NULL;
//	OV_INSTPTR_Merkmalserver_Auspraegungsaussage AusTemp = NULL;
//	OV_STRING Wert = NULL;
//	MerkmalTemp =
//			(OV_INSTPTR_Merkmalserver_Merkmal) Ov_SearchChild(ov_containment,Signal,name);
//	if (MerkmalTemp == NULL)
//		return Wert;
//	AusTemp =
//			(OV_INSTPTR_Merkmalserver_Auspraegungsaussage) Ov_SearchChild(ov_containment,MerkmalTemp,"Auspraegungsaussage");
//	if (AusTemp == NULL)
//		return Wert;
//	Wert = AusTemp->v_Wert;
//	 ov_logfile_debug("string %s", *string);
	ov_string_setvalue(string,old);
	ov_string_setvalue(&old, NULL);
	ov_string_setvalue(end,secondhalf);
	ov_string_setvalue(&secondhalf, NULL);
}

OV_DLLFNCEXPORT OV_INSTPTR_ov_object getrelativeobjectpointer(
    	const OV_STRING			startPoint,
    	const OV_STRING			pathname,
    	const OV_UINT			version
     ) {
    	/*
    	*	local variables
    	*/
   	OV_PATH		path;
    OV_ELEMENT	element;
    OV_PATH     startPointPath;
    ov_memstack_lock();
    ov_path_resolve(&startPointPath, NULL, startPoint, version);

   	/*
    	*	instructions
     	*/

     	if(Ov_Fail(ov_path_resolve(&path, &startPointPath, pathname, version))) {
    		/*
     		*	bad path
    		*/
     		ov_memstack_unlock();
   		return NULL;
     	}
   	element = path.elements[path.size-1];

     	 ov_memstack_unlock();
     	if(element.elemtype == OV_ET_OBJECT) {
   		return element.pobj;
     	}
    	/*
    	*	not an object path
    	*/
     	return NULL;
}
OV_DLLFNCEXPORT OV_RESULT ssc_setVariable_variable_set(
    OV_INSTPTR_ssc_setVariable          pinst,
    const OV_STRING  value
) {
    // check input
	if(ov_string_compare(value, "") == OV_STRCMP_EQUAL){
		//allow INITIAL_VALUE for loading an backup
		return OV_ERR_OK;
	}

	//fixme this problem has to be solved!
    if (ov_string_compare(value, NULL)==0)
    {
    	pinst->v_error=TRUE;
       	ov_string_setvalue(&pinst->v_errorDetail, "variable is not defined.");
       	return OV_ERR_OK;
    };

    pinst->v_error=FALSE;
    ov_string_setvalue(&pinst->v_errorDetail, NULL);

    return ov_string_setvalue(&pinst->v_variable,value);
}

OV_DLLFNCEXPORT OV_RESULT ssc_setVariable_value_set(
    OV_INSTPTR_ssc_setVariable          pobj,
    const OV_ANY*  value
) {
    return ov_variable_setanyvalue(&pobj->v_value, value);
}

OV_DLLFNCEXPORT void ssc_setVariable_typemethod(
	OV_INSTPTR_fb_functionblock	pfb,
	OV_TIME						*pltc
) {
    // local variables
    OV_INSTPTR_ssc_setVariable pinst = Ov_StaticPtrCast(ssc_setVariable, pfb);
    OV_INSTPTR_ssc_step  pStep= Ov_DynamicPtrCast(ssc_step, Ov_GetParent(ov_containment, pinst));
    //OV_INSTPTR_ssc_sscHeader  pSSC= Ov_DynamicPtrCast(ssc_sscHeader, Ov_GetParent(ov_containment, pStep));
    OV_RESULT    result = OV_ERR_OK;
    OV_UINT stringCount;
    OV_STRING pathToVariable=NULL;
    OV_STRING *pathToObject;
    OV_STRING temp =NULL;
    OV_STRING temp2=NULL;
    OV_STRING temp3=NULL;
    OV_INSTPTR_ov_object pObj = NULL;
    OV_ELEMENT element;
    OV_ELEMENT varElement;
    OV_VTBLPTR_ov_object pVtblObj = NULL;


    // init variables
    pinst->v_cyctime.secs = 0;
    pinst->v_cyctime.usecs = 0;
    pinst->v_iexreq = TRUE;
    pinst->v_error=FALSE;

    ov_string_setvalue(&pinst->v_errorDetail, NULL);

    // check location
    if ( pStep==NULL )
	{
    	pinst->v_error=TRUE;
		ov_logfile_error("ssc_actionBlock_constructor: action block must be encapsulated in a step.");
		return;
	}


    // check input
    if (ov_string_compare(pinst->v_variable, NULL)==0)
    {
    	pinst->v_error=TRUE;
       	ov_string_setvalue(&pinst->v_errorDetail, "variable is not defined.");
    };


    // set variable
    //result= fb_functionchart_getvariable(Ov_PtrUpCast(fb_functionchart, pSSC), pinst->v_variable, &pinst->v_value);
    //result= fb_functionchart_setvariable(Ov_PtrUpCast(fb_functionchart, pSSC), pinst->v_variable, &pinst->v_value);


// Extension to set any Port at any Variable
    //split the input at dot
   // pathToVariable =  ov_string_split(pinst->v_variable,".", &stringCount);
    ov_string_setvalue(&pathToVariable,pinst->v_variable);

    extractBehindSeperator(&pathToVariable,&temp2,'.');

   // ov_logfile_debug("path to variable %s", pathToVariable);
// for(int i=1;i<stringCount-1;i++)
// {
//	 ov_string_append( &(pathToVariable[0]),".");
//	 ov_string_append( &(pathToVariable[0]),pathToVariable[i]);
// }

   if((pinst->v_variable)[0]!='/'){
	   ov_memstack_lock();
	   ov_string_setvalue(&temp,ov_path_getcanonicalpath(Ov_DynamicPtrCast(ov_object,pinst), 2));
	   ov_memstack_unlock();

	  // ov_string_append(&temp,"/");




	 pathToObject=ov_string_split(pathToVariable,"/",&stringCount);

	   //result =ov_string_append(&temp,pathToVariable);

	  // ov_logfile_debug("result %s", ov_result_getresulttext(result));
	   //ov_logfile_debug("path %s", temp);
	   pObj = getrelativeobjectpointer(temp,pathToVariable ,2);
	//   ov_logfile_debug("path %s", pObj);

   }else{
	   pObj = ov_path_getobjectpointer(pathToVariable,2);
   }
   ov_string_setvalue(&pathToVariable,temp2);

    //pObj = ov_path_getobjectpointer(pathToVariable[0],2);

    if(pObj != NULL && pathToVariable != NULL)
    {
    	if (Ov_CanCastTo(fb_functionchart,pObj))
    	{
    		//set variable in a functionchart

    		result = fb_functionchart_setport((OV_INSTPTR_fb_functionchart)pObj, pathToVariable, &(pinst->v_value));
    	}
    	else
    	{
    		//set variable in a functionblock
			varElement.elemtype = OV_ET_NONE;
			element.elemtype = OV_ET_OBJECT;
			element.pobj = pObj;
			//iterate over all ports of the object to find the destination port for the set operation
			ov_element_getnextpart(&element, &varElement, OV_ET_VARIABLE);

			while(varElement.elemtype != OV_ET_NONE)
			{
				if(varElement.elemunion.pvar)
				{
					if(ov_string_compare(varElement.elemunion.pvar->v_identifier, pathToVariable) == OV_STRCMP_EQUAL)	/*	variable name matches	*/
					{
						//port found, use the setter to write the value
						Ov_GetVTablePtr(ov_object, pVtblObj, pObj);
						result = pVtblObj->m_setvar(varElement.pobj, &varElement, &(pinst->v_value));

					}
				}
				ov_element_getnextpart(&element, &varElement, OV_ET_VARIABLE);
			}
    	}
    }
    else
    {
    	pinst->v_error = TRUE;
    	ov_string_setvalue(&pinst->v_errorDetail, "path not found");
    }

    //result = fb_functionchart_setport( Ov_DynamicPtrCast(fb_functionchart, Ov_GetParent(ov_containment, pSSC)), pinst->v_variable, &pinst->v_value);

    if(Ov_Fail(result))
    {
    	pinst->v_error=TRUE;
    	ov_string_setvalue(&pinst->v_errorDetail, "bad parameter");

    }

/*
    		OV_INSTPTR_fb_functionchart pfc,
    		 const OV_STRING varname,
    		 OV_ANY *pvarcurrprops)
*/
    ov_string_setvalue(&temp,NULL);
    return;
}

OV_DLLFNCEXPORT OV_RESULT ssc_setVariable_setActionName(
             OV_INSTPTR_ssc_actionBlock          pinst,
             const OV_STRING  value
) {
	return ov_string_setvalue(&pinst->v_actionName,value);
}

OV_DLLFNCEXPORT OV_ACCESS ssc_setVariable_getaccess(
	OV_INSTPTR_ov_object	pobj,
	const OV_ELEMENT		*pelem,
	const OV_TICKET			*pticket
) {
	/*
	*   local variables
	*/
	OV_INSTPTR_ssc_step pStep = Ov_DynamicPtrCast(ssc_step, Ov_GetParent(ov_containment, pobj));
	OV_INSTPTR_ssc_sscHeader activeHeader= Ov_DynamicPtrCast(ssc_sscHeader, Ov_GetParent(ov_containment, pStep));
	OV_ACCESS access_code = fb_functionblock_getaccess(pobj, pelem, pticket);

	/*
	*	switch based on the element's type
	*/
	switch(pelem->elemtype) {
		case OV_ET_OBJECT:
			if(!activeHeader){
				//skip handling
			}else if(	activeHeader->v_workingState == WOST_INIT ||
						activeHeader->v_workingState == WOST_STOP ||
						activeHeader->v_workingState == WOST_TERMINATE)
			{
				//allow deletion
				access_code = (access_code | OV_AC_DELETEABLE);
			}else{
				//disallow deletion
				access_code = (access_code &~ OV_AC_DELETEABLE);
			}
			break;
		default:
			break;
	}
	return access_code;
}
