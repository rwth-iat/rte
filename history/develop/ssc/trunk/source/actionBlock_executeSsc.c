/*
*   The Framework was generated by the ACPLT/OV Builder.
*
*   Builder version: 1.0.4
*   Date of file generation:  15-Jul-2011 (13:34:12)
*/

#ifndef OV_COMPILE_LIBRARY_ssc
#define OV_COMPILE_LIBRARY_ssc
#endif


#include "ssc.h"
#include "ssclib.h"

OV_DLLFNCEXPORT void ssc_executeSsc_typemethod(
	OV_INSTPTR_fb_functionblock	pfb,
	OV_TIME						*pltc
) {
    /*
    *   local variables
    */

	OV_INSTPTR_ssc_executeSsc pinst = Ov_StaticPtrCast(ssc_executeSsc, pfb);

    OV_INSTPTR_ssc_step  		pStep= Ov_DynamicPtrCast(ssc_step, Ov_GetParent(ov_containment, pinst));
    OV_INSTPTR_ssc_sscHeader  	pSSC= Ov_DynamicPtrCast(ssc_sscHeader, Ov_GetParent(ov_containment, pStep));
    OV_INSTPTR_ssc_sscHeader  	pSscAction= Ov_DynamicPtrCast(ssc_sscHeader, Ov_GetParent(ssc_actionBlocks, pinst));
    OV_RESULT    			 result;

    // init parameters
    pinst->v_cyctime.secs = 0;
    pinst->v_cyctime.usecs = 0;
    pinst->v_iexreq = TRUE;
    pinst->v_error=FALSE;
    ov_string_setvalue(&pinst->v_errorDetail, NULL);

    // check location
    if (pSSC==NULL)
    {
      	pinst->v_error=TRUE;
      	ov_string_setvalue(&pinst->v_errorDetail, "wrong placement");
    	ov_logfile_error("ssc_executeSsc_typemethod: action block must be encapsulated in a step.");
       	return;
    }

    // check action
    // do what the base class do
    result=Ov_Call0 (ssc_executeFb, Ov_PtrUpCast(ssc_executeFb, pinst), checkAction);
    if(Ov_Fail(result)) return;

    // send command
	pSscAction->v_EN = pinst->v_enableSsc;

	// execute action
	Ov_Call1 (fb_task, Ov_PtrUpCast(fb_task, pSscAction), execute, pltc);


	// broadcase, if subSSC terminated
	if (pSscAction->v_terminated)
	{
		pStep->v_subSscTerminated=TRUE;
	} else {
		pStep->v_subSscTerminated=FALSE;
	}

	/*
	if (pSscAction != NULL)
	{
		// if subSSC terminates, then activate trans-task, else not
		pTask=&pStep->p_trans;
		if (pSscAction->v_workingState == WOST_STOP)
		{
			pTask->v_actimode=1;
		} else {
			pTask->v_actimode=0;
		}


	}
	*/

	return;
}

OV_DLLFNCEXPORT void ssc_executeSsc_destructor(
		OV_INSTPTR_ov_object pobj
) {
	OV_INSTPTR_ssc_executeSsc pinst = Ov_StaticPtrCast(ssc_executeSsc, pobj);
	OV_INSTPTR_ssc_step  pStep= Ov_DynamicPtrCast(ssc_step, Ov_GetParent(ov_containment, pinst));
	OV_INSTPTR_ssc_executeSsc pExecuteSsc = NULL;

	if (pStep != NULL)
	{
		Ov_Unlink(ov_containment, pStep, pinst);
		pStep->v_hasSubSsc=FALSE;
	}

	Ov_ForEachChildEx(ov_containment, pStep, pExecuteSsc, ssc_executeSsc)
	{
		if (pExecuteSsc->v_actionQualifier != ACT_EXIT)
			pStep->v_hasSubSsc=TRUE;
	}

    /* do what the base class does */
    ov_object_destructor(pobj);
}

OV_DLLFNCEXPORT OV_ACCESS ssc_executeSsc_getaccess(
	OV_INSTPTR_ov_object	pobj,
	const OV_ELEMENT		*pelem,
	const OV_TICKET			*pticket
) {
	/*
	*   local variables
	*/
	OV_INSTPTR_ssc_step pStep = Ov_DynamicPtrCast(ssc_step, Ov_GetParent(ov_containment, pobj));
	OV_INSTPTR_ssc_sscHeader activeHeader= Ov_DynamicPtrCast(ssc_sscHeader, Ov_GetParent(ov_containment, pStep));
	OV_ACCESS access_code = fb_functionblock_getaccess(pobj, pelem, pticket);

	/*
	*	switch based on the element's type
	*/
	switch(pelem->elemtype) {
		case OV_ET_OBJECT:
			if(!activeHeader){
				//skip handling
			}else if(	activeHeader->v_workingState == WOST_INIT ||
						activeHeader->v_workingState == WOST_STOP ||
						activeHeader->v_workingState == WOST_TERMINATE)
			{
				//allow deletion
				access_code = (access_code | OV_AC_DELETEABLE);
			}else{
				//disallow deletion
				access_code = (access_code &~ OV_AC_DELETEABLE);
			}
			break;
		default:
			break;
	}
	return access_code;
}
