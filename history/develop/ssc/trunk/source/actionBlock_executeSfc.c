/*
*   The Framework was generated by the ACPLT/OV Builder.
*
*   Builder version: 1.0.4
*   Date of file generation:  15-Jul-2011 (13:34:12)
*/

#ifndef OV_COMPILE_LIBRARY_sfc
#define OV_COMPILE_LIBRARY_sfc
#endif


#include "sfc.h"
#include "sfclib.h"

OV_DLLFNCEXPORT OV_RESULT sfc_executeSfc_actionName_set(
    OV_INSTPTR_sfc_executeSfc          pinst,
    const OV_STRING  value
) {
    //find action

	//return, if not defined

	//find current action

	// if not exists, create association

	// if different, unlink, and link to new action

	return ov_string_setvalue(&pinst->v_actionName,value);
}


OV_DLLFNCEXPORT void sfc_executeSfc_typemethod(
	OV_INSTPTR_fb_functionblock	pfb,
	OV_TIME						*pltc
) {
    /*
    *   local variables
    */

	OV_INSTPTR_sfc_executeSfc pinst = Ov_StaticPtrCast(sfc_executeSfc, pfb);

    OV_INSTPTR_sfc_step  		pStep= Ov_DynamicPtrCast(sfc_step, Ov_GetParent(ov_containment, pinst));
    OV_INSTPTR_sfc_sfcHeader  	pSFC= Ov_DynamicPtrCast(sfc_sfcHeader, Ov_GetParent(ov_containment, pStep));
    OV_INSTPTR_sfc_sfcHeader  	pSfcAction= Ov_DynamicPtrCast(sfc_sfcHeader, Ov_GetParent(sfc_actionBlocks, pinst));
    OV_RESULT    			 result;

    // init parameters
    pinst->v_cyctime.secs = 0;
    pinst->v_cyctime.usecs = 0;
    pinst->v_iexreq = 1;
    pinst->v_error=0;
    ov_string_setvalue(&pinst->v_errorDetail, NULL);

    // check location
    if (pSFC==NULL)
    {
      	pinst->v_error=TRUE;
      	ov_string_setvalue(&pinst->v_errorDetail, "wrong placement");
    	ov_logfile_error("sfc_executeSfc_typemethod: action block must be encapsulated in a step.");
       	return;
    }

    // check action
    // do what the base class do
    result=Ov_Call0 (sfc_executeFb, Ov_PtrUpCast(sfc_executeFb, pinst), checkAction);
    if(Ov_Fail(result)) return;

    // send command
	pSfcAction->v_EN = pinst->v_enableSfc;

	// execute action
	Ov_Call1 (fb_task, Ov_PtrUpCast(fb_task, pSfcAction), execute, pltc);


	// broadcase, if subSFC terminated
	if (pSfcAction->v_terminated)
	{
		pStep->v_subSfcTerminated=TRUE;
	} else {
		pStep->v_subSfcTerminated=FALSE;
	}

	/*
	if (pSfcAction != NULL)
	{
		// if subSFC terminates, then activate trans-task, else not
		pTask=&pStep->p_trans;
		if (pSfcAction->v_workingState == WOST_STOP)
		{
			pTask->v_actimode=1;
		} else {
			pTask->v_actimode=0;
		}


	}
	*/

	return;
}

OV_DLLFNCEXPORT void sfc_executeSfc_destructor(
		OV_INSTPTR_ov_object pobj
) {
	OV_INSTPTR_sfc_executeSfc pinst = Ov_StaticPtrCast(sfc_executeSfc, pobj);
	OV_INSTPTR_sfc_step  pStep= Ov_DynamicPtrCast(sfc_step, Ov_GetParent(ov_containment, pinst));
	OV_INSTPTR_sfc_executeSfc pExecuteSfc = NULL;

	if (pStep != NULL)
	{
		Ov_Unlink(ov_containment, pStep, pinst);
		pStep->v_hasSubSfc=FALSE;
	}

	Ov_ForEachChildEx(ov_containment, pStep, pExecuteSfc, sfc_executeSfc)
	{
		if (pExecuteSfc->v_actionQualifier != ACT_EXIT)
			pStep->v_hasSubSfc=TRUE;
	}

    /* do what the base class does */
    ov_object_destructor(pobj);
}



















