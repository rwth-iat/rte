
/******************************************************************************
*
*   FILE
*   ----
*   controlchart.c
*
*   History
*   -------
*   2015-02-18   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_ssc
#define OV_COMPILE_LIBRARY_ssc
#endif


#include "ssclib.h"
#include "fb_namedef.h"
#include "libov/ov_element.h"

#define CC_OCCUPANCY_ORDEROCCUPY "OCCUPY"
#define CC_OCCUPANCY_ORDERFREE "FREE"
#define CC_OCCUPY_VARIABLENAME "occupiedBy"
#define CC_SENDERID_VARIABLENAME "senderID"


//fixme move to typemethod, call this typemethod even in SequentialControlChart

/**
 *	generic syntax:
 *	-	"senderID;order;parameter"
 *
 *	for example:
 *	-	"senderID;OCCUPY;"
 *	-	"senderID;FREE;"
 *	-	"senderID;DOMAGIC;X=1,Y=17"
 *	-	"senderID;;X=1,Y=17"
 */
OV_DLLFNCEXPORT OV_RESULT ssc_controlchart_CMD_set(
		OV_INSTPTR_ssc_controlchart          this,
		const OV_STRING  value
)	{
	OV_STRING	*commandparts = NULL;
	OV_INT		idOfOccupancy = -1;
	OV_INSTPTR_fb_port pvar = NULL;
	OV_INSTPTR_fb_object pFbObject = NULL;
	OV_INSTPTR_fb_functionblock pOccupystatusHolder = NULL;
	OV_ELEMENT elemOccupyFb, elemOccupyVar;
	OV_VTBLPTR_ov_object pVtblObj = NULL;
	OV_STRING strCurrentOccupier = NULL;

	OV_STRING *keyvaluelist = NULL;
	OV_STRING *keyvalue = NULL;
	OV_UINT    len = 0;
	OV_UINT    keyvaluelen = 0;
	OV_UINT    iterator = 0;
	OV_ANY anyvar;
	OV_ANY orderVar;
	OV_RESULT result = OV_ERR_OK;

	anyvar.value.vartype = OV_VT_VOID;
	orderVar.value.vartype = OV_VT_STRING;
	orderVar.value.valueunion.val_string = NULL;

	if(this->v_ORDEREXECUTOR.veclen != this->v_ORDERLIST.veclen){
		//this controlchart is wrong configured
		return OV_ERR_GENERIC;
	}

	if(ov_string_compare(value, NULL) == OV_STRCMP_EQUAL){
		//fbds have an empty value...
		return OV_ERR_OK;
	}
	/*********************************************************************************************************
	 * check for occupy status
	 * idOfOccupancy == -1 => no occupy check needed
	 *********************************************************************************************************/
	for(iterator = 0;iterator < this->v_ORDERLIST.veclen;iterator++){
		if(ov_string_compare(this->v_ORDERLIST.value[iterator], CC_OCCUPANCY_ORDEROCCUPY) == OV_STRCMP_EQUAL){
			//we are a full featured controlchart with an OCCUPY state
			idOfOccupancy = iterator; // Guaranteed != -1
			break;
		}
	}

	if(idOfOccupancy > 0){
		//find functionblock which handles the occupy status
		Ov_ForEachChildEx(fb_variables, this, pvar, fb_port){
			if(ov_string_compare(this->v_ORDEREXECUTOR.value[iterator], pvar->v_identifier) == OV_STRCMP_EQUAL){
				break;
			}
		}
		pFbObject = fb_connection_getFirstConnectedObject(Ov_PtrUpCast(fb_object, pvar), TRUE, NULL);
		pOccupystatusHolder = Ov_DynamicPtrCast(fb_functionblock, pFbObject);
		if(pOccupystatusHolder != NULL){
			elemOccupyVar.elemtype = OV_ET_NONE;
			elemOccupyFb.elemtype = OV_ET_OBJECT;
			elemOccupyFb.pobj =  Ov_PtrUpCast(ov_object, pOccupystatusHolder);
			ov_element_searchpart(&elemOccupyFb, &elemOccupyVar, OV_ET_VARIABLE, CC_OCCUPY_VARIABLENAME);
			if(elemOccupyVar.elemtype == OV_ET_VARIABLE) {
				Ov_GetVTablePtr(ov_object, pVtblObj, pOccupystatusHolder);
				ov_memstack_lock();
				result = pVtblObj->m_getvar(elemOccupyVar.pobj, &elemOccupyVar, &anyvar);
				if(Ov_OK(result) && anyvar.value.vartype == OV_VT_STRING){
					ov_string_setvalue(&strCurrentOccupier, anyvar.value.valueunion.val_string);
				}else{
					//there is a variable with the right name, but it is not a string
					idOfOccupancy = -1;
				}
				ov_memstack_unlock();
			}else{
				//the functionblock has no variable with a correct name
				idOfOccupancy = -1;
			}
		}else{
			//did not found the functionblock or it was from a wrong class
			idOfOccupancy = -1;
		}
	}

	/*********************************************************************************************************
	 * parse command and check if we are allowed to do something
	 *********************************************************************************************************/
	commandparts = ov_string_split(value,";",&len);
	if(len != 3){
		ov_string_freelist(commandparts);
		return OV_ERR_BADPARAM;
	}

	if(idOfOccupancy != -1){
		//we have to check the occupancy
		if(ov_string_compare(commandparts[0], strCurrentOccupier) != OV_STRCMP_EQUAL){
			//we are not the current occupier
			if(ov_string_compare(strCurrentOccupier, NULL) == OV_STRCMP_EQUAL){
				//current Occupier is not set
				if(ov_string_compare(CC_OCCUPANCY_ORDEROCCUPY, commandparts[1]) == OV_STRCMP_EQUAL){
					//we want to occupy this controlchart, fine. Go for it.
				}else{
					//every other command should be not allowed
					ov_string_freelist(commandparts);
					ov_string_setvalue(&strCurrentOccupier, NULL);
					return OV_ERR_NOACCESS;
				}
			}else{
				//current Occupier is set different to us, nothing is allowed
				ov_string_freelist(commandparts);
				ov_string_setvalue(&strCurrentOccupier, NULL);
				return OV_ERR_NOACCESS;
			}
		}else{
			//we are the current occupier. All commands are allowed (also free)
		}
	}
	ov_string_setvalue(&strCurrentOccupier, NULL);

	/*********************************************************************************************************
	 * save the senderID
	 *********************************************************************************************************/
	ov_string_setvalue(&orderVar.value.valueunion.val_string, commandparts[0]);
	// this is optional, so no check on return value)
	ssc_setNamedVariable(Ov_PtrUpCast(ov_object, this), CC_SENDERID_VARIABLENAME, &orderVar);
	ov_string_setvalue(&orderVar.value.valueunion.val_string, NULL);

	/*********************************************************************************************************
	 * set order if set
	 *********************************************************************************************************/
	if(ov_string_compare(commandparts[1], NULL) != OV_STRCMP_EQUAL){
		//we have to find the id first
		for(iterator = 0 ; iterator < this->v_ORDERLIST.veclen ; iterator++){
			if(ov_string_compare(this->v_ORDERLIST.value[iterator], commandparts[1]) == OV_STRCMP_EQUAL){
				//found it
				ov_string_setvalue(&orderVar.value.valueunion.val_string, commandparts[1]);
				//we want to have the execution of the order optional! If this fails, we parse the params nevertheless
				ssc_setNamedVariable(Ov_PtrUpCast(ov_object, this), this->v_ORDEREXECUTOR.value[iterator], &orderVar);
				ov_string_setvalue(&orderVar.value.valueunion.val_string, NULL);
				if(		ov_string_compare(commandparts[1], CC_OCCUPANCY_ORDEROCCUPY) != OV_STRCMP_EQUAL
					||	ov_string_compare(commandparts[1], CC_OCCUPANCY_ORDERFREE) != OV_STRCMP_EQUAL){
					//after occupy and free no params are allowed
					ov_string_freelist(commandparts);
					return OV_ERR_OK;
				}
				break;// break the orderlist iterator
			}
		}
	}

	/*********************************************************************************************************
	 * handle params
	 *********************************************************************************************************/
	keyvaluelist = ov_string_split(commandparts[2], ",", &keyvaluelen);
	orderVar.value.vartype = OV_VT_STRING;
	for(iterator = 0;iterator < keyvaluelen;iterator++){
		keyvalue = ov_string_split(keyvaluelist[iterator], "=", &len);
		if(len != 2){
			//did not found exactly one "=", try next
			continue;
		}
		orderVar.value.valueunion.val_string = keyvalue[1];	//in heap mem
		//we want to skip an unsuccessful set, so no result check
		ssc_setNamedVariable(Ov_PtrUpCast(ov_object, this), keyvalue[0], &orderVar);
	}

	ov_string_freelist(commandparts);
	ov_string_freelist(keyvaluelist);
	ov_string_freelist(keyvalue);

	return OV_ERR_OK;
}

