
/******************************************************************************
*
*   FILE
*   ----
*   transition.c
*
*   History
*   -------
*   2011-05-27   File created
*
*******************************************************************************
*
*   This file is generated by the 'fb_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_ssc
#define OV_COMPILE_LIBRARY_ssc
#endif

#ifdef ssc_ERROR
#define ssc_TRANS_ERROR
#endif


#include "ssclib.h"

OV_DLLFNCEXPORT OV_RESULT ssc_transition_constructor(
		OV_INSTPTR_ov_object 	pobj
) {
	/*
	 *   local variables
	 */
	OV_INSTPTR_ssc_transition pinst = Ov_StaticPtrCast(ssc_transition, pobj);
	OV_INSTPTR_ssc_sscHeader pSSC = Ov_DynamicPtrCast(ssc_sscHeader, Ov_GetParent(ov_containment, pinst));

	OV_RESULT    result;

	/* do what the base class does first */
	result = fb_functionblock_constructor(pobj);
	if(Ov_Fail(result)){
		return result;
	}

	// check location
	if (pSSC == NULL){
		ov_logfile_error("ssc_transition_constructor: transition must be encapsulated in a sscHeader.");
		return OV_ERR_BADPLACEMENT;
	}

	return OV_ERR_OK;
}


OV_DLLFNCEXPORT void ssc_transition_typemethod(
	OV_INSTPTR_fb_functionblock	pfb,
	OV_TIME						*pltc
) {
	/*
	 *   local variables
	 */
	OV_INSTPTR_ssc_transition 	pinst = Ov_StaticPtrCast(ssc_transition, pfb);

	OV_INSTPTR_ssc_step  		pPrevStep = Ov_GetParent(ssc_nextTransitions, pinst);
	OV_INSTPTR_ssc_step  		pNextStep = Ov_GetParent(ssc_previousTransitions, pinst);

	OV_INSTPTR_ssc_sscHeader	pSSC = Ov_StaticPtrCast(ssc_sscHeader, Ov_GetParent(ov_containment, pinst));

	// check location and links
	if ( !pSSC){
		pinst->v_error=TRUE;
		ov_string_setvalue(&pinst->v_errorDetail, "placed wrong");
		return;
	}else if ( !pPrevStep || !pNextStep ){
		pinst->v_error=TRUE;
		ov_string_setvalue(&pinst->v_errorDetail, "not connected to both steps");
		return;
	}
	pinst->v_error=FALSE;
	ov_string_setvalue(&pinst->v_errorDetail, NULL);




	return;
}

/**
 * disallow deletion in run state
 */
OV_DLLFNCEXPORT OV_ACCESS ssc_transition_getaccess(
	OV_INSTPTR_ov_object	pobj,
	const OV_ELEMENT		*pelem,
	const OV_TICKET			*pticket
) {
	/*
	*   local variables
	*/
	OV_INSTPTR_ssc_sscHeader activeHeader = Ov_DynamicPtrCast(ssc_sscHeader, Ov_GetParent(ov_containment, pobj));
	OV_ACCESS access_code = fb_functionblock_getaccess(pobj, pelem, pticket);

	/*
	*	switch based on the element's type
	*/
	switch(pelem->elemtype) {
		case OV_ET_OBJECT:
			if(!activeHeader){
				//skip handling
			}else if(	activeHeader->v_error == TRUE ||
						activeHeader->v_workingState == SSC_WOST_INIT ||
						activeHeader->v_workingState == SSC_WOST_STOP ||
						activeHeader->v_workingState == SSC_WOST_TERMINATE)
			{
				//allow deletion
				access_code = (access_code | OV_AC_DELETEABLE);
			}else{
				//disallow deletion
				access_code = (access_code &~ OV_AC_DELETEABLE);
			}
			break;
		default:
			break;
	}
	return access_code;
}
