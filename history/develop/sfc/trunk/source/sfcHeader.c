
/******************************************************************************
*
*   FILE
*   ----
*   sfcHeader.c
*
*   History
*   -------
*   2011-07-04   File created
*
*******************************************************************************
*
*   This file is generated by the 'fb_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_sfc
#define OV_COMPILE_LIBRARY_sfc
#endif


#include "sfc.h"
#include "sfclib.h"

OV_RESULT sfc_sfcHeader_checkLocation(
	OV_INSTPTR_sfc_sfcHeader	pSFC
) {
	OV_INSTPTR_fb_functionchart pSfcContainer = Ov_DynamicPtrCast(fb_functionchart, Ov_GetParent(ov_containment, pSFC));
	OV_INSTPTR_ov_domain pSfcContainerContainer = Ov_GetParent(ov_containment, Ov_GetParent(ov_containment, pSFC));

	//if ( pSfcContainer == NULL )
	if ( (pSfcContainer == NULL) && (pSfcContainerContainer != NULL) )
	{
	   	pSFC->v_error=TRUE;
	   	ov_string_setvalue(&pSFC->v_errorDetail, "sfc must be encapsulated in a functionchart.");
		ov_logfile_error("sfc_sfcHeader_constructor: sfc must be encapsulated in a functionchart.");
		return OV_ERR_BADPLACEMENT;
	}
	return OV_ERR_OK;
}


OV_DLLFNCEXPORT OV_RESULT sfc_sfcHeader_constructor(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
    OV_INSTPTR_sfc_sfcHeader pinst = Ov_StaticPtrCast(sfc_sfcHeader, pobj);
    //OV_INSTPTR_fb_functionchart pSfcContainer = Ov_DynamicPtrCast(fb_functionchart, Ov_GetParent(ov_containment, pinst));
    OV_INSTPTR_sfc_step pInitStep = NULL;
    OV_INSTPTR_sfc_step pEndStep = NULL;
    //OV_INSTPTR_fb_task pInitTaskParent = NULL;
    OV_RESULT    result;

    /* do what the base class does first */
    result = fb_functionblock_constructor(pobj);
    if(Ov_Fail(result))
         return result;

    /* do what */

    // check location
    result = sfc_sfcHeader_checkLocation (pinst);
    if(Ov_Fail(result)) return result;


    /*
    if (pSfcContainer == NULL)
    {
    	ov_logfile_error("sfc_sfcHeader_constructor: sfc must be encapsulated in a functionchart.");
		return OV_ERR_BADPLACEMENT;
	}
	*/


    // create INIT- & END-step
    result = Ov_CreateObject(sfc_step, pInitStep, pinst, "INIT");
    pInitStep->v_internalID=0;
    pInitStep->v_actimode=1;
    result = Ov_CreateObject(sfc_step, pEndStep, pinst, "END");
    pEndStep->v_internalID=999;

    //init variables
    pinst->v_workingState= WOST_INIT;

    return OV_ERR_OK;
}

OV_DLLFNCEXPORT void sfc_sfcHeader_typemethod(
		OV_INSTPTR_fb_functionblock	pfb,
		OV_TIME						*pltc
) {
    /*    
    *   local variables
    */
    OV_INSTPTR_sfc_sfcHeader pinst = Ov_StaticPtrCast(sfc_sfcHeader, pfb);
    //OV_INSTPTR_fb_functionchart pSfcContainer = Ov_DynamicPtrCast(fb_functionchart, Ov_GetParent(ov_containment, pinst));
    //OV_INSTPTR_sfc_step      pInitStep = NULL;
    OV_INSTPTR_sfc_step      pActiveStep = NULL;
    //OV_INSTPTR_fb_task       pTask = NULL;
    OV_INSTPTR_fb_task 		 intask = &pinst->p_intask;
    //OV_INSTPTR_fb_task 		 pActiveStepExit = NULL;
    // helper vaiables
    OV_RESULT    			 result;
    OV_BOOL	                 exitLoop;

    // init variables
    pinst->v_error=FALSE;
    ov_string_setvalue(&pinst->v_errorDetail, NULL);
    intask->v_actimode = 1;
    intask->v_cyctime.secs = 0;
    intask->v_cyctime.usecs = 0;

    // check location
    result = sfc_sfcHeader_checkLocation (pinst);
    if(Ov_Fail(result)) return;


    // find active step
    Ov_GetFirstChildEx(fb_tasklist, intask, pActiveStep, sfc_step);
    if (pActiveStep != NULL)
    {
    	pActiveStep->v_actimode=0;
   		ov_string_setvalue(&pinst->v_activeStep, pActiveStep->v_identifier);
    }

    /*################################
    * state machine: working state
    #################################*/
    do{
    	exitLoop=TRUE;
    	switch (pinst->v_workingState)
    	{
    	/* step 0 init */
    	case WOST_INIT:
    		switch (pinst->v_woStPhase)
    		{
    		case 1:
    			/* entry: */
    			if (pinst->v_woStQualifier == 1)
    			{

    				ov_string_setvalue(&pinst->v_woStText, "INIT");

    				// generic part
    				pinst->v_woStQualifier = 2;
    				//printf("init, entry\n");
    			}

    			/* do: */
    			//printf("init, do\n");
    			// reset sfc
    			result=Ov_Call0 (sfc_sfcHeader, pinst, resetSfc);
    			if(Ov_Fail(result)) return;

    			// generic part
    			pinst->v_woStPhase = 2;
    		break;
    		case 2:
    			/* transitions */
    			//printf("init, transitions\n");
    			// INIT to START
    			if (pinst->v_EN == SFCCMD_START) pinst->v_workingState= WOST_START;

    			/* exit */
    			if (pinst->v_workingState != WOST_INIT)
    			{

    				// generic part
    				pinst->v_woStQualifier = 1;
					//printf("init, exit\n");
				}

    			// generic part
    			pinst->v_woStPhase = 1;
    			exitLoop=FALSE;
    		break;
    		} // END switch woStPhase
    	break;
    	/* END step 0 init */

    	/* step 1 START */
        case WOST_START:
        	switch (pinst->v_woStPhase)
        	{
        	case 1:
        		/* entry: */
        		if (pinst->v_woStQualifier == 1)
        		{

       				ov_string_setvalue(&pinst->v_woStText, "START");

       				// generic part
       				pinst->v_woStQualifier = 2;
       				//printf("start, entry\n");
       			}

       			/* do: */
       			//printf("start, do\n");
       			// activate active step
       			if (pActiveStep != NULL)
       			{
       				pActiveStep->v_actimode=1;
       			}

       			// generic part
       			pinst->v_woStPhase = 2;
       		break;
       		case 2:
       			/* transitions */
       			//printf("start, transitions\n");

       			// START to BREAK
    			if (pinst->v_EN == SFCCMD_BREAK) pinst->v_workingState= WOST_BREAK;

    			// START to STOP
    			if (pinst->v_EN == SFCCMD_STOP) pinst->v_workingState= WOST_STOP;

       			/* exit */
       			if (pinst->v_workingState != WOST_START)
       			{

       				// generic part
       				pinst->v_woStQualifier = 1;
   					//printf("start, exit\n");
   				}

       			// generic part
               	pinst->v_woStPhase = 1;
               	exitLoop=FALSE;
       		break;
        	} // END switch woStPhase
        break;
        /* END step 1 START */

        /* step 2 BREAK */
        case WOST_BREAK:
        switch (pinst->v_woStPhase)
        {
           	case 1:
           		/* entry: */
           		if (pinst->v_woStQualifier == 1)
           		{
           			// activate active step
           			if (pActiveStep != NULL)
           			{
           				pActiveStep->v_actimode=1;
           			}

           			ov_string_setvalue(&pinst->v_woStText, "BREAK");

           			// generic part
           			pinst->v_woStQualifier = 2;
           			//printf("break, entry\n");
           		}

           		/* do: */
           		//printf("break, do\n");
           		// activate active step
           		if (pActiveStep != NULL)
           		{
           			pActiveStep->v_actimode=0;
           			pActiveStep->v_phase=1;
           			pActiveStep->v_X=FALSE;
           		}

           		// generic part
           		pinst->v_woStPhase = 2;
           		break;
           	case 2:
           		/* transitions */
           		//printf("break, transitions\n");

           		// BREAK to STOP
           		if (pinst->v_EN == SFCCMD_STOP) pinst->v_workingState= WOST_STOP;

           		// BREAK to START
           		if (pinst->v_EN == SFCCMD_START) pinst->v_workingState= WOST_START;

           		// generic part
           		if (pinst->v_workingState != WOST_BREAK) pinst->v_woStQualifier = 3;

           		/* exit */
           		if (pinst->v_woStQualifier == 3)
           		{
           			// generic part
           			pinst->v_woStQualifier = 1;
           			//printf("break, exit\n");
           		}

           	// generic part
           	pinst->v_woStPhase = 1;
           	exitLoop=FALSE;
           	break;
            } // END switch woStPhase
        break;
        /* END step 2 BREAK */

        /* step 3 STOP */
        case WOST_STOP:
        switch (pinst->v_woStPhase)
        {
           	case 1:
        	/* entry: */
        	if (pinst->v_woStQualifier == 1)
        	{
        		// execute exit-actions of the end step
        		if (pActiveStep == NULL)					// step specific
        		{
        			// TODO: ERROR
        			return;
        		}
      		    //Ov_Call1 (fb_task, Ov_PtrUpCast(fb_task, pActiveStep), execute, pltc);
        		//Frage: Warum funktionier hier der Aufruf von execute nicht?
        		//Ov_Call1 (sfc_step, pActiveStep, typemethod, pltc);
        		Ov_Call1 (fb_functionblock, pActiveStep, typemethod, pltc);


        		ov_string_setvalue(&pinst->v_woStText, "STOP");

        		// generic part
        		pinst->v_woStQualifier = 2;
        		//printf("stop, entry\n");
        	}

        	/* do: */
        	//printf("stop, do\n");
        	// reset sfc
        	result=Ov_Call0 (sfc_sfcHeader, pinst, resetSfc);
        	if(Ov_Fail(result)) return;

        	// generic part
        	pinst->v_woStPhase = 2;
        	break;
           	case 2:
        	/* transitions */
           	//printf("stop, transitions\n");

           	// STOP to START
        	if (pinst->v_EN == SFCCMD_START) pinst->v_workingState= WOST_START;

        	// generic part
           	if (pinst->v_workingState != WOST_STOP) pinst->v_woStQualifier = 3;

           	/* exit */
           	if (pinst->v_woStQualifier == 3)
           	{
           		// generic part
           		pinst->v_woStQualifier = 1;
       			//printf("stop, exit\n");
       		}

           	// generic part
           	pinst->v_woStPhase = 1;
           	exitLoop=FALSE;
           	break;
            } // END switch woStPhase
        break;
        /* END step 3 STOP */


    	}
    } while (!exitLoop);
    /* END: state machine: working state
    #################################*/



    /* Execute internal task */
    Ov_Call1 (fb_task, intask, execute, pltc);

    if (ov_string_compare(pinst->v_identifier, "sfc1") == 0)
    	printf("\n");
    return;
}

OV_DLLFNCEXPORT OV_RESULT sfc_sfcHeader_resetSfc(
	OV_INSTPTR_sfc_sfcHeader    pinst
) {
	OV_INSTPTR_sfc_step      pStep = NULL;
	OV_INSTPTR_sfc_step      pInitStep = NULL;
	OV_INSTPTR_fb_task 		 intask = &pinst->p_intask;
	OV_RESULT    			 result;
	OV_INSTPTR_fb_functionblock pFbAction=NULL;
	OV_INSTPTR_fb_task       pTask = NULL;
	OV_INSTPTR_sfc_sfcHeader pSfcAction = NULL;
    //OV_TIME *pTime;
    //ov_time_gettime(&pTime);

    //reset all steps; find and link INIT-step to intask
	  Ov_ForEachChildEx(ov_containment, pinst, pStep, sfc_step)
	  {
		  result=Ov_Call0(sfc_step, pStep, resetStep);

		  if(pStep->v_internalID == 0)
		  {
			  pInitStep=pStep;
		  }
	  }
	  if (pInitStep == NULL)
	  {
		  pinst->v_error=TRUE;
		  ov_string_setvalue(&pinst->v_errorDetail, "no INIT-step is defined");
		  return OV_ERR_BADPATH;
	  }
	  result=Ov_Link(fb_tasklist, intask,  pInitStep);

	  // reset all actions (FB, CFC or SFC) under .actions folder
	  Ov_ForEachChildEx(ov_containment, &pinst->p_actions, pFbAction, fb_functionblock)
	  {
		  // unlink from task parent
		  pTask = Ov_GetParent(fb_tasklist, pFbAction);
		  if (pTask != NULL)	Ov_Unlink(fb_tasklist, pTask, pFbAction);

		  // reset parameters
		  pFbAction->v_actimode=0;
		  pFbAction->v_cyctime.secs = 0;
		  pFbAction->v_cyctime.usecs = 0;
		  pFbAction->v_iexreq = TRUE;

		  // reset SFC action
		  pSfcAction=Ov_DynamicPtrCast(sfc_sfcHeader,pFbAction);
		  if (pSfcAction != NULL)
		  {
			  pSfcAction->v_actimode=1;
			  pSfcAction->v_EN=SFCCMD_STOP;
			  //Ov_Call1 (fb_task, Ov_PtrUpCast(fb_task, pSfcAction), execute, &pTime);
			  Ov_Call0 (sfc_sfcHeader, pSfcAction, resetSfc);
			  pSfcAction->v_actimode=0;
		  }
	  }

	  // TODO: reset all transition conditions under .transConds folder
	  Ov_ForEachChildEx(ov_containment, &pinst->p_transConds, pFbAction, fb_functionblock)
	  	  {
	  		  // unlink from task parent
	  		  OV_INSTPTR_fb_task pTask = Ov_GetParent(fb_tasklist, pFbAction);
	  		  if (pTask != NULL)	Ov_Unlink(fb_tasklist, pTask, pFbAction);

	  		  // reset parameters
	  		  pFbAction->v_actimode=0;
	  		  pFbAction->v_cyctime.secs = 0;
	  		  pFbAction->v_cyctime.usecs = 0;
	  		  pFbAction->v_iexreq = TRUE;
	  	  }
	  //printf("%s: reset all steps END\n", pinst->v_identifier);

	  return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT sfc_sfcHeader_checkPlausibility(
	OV_INSTPTR_sfc_sfcHeader          pobj
) {


    return OV_ERR_OK;
}


