/*
*   The Framework was generated by the ACPLT/OV Builder.
*
*   Builder version: 1.0.1
*   Date of file generation:  10-Apr-2002 (17:18:25)
*/

#ifndef OV_COMPILE_LIBRARY_dynov
#define OV_COMPILE_LIBRARY_dynov
#endif


#include "dynov.h"
#include "libov/ov_macros.h"


OV_DLLFNCEXPORT OV_BOOL dynov_dynoperation_check(
             OV_INSTPTR_ov_object          pobj
) {
	return FALSE;
}

OV_DLLFNCEXPORT void dynov_dynoperation_uncheck(
             OV_INSTPTR_ov_object          pobj
) {
}

OV_DLLFNCEXPORT OV_BOOL dynov_dynoperation_executeable_get(
             OV_INSTPTR_dynov_dynoperation          pobj
) {
	     return pobj->v_executeable;		
}

OV_DLLFNCEXPORT OV_RESULT dynov_dynoperation_executeable_set(
             OV_INSTPTR_dynov_dynoperation          pobj,
             const OV_BOOL           value
) {
             OV_VTBLPTR_dynov_dynoperation          pvtable;
             OV_INSTPTR_dynov_dynclass		    pclass;
             OV_INSTPTR_dynov_dynassociation		    passoc;

	     if ((value) && (!pobj->v_executeable)) {
		     Ov_GetVTablePtr(dynov_dynoperation, pvtable, pobj);
		     if (pvtable)
	             	pobj->v_executeable = pvtable->m_check(Ov_PtrUpCast(ov_object, pobj));
		     if (!pobj->v_executeable) return OV_ERR_OPDEFMISMATCH;
	     }
	     else if ((!value) && (pobj->v_executeable)) {
	             pclass = Ov_DynamicPtrCast(dynov_dynclass, Ov_GetParent(ov_containment, pobj));
	             if (pclass) if (pclass->v_isinstantiable) return OV_ERR_NOACCESS;
	             passoc = Ov_GetParent(dynov_assocaccess, pobj);
	             if (passoc) if (passoc->v_islinkable) return OV_ERR_NOACCESS;
	             passoc = Ov_GetParent(dynov_islinkfnc, pobj);
	             if (passoc) if (passoc->v_islinkable) return OV_ERR_NOACCESS;
	             passoc = Ov_GetParent(dynov_isunlinkfnc, pobj);
	             if (passoc) if (passoc->v_islinkable) return OV_ERR_NOACCESS;
	             pclass = Ov_DynamicPtrCast(dynov_dynclass, Ov_GetParent(ov_containment, Ov_GetParent(dynov_isgetaccessor, pobj)));
	             if (pclass) if (pclass->v_isinstantiable) return OV_ERR_NOACCESS;
	             pclass = Ov_DynamicPtrCast(dynov_dynclass, Ov_GetParent(ov_containment, Ov_GetParent(dynov_issetaccessor, pobj)));
	             if (pclass) if (pclass->v_isinstantiable) return OV_ERR_NOACCESS;

		     Ov_GetVTablePtr(dynov_dynoperation, pvtable, pobj);
		     if (pvtable) {
			pvtable->m_uncheck(Ov_PtrUpCast(ov_object, pobj));
			pobj->v_executeable = FALSE;
		     }
	     }

             return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_ACCESS dynov_dynoperation_getaccess(
	OV_INSTPTR_ov_object	pobj,
	const OV_ELEMENT		*pelem,
	const OV_TICKET			*pticket
) {
	OV_ACCESS			access;
        OV_INSTPTR_dynov_dynoperation          pdynop;

	pdynop = Ov_StaticPtrCast(dynov_dynoperation, pobj);
	switch(pelem->elemtype) {
		case OV_ET_VARIABLE:
			if (!ov_string_compare(pelem->elemunion.pvar->v_identifier, "executeable"))
				return OV_AC_READ | OV_AC_WRITE;
			return OV_AC_NONE;
		case OV_ET_CHILDLINK:
			if (pdynop->v_executeable) {
				access = OV_AC_READ;
			}
			else  {
				access = OV_AC_READ | OV_AC_WRITE;
			}
			if (pelem->elemunion.passoc == passoc_dynov_islinkfnc)
				return access;
			if (pelem->elemunion.passoc == passoc_dynov_isunlinkfnc)
				return access;
			if (pelem->elemunion.passoc == passoc_dynov_assocaccess)
				return access;
			if (pelem->elemunion.passoc == passoc_dynov_isgetaccessor)
				return access;
			if (pelem->elemunion.passoc == passoc_dynov_issetaccessor)
				return access;
			return OV_AC_NONE;
		case OV_ET_PARENTLINK:
			return OV_AC_NONE;
		case OV_ET_OPERATION:
			return OV_AC_NONE;
    	}
	if ((pdynop->v_executeable) || (pobj->v_pouterobject)) return OV_AC_READ;
	return OV_AC_READ | OV_AC_DELETEABLE | OV_AC_RENAMEABLE;
}
