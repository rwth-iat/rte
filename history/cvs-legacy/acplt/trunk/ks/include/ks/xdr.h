/* -*-plt-c++-*- */
/* xdr.h */
/* 
 *  Copyright (c) 1996 PLT, RWTH-Aachen, Germany. See file copy_plt.txt!
 *  Author: Martin Kneissl <martin@plt.rwth-aachen.de>
 *
 */

#ifndef KS_XDR_INCLUDED
#define KS_XDR_INCLUDED

#include <plt/debug.h>
// #include <plt/string.hpp>
extern "C" {
#include <rpc/xdr.h>
};


//////////////////////////////////////////////////////////////////////
// XDR streaming helper classes and macros
//////////////////////////////////////////////////////////////////////
//
// Intention:
// ==========
// - Objects should know best how to stream themselves.
// - Classes should construct objects directly from the stream
//   to avoid copying large data structures.
// - Constructors have to report failed deserialization via
//   a bool "return value" (== additional reference argument)
//   because exceptions are not generally available.
// - For those objects that are (de-)serialized by RPC there must
//   be extern "C" stubs that call C++ methods.
//
// Usage:
// ======
// Each XDR streamable class shoud derive from KsXdrAble and must define
// a1)   bool xdrEncode(XDR *) const;   // serialization
// a2)   bool xdrDecode(XDR *);         // deserialization
//
// b)    SomeClass::SomeClass(XDR *, bool & ok); // deserialize and construct
// c)    static SomeClass * SomeClass::xdrNew(XDR *); 
//          // factory method for b)
//
// a1) and a2) must be manually implemented
// b) can be implemented by executing KS_IMPL_XDRCTOR(SomeClass) if
//    SomeClass has a default constructor
// c) can be implemented by executing KS_IMPL_XDRNEW(SomeClass); 
// 
// Class KsXdrUnion is an abstract base class for classes with some
// known derivations representing a XDR union
// Each derived class has to 
// - define a a distinct "virtual constant" xdrTypeCode() const 
//   (the same value as the XDR union discriminator)
// - extend xdrEncode()
// - extend xdrDecode()
// 
// The abstract base class definition body can be generated by expanding
//    KS_DECL_XDRUNION(Base);
//
// The definition of a1) and c) (s.a.) can be generated by expanding
//    KS_BEGIN_IMPL_XDRUNION( base );
//    KS_XDR_MAP( CONST1, Derived1 );
//    KS_XDR_MAP( CONST2, Derived2 );
//     ...
//    KS_END_IMPL_XDRUNION;
//
// The constructor b) is not needed (Base is abstract)
// a2) works only in some cases because you can't change an
//     object's class
//////////////////////////////////////////////////////////////////////
// See tests/txdr2.cpp for an example
//////////////////////////////////////////////////////////////////////

class KsXdrAble 
{
public:
    virtual bool xdrEncode(XDR *) const = 0;  // serialize
    virtual bool xdrDecode(XDR *) = 0;        // deserialize
 // static KsXdrUnion * xdrNew(XDR *) = 0; // deserialization factory meth.
};

//////////////////////////////////////////////////////////////////////

class KsXdrUnion 
: public KsXdrAble 
{
public:
    virtual bool xdrEncode(XDR *) const = 0;
    virtual bool xdrDecode(XDR *) = 0;
//  static KsXdrUnion * xdrNew(XDR *) = 0;
    virtual enum_t xdrTypeCode() const = 0; // XDR union discriminator 
};

//////////////////////////////////////////////////////////////////////

#define KS_IMPL_XDR_C(classname)                  \
    extern "C" bool_t                             \
    xdr_##classname(XDR *xdrs, classname **pp)    \
    {                                             \
        PLT_PRECONDITION( xdrs && pp );           \
        switch(xdrs->x_op) {                      \
                                                  \
        case XDR_FREE:                            \
            if (!*pp) {                           \
                delete *pp;                       \
                *pp = 0;                          \
                return TRUE;                      \
            }                                     \
        case XDR_ENCODE:                          \
            if (! *pp) return FALSE;              \
            return (*pp)->xdrEncode(xdrs);        \
                                                  \
        case XDR_DECODE:                          \
            *pp = classname::xdrNew(xdrs);        \
            return *pp != 0;                      \
                                                  \
        default:                                  \
            return FALSE;                         \
        }                                         \
    }                                             \
    typedef void ks_dummy_typedef

//////////////////////////////////////////////////////////////////////

#define KS_DECL_XDRUNION(base)                                    \
    public:                                                       \
    virtual bool xdrEncode(XDR *) const;                          \
    virtual bool xdrDecode(XDR *);                                \
    static base * xdrNew(XDR *);                                  \
    virtual enum_t xdrTypeCode() const = 0 /*;  redeclaration */  

//////////////////////////////////////////////////////////////////////

#define KS_BEGIN_IMPL_XDRUNION(base)                               \
    bool base::xdrEncode(XDR * xdrs) const                         \
    {                                                              \
        PLT_PRECONDITION(xdrs->x_op == XDR_ENCODE);                \
        enum_t typecode = xdrTypeCode();                           \
        return xdr_enum(xdrs, &typecode);                          \
    }                                                              \
                                                                   \
/***************************************************/              \
                                                                   \
    bool base::xdrDecode(XDR * xdrs)                               \
    {                                                              \
        PLT_PRECONDITION(xdrs->x_op == XDR_DECODE);                \
        enum_t typecode;                                           \
        bool_t succ = xdr_enum(xdrs, &typecode);                   \
        return succ && typecode == xdrTypeCode();                  \
        /* typecode must match, cant change object's class! */     \
    }                                                              \
                                                                   \
/***************************************************/              \
                                                                   \
    base * base::xdrNew(XDR * xdrs)                                \
    {                                                              \
        PLT_PRECONDITION(xdrs->x_op == XDR_DECODE);                \
        base * p = 0;                                              \
        enum_t typecode;                                           \
            if (xdr_enum(xdrs, &typecode)) {                       \
            /* typecode successfully decoded */                    \
            switch(typecode) {                                     \

#define KS_XDR_MAP(constant,derived)                       \
            case constant:                                 \
                p = derived::xdrNew(xdrs);                 \
                break                                      \

#define KS_END_IMPL_XDRUNION                                       \
           default:                                               \
                /* unknown typecode */                             \
                /* p = 0;           */                             \
                    { }                                            \
            }                                                      \
        }                                                          \
        PLT_ASSERT(p->xdrTypeCode() == typecode);                  \
        return p;                                                  \
    }                                                              \
typedef void ks_dummy_typedef

//////////////////////////////////////////////////////////////////////

#define KS_IMPL_XDRNEW(classname)                          \
    classname * classname::xdrNew(XDR * xdrs)              \
    {                                                      \
        bool ok;                                           \
        classname * p = new classname(xdrs, ok);           \
        if ( !ok && p) {                                   \
            delete p;                                      \
            p = 0;                                         \
        }                                                  \
        return p;                                          \
    }                                                      \
typedef void ks_dummy_typedef

//////////////////////////////////////////////////////////////////////

// extern "C" bool_t xdr_PltString(XDR * xdrs, PltString **pp);

//////////////////////////////////////////////////////////////////////

#endif
