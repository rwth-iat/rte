/* -*-plt-c++-*- */
/* xdr.h */
/* 
 *  Copyright (c) 1996 PLT, RWTH-Aachen, Germany. See file copy_plt.txt!
 *  Author: Martin Kneissl <martin@plt.rwth-aachen.de>
 *
 */

#ifndef KS_XDR_INCLUDED
#define KS_XDR_INCLUDED

#include <plt/debug.h>
#include <plt/string.hpp>
extern "C" {
#include <rpc/xdr.h>
};


//////////////////////////////////////////////////////////////////////
// XDR streaming helper classes and macros
//////////////////////////////////////////////////////////////////////
//
// Intention:
// ==========
// - Objects should know best how to stream themselves.
// - Classes should construct objects directly from the stream
//   to avoid copying large data structures.
// - Constructors have to report failed deserialization via
//   a bool "return value" (== additional reference argument)
//   because exceptions are not generally available.
// - For those objects that are (de-)serialized by RPC there must
//   be extern "C" stubs that call C++ methods.
//
// Usage:
// ======
// Each XDR streamable class shoud derive from KsXdrAble and must define
// a)    bool xdrEncode(XDR *) const;   // serialization
// b)    SomeClass::SomeClass(XDR *, bool & ok); // deserialize and construct
// c)    static SomeClass * SomeClass::xdrDecode(XDR *); 
//          // factory method for b)
//
// a) and b) must be manually implemented
// c) can be implemented by executing KS_IMPL_XDRDECODE(SomeClass); 
// 
// Class KsXdrUnion is an abstract base class for classes with some
// known derivations representing a XDR union
// Each derived class has to define a 
// distinct "virtual constant" xdrTypeCode() const (the same value
// as the XDR union discriminator)
//
// The abstract base class definition body can be generated by expanding
//    KS_DECL_XDRUNION(Base);
//
// The definition of a) and c) (s.a.) can be generated by expanding
//    KS_BEGIN_IMPL_XDRUNION( base );
//    KS_XDR_MAP( CONST1, Derived1 );
//    KS_XDR_MAP( CONST2, Derived2 );
//     ...
//    KS_END_IMPL_XDRUNION;
//
// The constructor b) is not needed (Base is abstract)
//////////////////////////////////////////////////////////////////////
// See tests/txdr2.cpp for an example
//////////////////////////////////////////////////////////////////////

class KsXdrAble 
{
public:
    virtual bool xdrEncode(XDR *) const = 0;  // serialize
 // static KsXdrUnion * xdrDecode(XDR *) = 0; // deserialization factory meth.
};

//////////////////////////////////////////////////////////////////////

class KsXdrUnion 
: public KsXdrAble 
{
public:
    virtual bool xdrEncode(XDR *) const = 0;
//  static KsXdrUnion * xdrDecode(XDR *) = 0;
    virtual enum_t xdrTypeCode() const = 0; // XDR union discriminator 
};

//////////////////////////////////////////////////////////////////////

#define KS_IMPL_XDR_C(classname)                  \
    extern "C" bool_t                             \
    xdr_##classname(XDR *xdrs, classname **pp)    \
    {                                             \
        PLT_PRECONDITION( xdrs && pp );           \
        switch(xdrs->x_op) {                      \
                                                  \
        case XDR_FREE:                            \
            if (!*pp) {                           \
                delete *pp;                       \
                *pp = 0;                          \
                return TRUE;                      \
            }                                     \
        case XDR_ENCODE:                          \
            if (! *pp) return FALSE;              \
            return (*pp)->xdrEncode(xdrs);        \
                                                  \
        case XDR_DECODE:                          \
            *pp = classname::xdrDecode(xdrs);     \
            return *pp != 0;                      \
                                                  \
        default:                                  \
            return FALSE;                         \
        }                                         \
    }                                             \
    typedef void ks_dummy_typedef

//////////////////////////////////////////////////////////////////////

#define KS_DECL_XDRUNION(base)                                    \
    public:                                                       \
    virtual bool xdrEncode(XDR *) const;                          \
    static base * xdrDecode(XDR *);                               \
    virtual enum_t xdrTypeCode() const = 0 /*;  redeclaration */  

//////////////////////////////////////////////////////////////////////

#define KS_BEGIN_IMPL_XDRUNION(base)                               \
    bool base::xdrEncode(XDR * xdrs) const                         \
    {                                                              \
        PLT_PRECONDITION(xdrs->x_op == XDR_ENCODE);                \
        enum_t typecode = xdrTypeCode();                           \
        return xdr_enum(xdrs, &typecode);                          \
    }                                                              \
                                                                   \
/***************************************************/              \
                                                                   \
    base * base::xdrDecode(XDR * xdrs)                             \
    {                                                              \
        PLT_PRECONDITION(xdrs->x_op == XDR_DECODE);                \
        base * p = 0;                                              \
        enum_t typecode;                                           \
            if (xdr_enum(xdrs, &typecode)) {                       \
            /* typecode successfully decoded */                    \
            switch(typecode) {                                     \

#define KS_XDR_MAP(constant,derived)                       \
            case constant:                                 \
                p = derived::xdrDecode(xdrs);              \
                break                                      \

#define KS_END_IMPL_XDRUNION                                       \
            default:                                               \
                /* unknown typecode */                             \
                /* p = 0;           */                             \
                    { }                                            \
            }                                                      \
        }                                                          \
        PLT_ASSERT(p->xdrTypeCode() == typecode);                  \
        return p;                                                  \
    }                                                              \
typedef void ks_dummy_typedef

//////////////////////////////////////////////////////////////////////

#define KS_IMPL_XDRDECODE(classname)                       \
    classname * classname::xdrDecode(XDR * xdrs)           \
    {                                                      \
        bool ok;                                           \
        classname * p = new classname(xdrs, ok);           \
        if ( !ok && p) {                                   \
            delete p;                                      \
            p = 0;                                         \
        }                                                  \
        return p;                                          \
    }                                                      \
typedef void ks_dummy_typedef

//////////////////////////////////////////////////////////////////////

extern "C" bool_t xdr_PltString(XDR * xdrs, PltString **pp);

//////////////////////////////////////////////////////////////////////

#endif
