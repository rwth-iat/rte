/* -*-plt-c++-*- */
#ifndef KS_XDR_INCLUDED
#define KS_XDR_INCLUDED
/* $Header: /home/david/cvs/acplt/ks/include/ks/xdr.h,v 1.19 2007-04-25 12:57:20 martin Exp $ */
/*
 * Copyright (c) 1996, 1997, 1998, 1999
 * Lehrstuhl fuer Prozessleittechnik, RWTH Aachen
 * D-52064 Aachen, Germany.
 * All rights reserved.
 *
 * This file is part of the ACPLT/KS Package which is licensed as open
 * source under the Artistic License; you can use, redistribute and/or
 * modify it under the terms of that license.
 *
 * You should have received a copy of the Artistic License along with
 * this Package; see the file ARTISTIC-LICENSE. If not, write to the
 * Copyright Holder.
 *
 * THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES
 * OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include "plt/rtti.h"
#include "ks/rpc.h"

//////////////////////////////////////////////////////////////////////
// XDR streaming helper classes and macros
//////////////////////////////////////////////////////////////////////
//
// Intention:
// ==========
// - Objects should know best how to stream themselves.
// - Classes should construct objects directly from the stream
//   to avoid copying large data structures.
// - Constructors have to report failed deserialization via
//   a bool "return value" (== additional reference argument)
//   because exceptions are not generally available.
// - For those objects that are (de-)serialized by RPC there must
//   be extern "C" stubs that call C++ methods.
//
// Usage:
// ======
// Each XDR streamable class shoud derive from KsXdrAble and must define
// a1)   bool xdrEncode(XDR *) const;   // serialization
// a2)   bool xdrDecode(XDR *);         // deserialization
//
// b)    SomeClass::SomeClass(XDR *, bool & ok); // deserialize and construct
// c)    static SomeClass * SomeClass::xdrNew(XDR *); 
//          // factory method for b)
//
// a1) and a2) must be manually implemented
// b) can be implemented by executing KS_IMPL_XDRCTOR(SomeClass) if
//    SomeClass has a cheap default constructor
// c) can be implemented by executing KS_IMPL_XDRNEW(SomeClass); 
// 
// Class KsXdrUnion is an abstract base class for classes with some
// known derivations representing a XDR union. It defines a1) and a2)
// Each derived class has to 
// - define a a distinct "virtual constant" xdrTypeCode() const 
//   (the same value as the XDR union discriminator)
// - define xdrEncodeVariant(XDR *) const
// - define xdrDecodeVariant(XDR *)
// - define the deserialization constructor
// 
// The base class can define 
// - xdrEncodeCommon(XDR *) const 
// - xdrDecodeCommon(XDR*)
// to (de)serialize common state.
//
// The abstract base class definition body can be generated by expanding
//    KS_DECL_XDRUNION(Base);
//
// The definition of c) (s.a.) can be generated by expanding
//    KS_BEGIN_IMPL_XDRUNION( base );
//    KS_XDR_MAP( CONST1, Derived1 );
//    KS_XDR_MAP( CONST2, Derived2 );
//     ...
//    KS_END_IMPL_XDRUNION;
//
// The constructor b) is not needed (Base is abstract)
// a2) works only in some cases because you can't change an
//     object's class
//////////////////////////////////////////////////////////////////////
// See tests/txdr2.cpp for an example
//////////////////////////////////////////////////////////////////////

class KsXdrAble 
{
public:
    virtual ~KsXdrAble() { }
    virtual bool xdrEncode(XDR *) const = 0;  // serialize
    virtual bool xdrDecode(XDR *) = 0;        // deserialize
 // static KsXdrUnion * xdrNew(XDR *) = 0; // deserialization factory meth.
    PLT_DECL_RTTI;
};

//////////////////////////////////////////////////////////////////////

class KsXdrUnion 
: public KsXdrAble 
{
public:
    virtual bool xdrEncode(XDR *) const;
    virtual bool xdrDecode(XDR *) ;
//  static KsXdrUnion * xdrNew(XDR *) = 0;
    virtual enum_t xdrTypeCode() const = 0; // XDR union discriminator 
protected:
    virtual bool xdrEncodeCommon(XDR *) const;       // serialize common part
    virtual bool xdrDecodeCommon(XDR *);             // deser.    common part
    virtual bool xdrEncodeVariant(XDR *) const = 0;
    virtual bool xdrDecodeVariant(XDR *) = 0;
    PLT_DECL_RTTI;
};

//////////////////////////////////////////////////////////////////////

#define KS_IMPL_XDR_C(classname)                  \
    extern "C" bool_t                             \
    xdr_##classname(XDR *xdrs, classname **pp)    \
    {                                             \
        PLT_PRECONDITION( xdrs && pp );           \
        switch(xdrs->x_op) {                      \
                                                  \
        case XDR_FREE:                            \
            if (!*pp) {                           \
                delete *pp;                       \
                *pp = 0;                          \
                return TRUE;                      \
            }                                     \
        case XDR_ENCODE:                          \
            if (! *pp) return FALSE;              \
            return (*pp)->xdrEncode(xdrs);        \
                                                  \
        case XDR_DECODE:                          \
            *pp = classname::xdrNew(xdrs);        \
            return *pp != 0;                      \
                                                  \
        default:                                  \
            return FALSE;                         \
        }                                         \
    }                                             \
    typedef void ks_dummy_typedef

//////////////////////////////////////////////////////////////////////

#define KS_DECL_XDRUNION(base)                                    \
    public:                                                       \
    static base * xdrNew(XDR *);                                  \
    virtual enum_t xdrTypeCode() const = 0; /*redeclaration*/     \
    protected:                                                    \
    virtual bool xdrEncodeVariant(XDR *) const = 0; /*redecl.*/   \
    virtual bool xdrDecodeVariant(XDR *) = 0 /*;     *redecl.*/          

//////////////////////////////////////////////////////////////////////

#define KS_BEGIN_IMPL_XDRUNION(base)                               \
                                                                   \
    base * base::xdrNew(XDR * xdrs)                                \
    {                                                              \
        PLT_PRECONDITION(xdrs->x_op == XDR_DECODE);                \
        base * p = 0;                                              \
        enum_t typecode;                                           \
            if (ks_xdrd_enum(xdrs, &typecode)) {                   \
            /* typecode successfully decoded */                    \
            switch(typecode) {                                     \

#define KS_XDR_MAP(constant,derived)                       \
            case constant:                                 \
            {                                              \
                bool ok=false;                             \
                p = new derived(xdrs, ok);                 \
                if (! ok && p) {                           \
                    delete p;                              \
                    p = 0;                                 \
                }                                          \
            } break                                        

#define KS_END_IMPL_XDRUNION                                       \
           default:                                                \
                /* unknown typecode */                             \
                /* p = 0;           */                             \
                    { }                                            \
            }                                                      \
        }                                                          \
        if (p) {                                                   \
            PLT_ASSERT(p->xdrTypeCode() == typecode);              \
            if (!p->xdrDecodeCommon(xdrs)) {                       \
                delete p;                                          \
                return 0;                                          \
            }                                                      \
        }                                                          \
        return p;                                                  \
    }                                                              \
typedef void ks_dummy_typedef

//////////////////////////////////////////////////////////////////////

#define KS_IMPL_XDRCTOR(classname)                         \
    classname::classname(XDR *xdr, bool &ok) {             \
        ok = xdrDecode(xdr);                               \
    }

//////////////////////////////////////////////////////////////////////

#define KS_IMPL_XDRNEW2(rettype,classname)                 \
    rettype * classname::xdrNew(XDR * xdrs)                \
    {                                                      \
        bool ok=true;                                      \
        rettype * p = new classname(xdrs, ok);             \
        if ( !ok && p) {                                   \
            delete p;                                      \
            p = 0;                                         \
        }                                                  \
        return p;                                          \
    }                                                      \
typedef void ks_dummy_typedef

//////////////////////////////////////////////////////////////////////

#define KS_IMPL_XDRNEW(classname) KS_IMPL_XDRNEW2(classname,classname)

/////////////////////////////////////////////////////////////////////////////

#define KS_IMPL_XDRWRAPPER2(name,typ)                               \
inline bool                                                         \
ks_xdre_##name(XDR *xdr, const typ *p)                              \
{                                                                   \
    PLT_PRECONDITION(xdr->x_op == XDR_ENCODE && p);                 \
    /* The following const->nonconst cast should be safe, */        \
    /* because the XDR-library will not change the object */        \
    /* pointed to.                                        */        \
    return xdr_##name(xdr, (typ *) p) != 0;                         \
}                                                                   \
/****************/                                                  \
inline bool                                                         \
ks_xdrd_##name(XDR *xdr, typ *p)                                    \
{                                                                   \
    PLT_PRECONDITION(xdr->x_op == XDR_DECODE && p);                 \
    /* we don't want the XDR library to create storage for us! */   \
                                                                    \
    return xdr_##name(xdr, p) != 0;                                 \
}                                                                   \
typedef void ks_dummy_typedef

/////////////////////////////////////////////////////////////////////////////

#define KS_IMPL_XDRWRAPPER(typ) KS_IMPL_XDRWRAPPER2(typ,typ)

/////////////////////////////////////////////////////////////////////////////

KS_IMPL_XDRWRAPPER(u_long);
KS_IMPL_XDRWRAPPER(long);
KS_IMPL_XDRWRAPPER(u_int);
KS_IMPL_XDRWRAPPER(int);
KS_IMPL_XDRWRAPPER(u_short);
KS_IMPL_XDRWRAPPER(short);
KS_IMPL_XDRWRAPPER(u_char);
KS_IMPL_XDRWRAPPER(char);
KS_IMPL_XDRWRAPPER(double);
KS_IMPL_XDRWRAPPER(float);

KS_IMPL_XDRWRAPPER2(enum,enum_t);

/////////////////////////////////////////////////////////////////////////////
// 
// bool needs special treatment, we can't assume that bool and bool_t
// have the same representation
//

inline bool
ks_xdre_bool(XDR *xdr, const bool *p)
{
    PLT_PRECONDITION(xdr->x_op == XDR_ENCODE && p);
    bool_t b = *p;
    return xdr_bool(xdr, &b) != 0;
}

/////////////////////////////////////////////////////////////////////////////

inline bool
ks_xdrd_bool(XDR *xdr, bool *p)
{
    PLT_PRECONDITION(xdr->x_op == XDR_DECODE && p);
    /* we don't want the XDR library to create storage for us! */
    bool_t b;
    if (xdr_bool(xdr, &b)) {
        // success
        *p = b ? true : false;
        return true;
    } else {
        return false;
    }
}

//////////////////////////////////////////////////////////////////////
// INLINE IMPLEMENTATION
//////////////////////////////////////////////////////////////////////

inline bool 
KsXdrUnion::xdrDecodeCommon(XDR *)
{
    return true;
}

//////////////////////////////////////////////////////////////////////

inline bool
KsXdrUnion::xdrEncodeCommon(XDR *) const
{
    return true;
}

#endif
