
/******************************************************************************
*
*   FILE
*   ----
*   MsgExt.c
*
*   History
*   -------
*   2014-11-07   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_kshttpMsgExt
#define OV_COMPILE_LIBRARY_kshttpMsgExt
#endif


#include "kshttpMsgExt.h"
#include "libov/ov_macros.h"
#include "ks_logfile.h"
#include "acplt_simpleMsgHandling.h"
#include "MessageSys_helpers.h"
#include "ksbase_helper.h"
#include "libov/ov_result.h"


OV_DLLFNCEXPORT OV_RESULT kshttpMsgExt_MsgExt_constructor(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
    OV_INSTPTR_kshttpMsgExt_MsgExt pinst = Ov_StaticPtrCast(kshttpMsgExt_MsgExt, pobj);
    OV_RESULT    result;
    OV_STRING	command = "/msg";
    /* do what the base class does first */
    result = ov_object_constructor(pobj);
    if(Ov_Fail(result))
         return result;

    /* do what */


    return Ov_SetDynamicVectorValue(&pinst->v_commandList, &command, 1, STRING);
}


OV_DLLFNCEXPORT OV_RESULT kshttpMsgExt_MsgExt_HandleRequest(
	OV_INSTPTR_ksbase_ClientHandler this,
	OV_INSTPTR_ksbase_Channel pChannel,
	KS_DATAPACKET* dataReceived,
	KS_DATAPACKET* answer
) {
    /*
    *   local variables
    */

    return OV_ERR_OK;
}

#define Try(command, errorMessage, answerContent)	\
	do{	\
		result	=	command;	\
		if(Ov_Fail(result)){	\
			KS_logfile_error(errorMessage);	\
			ov_string_setvalue(&response->contentString, answerContent);	\
			return result;	\
		}	\
	} while(FALSE)

OV_DLLFNCEXPORT OV_RESULT kshttpMsgExt_MsgExt_HandleExtendedRequest(
	const OV_INSTPTR_kshttp_httpClientHandlerExtension	pobj,
	const OV_INSTPTR_kshttp_httpclienthandler	pClientHandler,
	const OV_INSTPTR_ksbase_Channel	pChannel,
	const HTTP_REQUEST request,
	HTTP_RESPONSE *response
) {
	OV_UINT iterator;
	OV_INT commantIndex	=	-1;
	OV_RESULT result;
	OV_INSTPTR_kshttpMsgExt_MsgSendExt	pNewSendExt	=	NULL;
	OV_INSTPTR_MessageSys_Message	pNewMessage	=	NULL;
	OV_INSTPTR_ov_domain			pInbox		=	NULL;
	OV_ELEMENT						InboxElem;
	OV_ELEMENT						VarElem;

	for(iterator = 0; iterator < pobj->v_commandList.veclen; iterator++){
		if(ov_string_compare(request.urlPath, pobj->v_commandList.value[iterator]) == OV_STRCMP_EQUAL){
			commantIndex = iterator;
			break;
		}
	}
	if(commantIndex == -1){
		KS_logfile_info(("incompatible url %s for kshttp Message Extension", request.url));
		ov_string_setvalue(&response->contentString, "bad url for handler\n");
		return OV_ERR_NOTIMPLEMENTED;
	}
	if(ov_string_compare(request.requestMethod, "POST") != OV_STRCMP_EQUAL){
		KS_logfile_info(("incompatible requestMethod %s for kshttp Message Extension", request.requestMethod));
		ov_string_setvalue(&response->contentString, "bad requestMethod for handler\n");
		return OV_ERR_BADPARAM;
	}
	if(request.contentLength == 0){
		KS_logfile_info(("no data in content", request.requestMethod));
		ov_string_setvalue(&response->contentString, "no data\n");
		return OV_ERR_BADVALUE;
	}
	if(!pChannel){
		KS_logfile_info(("could not get channel of incoming message"));
		ov_string_setvalue(&response->contentString, "internal Error getting channel\n");
		return OV_ERR_GENERIC;
	}

	Try(MessageSys_parseAndDeliverMsg((OV_STRING)request.messageBody, &pNewMessage, &pInbox),("%s - parse and deliver message failed - line: %u", pobj->v_identifier, __LINE__), "internal error: parseAndDeliver failed\n");
	if(pNewMessage && pInbox)
	{/*	fill in additional information	*/
		pNewMessage->v_sendBy = MSG_SEND_EXTENSION; /*	came via http	*/
		/*	find "holdconnection"-variable, check type and value	*/
		InboxElem.elemtype = OV_ET_OBJECT;
		InboxElem.pobj = Ov_StaticPtrCast(ov_object, pInbox);
		VarElem.elemtype = OV_ET_NONE;
		ov_element_getnextpart(&InboxElem, &VarElem, OV_ET_VARIABLE);
		while(VarElem.elemtype != OV_ET_NONE){
			if(VarElem.elemunion.pvar){
				KS_logfile_debug(("msgHandler %s: iterating over inbox' variables: %s, type: %u", this->v_identifier, VarElem.elemunion.pvar->v_identifier, VarElem.elemunion.pvar->v_vartype & OV_VT_KSMASK));
				if((ov_string_comparei(VarElem.elemunion.pvar->v_identifier, "holdConnection") == OV_STRCMP_EQUAL)	/*	variable name matches	*/
						&& ((VarElem.elemunion.pvar->v_vartype & OV_VT_KSMASK) == OV_VT_BOOL)	/*	varType matches	*/
						&& (*((OV_BOOL*) VarElem.pvalue) == TRUE)) {	/*	we should hold the connection	*/
					Ov_Link(MessageSys_Message2Channel, pNewMessage,  pChannel);
					Ov_CreateIDedObject(kshttpMsgExt_MsgSendExt, pNewSendExt, pobj, "SendExt");
					if(pNewSendExt){
						pNewSendExt->v_httpClientHandlerIDh = pClientHandler->v_idH;
						pNewSendExt->v_httpClientHandlerIDl = pClientHandler->v_idL;
						pNewSendExt->v_actimode = 0;
					}
					Ov_Unlink(ksbase_AssocChannelClientHandler, pChannel, pClientHandler);
					Try(Ov_Link(ksbase_AssocChannelDataHandler, pChannel, pNewSendExt), ("%s - could not relink channel %s - line: %u", pobj->v_identifier, pChannel->v_identifier, __LINE__), "internal error relinking channel\n");
					pClientHandler->v_CommunicationStatus = HTTP_CS_CHANNELRESPONSIBILITYRELEASED;
					pChannel->v_ClientHandlerAssociated = KSBASE_CH_NOTNEEDED;
		/*	from here on we have a different return scheme as the old client handler is currently turned off	*/
#undef Try
#define Try(command, errorMessage, answerContent)	\
		do{	\
			result	=	command;	\
			if(Ov_Fail(result)){	\
				KS_logfile_error(errorMessage);	\
				if(pNewMessage){	\
					Ov_DeleteObject(pNewMessage);	\
				}	\
				ov_string_setvalue(&response->contentString, answerContent);	\
				pClientHandler->v_CommunicationStatus = HTTP_CS_RESPONSEBODYGENERATED;	\
				Ov_Unlink(ksbase_AssocChannelDataHandler, pChannel, pNewSendExt);	\
				if(Ov_Fail(Ov_Link(ksbase_AssocChannelClientHandler, pChannel, pClientHandler))){	\
					Ov_DeleteObject(pChannel);	\
					Ov_DeleteObject(pClientHandler);	\
					Ov_DeleteObject(pNewSendExt);	\
					return result;	\
				}	\
				pChannel->v_ClientHandlerAssociated = KSBASE_CH_ASSOCIATED;	\
				return result;	\
			}	\
		} while(FALSE)

					Try(Ov_Link(MessageSys_SendExtension2Message, pNewSendExt, pNewMessage),("%s - could not link Message to Send extension %s - line: %u", pobj->v_identifier, pNewSendExt->v_identifier, __LINE__), "internal error relinking channel\n");
					pChannel->v_CloseAfterSend = FALSE;
					KS_logfile_debug(("Value: TRUE"));
					break;
				} else {
					KS_logfile_debug(("no match"));
				}
			}
			ov_element_getnextpart(&InboxElem, &VarElem, OV_ET_VARIABLE);
		}
		if(Ov_GetChild(MessageSys_Message2Channel, pNewMessage) != pChannel){
			/*	no need to hold the connection -->  return with ok Message	*/
			pClientHandler->v_CommunicationStatus = HTTP_CS_RESPONSEBODYGENERATED;
			response->keepAlive = FALSE;
			pChannel->v_CloseAfterSend = FALSE;
			ov_string_setvalue(&response->contentString, "Message delivered to inbox. Wait for effect. No further communication on this connection. Bye.\n");
			return OV_ERR_OK;
		}
	} else {
		KS_logfile_info(("%s: Message was not created (line: %u)", pobj->v_identifier, __LINE__));
		ov_string_setvalue(&response->contentString, "Message was not delivered.");	\
	}
    return OV_ERR_OK;
}

