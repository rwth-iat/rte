
/******************************************************************************
*
*   FILE
*   ----
*   msgHandler.c
*
*   History
*   -------
*   2013-11-07   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_MessageSys
#define OV_COMPILE_LIBRARY_MessageSys
#endif


#include "MessageSys.h"
#include "libov/ov_macros.h"
#include "ks_logfile.h"
#include "acplt_simpleMsgHandling.h"
#include "MessageSys_helpers.h"
#include <stdlib.h>
#include <strings.h>

OV_DLLFNCEXPORT void MessageSys_msgHandler_startup(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
//    OV_INSTPTR_MessageSys_msgHandler pinst = Ov_StaticPtrCast(MessageSys_msgHandler, pobj);

    /* do what the base class does first */
    ksbase_ClientHandler_startup(pobj);

    /* do what */


    return;
}

OV_DLLFNCEXPORT void MessageSys_msgHandler_shutdown(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
//    OV_INSTPTR_MessageSys_msgHandler pinst = Ov_StaticPtrCast(MessageSys_msgHandler, pobj);

    /* do what */

    /* set the object's state to "shut down" */
    ksbase_ClientHandler_shutdown(pobj);

    return;
}

OV_DLLFNCEXPORT OV_RESULT MessageSys_msgHandler_HandleRequest(
	OV_INSTPTR_ksbase_ClientHandler this,
	OV_INSTPTR_ksbase_Channel pChannel,
	KS_DATAPACKET* dataReceived,
	KS_DATAPACKET* answer
) {
    /*    
    *   local variables
    */
	OV_STRING msgString = NULL;
	OV_STRING tempData = NULL;
	OV_STRING msgEnd = NULL;
	OV_UINT i;
	OV_UINT msgTagLength;
	OV_UINT msgLeastLength;
	OV_UINT currDataLength;
	OV_UINT hdrLength;
	OV_UINT bdyLength;
	OV_INSTPTR_MessageSys_Message	pNewMessage =	NULL;
	OV_INSTPTR_ov_domain			pInbox 		=	NULL;
	OV_ELEMENT						InboxElem;
	OV_ELEMENT						VarElem;
	OV_INSTPTR_MessageSys_msgHandler	thisMsgHandler = Ov_StaticPtrCast(MessageSys_msgHandler, this);

	/***********************************************************************************************************************************************************************************************
	 *	Check if message is complete in buffer. if not, return ERR_OK and wait for a short time. is the message has not arrived completely within a second we assume it is broken
	 ***********************************************************************************************************************************************************************************************/
	currDataLength = dataReceived->length - (dataReceived->readPT - dataReceived->data);
	if(currDataLength < 19)
	{
		KS_logfile_debug(("%s: HandleRequest: Buffer does NOT hold the complete request. waiting some time...", this->v_identifier));
		pChannel->v_ConnectionTimeOut = thisMsgHandler->v_timeoutIncomplete;
		return OV_ERR_OK;		/*	get called again to process the request next time (if it is complete then).
													Yes, this could block the ClientHandler for a longer time.	*/
	}
	ov_memstack_lock();
	msgString = ov_memstack_alloc(currDataLength + 1);
	/*	just copy until end of tag	*/
	for(i=0; i<dataReceived->length && dataReceived->readPT[i-1] != '>'; i++)
		msgString[i] = dataReceived->readPT[i];
	msgString[i] = '\0';
	msgTagLength = i;
	/*	check if message is valid	*/
	acplt_simpleMsg_xml_findElementBegin(msgString, "msg", &tempData);
	if(!tempData)
	{
		ov_memstack_unlock();
		KS_logfile_info(("%s: HandleRequest: Message not valid: no msg-Tag. Deleting Data.", this->v_identifier));
		return OV_ERR_BADVALUE;
	}
	if(Ov_Fail(acplt_simpleMsg_xml_getAttributeData(msgString, "msg", "hdrL", &tempData)))
	{
		ov_memstack_unlock();
		KS_logfile_info(("%s: HandleRequest: Message not valid: no hdrL Attribute. Deleting Data.", this->v_identifier));
		return OV_ERR_BADVALUE;
	}
	hdrLength = strtoul(tempData, NULL, 10);
	if(!hdrLength)
	{
		ov_memstack_unlock();
		KS_logfile_info(("%s: HandleRequest: Message not valid: hdrL 0 or not valid. Deleting Data.", this->v_identifier));
		return OV_ERR_BADVALUE;
	}
	if(Ov_Fail(acplt_simpleMsg_xml_getAttributeData(msgString, "msg", "bdyL", &tempData)))
	{
		ov_memstack_unlock();
		KS_logfile_info(("%s: HandleRequest: Message not valid: no bdyL Attribute. Deleting Data.", this->v_identifier));
		return OV_ERR_BADVALUE;
	}
	bdyLength = strtoul(tempData, NULL, 10);
	if(!bdyLength)
	{
		ov_memstack_unlock();
		KS_logfile_info(("%s: HandleRequest: Message not valid: bdyL 0 or not valid. Deleting Data.", this->v_identifier));
		return OV_ERR_BADVALUE;
	}
	/*	calculate the least (leaving out whitespaces between the main elements: <msg/>, </hdr> and <bdy>) msgLength: msg-Tag + header + body + "</msg>	*/
	msgLeastLength = msgTagLength + hdrLength + bdyLength + 6;

	if(currDataLength < msgLeastLength)
	{	/*	not complete	*/
		ov_memstack_unlock();
		KS_logfile_debug(("%s: HandleRequest: Buffer does NOT hold the complete request. waiting some time...", this->v_identifier));
		pChannel->v_ConnectionTimeOut = thisMsgHandler->v_timeoutIncomplete;
		return OV_ERR_OK;		/*	get called again to process the request next time (if it is complete then).
															Yes, this could block the ClientHandler for a longer time.	*/
	}
	else
	{
		if(Ov_Fail(acplt_simpleMsg_xml_findElementBegin((char*) dataReceived->readPT, "/msg", &msgEnd)) || !msgEnd)
		{/*	no </msg>-tag still incomplete	*/
			ov_memstack_unlock();
			KS_logfile_debug(("%s: HandleRequest: buffer exceeds size of msgleastLength but no /msg tag found yet", this->v_identifier));
			KS_logfile_debug(("%s: HandleRequest: Buffer does NOT hold the complete request. waiting some time...", this->v_identifier));
			pChannel->v_ConnectionTimeOut = thisMsgHandler->v_timeoutIncomplete;
			return OV_ERR_OK;		/*	get called again to process the request next time (if it is complete then).
																		Yes, this could block the ClientHandler for a longer time.	*/
		}

		KS_logfile_debug(("%s: HandleRequest: msgEnd is %p; that makes a length of: %u", this->v_identifier, msgEnd, (((OV_STRING) dataReceived->readPT) - msgEnd)));

		pChannel->v_ConnectionTimeOut = thisMsgHandler->v_connectionTimeout;
	}

	/***********************************************************************************************************************************************************************************************
	 * message is definitely complete
	 ***********************************************************************************************************************************************************************************************/

	/*	copy rest of message into temporary string and hand it over to the parse function. increment dataReceived->readPT	*/
	for(i=msgTagLength; i<currDataLength; i++)
		msgString[i] = dataReceived->readPT[i];
	msgString[i] = '\0';
	dataReceived->readPT += i;

	KS_logfile_debug(("%s: HandleRequest msgString:\n\n%s\n\n", this->v_identifier, msgString));

	MessageSys_parseAndDeliverMsg(msgString, &pNewMessage, &pInbox);
	if(pNewMessage && pInbox)
	{/*	fill in additional information	*/
		pNewMessage->v_sendBy = MSG_SEND_DIRECTLY; /*	came directly	*/

		pChannel = Ov_GetParent(ksbase_AssocChannelClientHandler, this);
		if(pChannel)
		{
			/*	find "holdconnection"-variable, check type and value	*/
			InboxElem.elemtype = OV_ET_OBJECT;
			InboxElem.pobj = Ov_StaticPtrCast(ov_object, pInbox);
			VarElem.elemtype = OV_ET_NONE;
			ov_element_getnextpart(&InboxElem, &VarElem, OV_ET_VARIABLE);
			while(VarElem.elemtype != OV_ET_NONE)
			{
				if(VarElem.elemunion.pvar)
				{
					KS_logfile_debug(("msgHandler %s: iterating over inbox' variables: %s, type: %u", this->v_identifier, VarElem.elemunion.pvar->v_identifier, VarElem.elemunion.pvar->v_vartype & OV_VT_KSMASK));
					if((ov_string_comparei(VarElem.elemunion.pvar->v_identifier, "holdConnection") == OV_STRCMP_EQUAL)	/*	variable name matches	*/
						&& ((VarElem.elemunion.pvar->v_vartype & OV_VT_KSMASK) == OV_VT_BOOL)	/*	varType matches	*/
						&& (*((OV_BOOL*) VarElem.pvalue) == TRUE))	/*	we should hold the connection	*/
					{
						Ov_Link(MessageSys_Message2Channel, pNewMessage,  pChannel);
						pChannel->v_CloseAfterSend = FALSE;
						KS_logfile_debug(("Value: TRUE"));
						break;
					}
					else
					{
						KS_logfile_debug(("no match"));
						pChannel->v_CloseAfterSend = TRUE;
					}
				}
				ov_element_getnextpart(&InboxElem, &VarElem, OV_ET_VARIABLE);
			}
		}

	}
	else
	{
		Ov_DeleteObject(pChannel);
	}

	ov_memstack_unlock();
    return OV_ERR_OK;
}

