
/******************************************************************************
*
*   FILE
*   ----
*   rtov.c
*
*   History
*   -------
*   2012-11-07   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_rtov
#define OV_COMPILE_LIBRARY_rtov
#endif

/**
 * The SAFE_STACK define determines the size of the prefaulted (safe) stack in kB.
 * The RT_LOG_OV define enables debug-logging
 */
#ifndef SAFE_STACK					/* Size of safe stack in kB. Should be determined in make-process*/
#warning "SAFE_STACK not define will use 128kB as default"
#define MAX_SAFE_STACK (128*1024) /* Defaultvalue for safe stack without faulting */
#else
#define MAX_SAFE_STACK (SAFE_STACK*1024)
#endif

#ifdef RT_LOG_OV
#define log_dbg(a) ov_logfile_debug(a)
#define log_err(a) ov_logfile_error(a)
#else
#define log_dbg(a)
#define log_err(a) ov_logfile_error(a)
#endif

#include "rtov.h"
#include "libov/ov_macros.h"
#include "libov/ov_logfile.h"
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <sched.h>
#include <sys/mman.h>

static void stack_prefault(void) {

        unsigned char dummy[MAX_SAFE_STACK];
log_dbg("prefaulting stack...");
        memset(dummy, 0, MAX_SAFE_STACK);
log_dbg("prefaulting done");
        return;
}

/**
 * Set-accessor for RTenable parameter. This parameter is used to switch RT-mode on or off.
 * Furthermore changes in priority or scheduling policy take effect after a set to RTenable.
 * If RT-mode is switched on with a call, scheduling priority and policy parameters take effect.
 * Memory is locked and the stack prefaulted. If RT-mode was already on before, the new priority and policy take effect.
 * If RT-mode is switched of, memory is unlocked, the priority is set to 0 and the scheduling policy to SCHED_OTHER.
 */
OV_DLLFNCEXPORT OV_RESULT rtov_rtov_RTenable_set(
    OV_INSTPTR_rtov_rtov          pobj,
    const OV_BOOL  value
) {
	struct sched_param param;

	if(value)
    {
    	/* enable real-time behaviour or set new parameters */

		param.sched_priority = pobj->v_priority;
		log_dbg("setting priority...");
		switch(pobj->v_schedFIFO)
		{
		case TRUE:
			if(sched_setscheduler(0, SCHED_FIFO, &param) == -1)
			{
				log_err("sched_setscheduler failed");
				return OV_ERR_GENERIC;
			}
			break;
		default:
			if(sched_setscheduler(0, SCHED_RR, &param) == -1)
			{
				log_err("sched_setscheduler failed");
				return OV_ERR_GENERIC;
			}
			break;
		}
		log_dbg("done");

		if(!pobj->v_RTenable)
		{
			/* Lock memory */
			log_dbg("locking memory...");
			if(mlockall(MCL_CURRENT|MCL_FUTURE) == -1)
			{
				log_err("mlockall failed");
				return OV_ERR_GENERIC;
			}
			log_dbg("done");

			/* Pre-fault our stack */
			stack_prefault();
		}
    }
    else
    {
    	/* disable real-time behaviour*/
    	param.sched_priority = 0;
    	if(pobj->v_RTenable)
    	{
    		log_dbg("disabling RT...");
    		if(sched_setscheduler(0, SCHED_OTHER, &param) == -1)
    		{
    			log_err("sched_setscheduler failed");
    			return OV_ERR_GENERIC;
    		}
    		/* Unlock memory */
    		log_dbg("locking memory...");
    		if(munlockall() == -1)
    		{
    			log_err("munlockall failed");
    			return OV_ERR_GENERIC;
    		}
    		log_dbg("done");
    	}
    }

	pobj->v_RTenable = value;
    return OV_ERR_OK;
}

/**
 * Set-accessor for priority value. Checks the values for range-exceeds. 0-99 is allowed. 99 means highest priority.
 */
OV_DLLFNCEXPORT OV_RESULT rtov_rtov_priority_set(
    OV_INSTPTR_rtov_rtov          pobj,
    const OV_UINT  value
) {
	if((value >= 0) && (value <= 99))
	{
		pobj->v_priority = value;
		return OV_ERR_OK;
	}
	else
		return OV_ERR_BADPARAM;
}

/**
 * During object startup the set parameters take effect.
 * Scheduling priority and policy is set. If RT-mode is enabled memory is locked and the stack prefaulted.
 * First startup is RT-mode with highest priority and FIFO scheduling (see initialvalues).
 */
OV_DLLFNCEXPORT void rtov_rtov_startup(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
    OV_INSTPTR_rtov_rtov pinst = Ov_StaticPtrCast(rtov_rtov, pobj);

    /* do what the base class does first */
    ov_object_startup(pobj);

    /* do what */
    rtov_rtov_RTenable_set(pinst, pinst->v_RTenable);

    /*since RTenable_set won't lock the memory and prefault the stack
     * if RTenable is already set, do this now*/
    if(pinst->v_RTenable)
    {
    	/* Lock memory */
    	log_dbg("locking memory...");
    	if(mlockall(MCL_CURRENT|MCL_FUTURE) == -1)
    	{
    		log_err("mlockall failed");
    		return;
    	}
    	log_dbg("done");

    	/* Pre-fault our stack */
    	stack_prefault();
    }


    return;
}


/**
 * During shutdown RT-mode is switched off. Memory is unlocked.
 */
OV_DLLFNCEXPORT void rtov_rtov_shutdown(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
    OV_INSTPTR_rtov_rtov pinst = Ov_StaticPtrCast(rtov_rtov, pobj);
    struct sched_param param;

    /* do what */
    /* disable real-time behaviour*/
    param.sched_priority = 0;
    if(pinst->v_RTenable)
    {
    	log_dbg("disabling RT...");
    	if(sched_setscheduler(0, SCHED_OTHER, &param) == -1)
    	{
    		log_err("sched_setscheduler failed");
    	}
    	/* Unlock memory */
    	log_dbg("locking memory...");
    	if(munlockall() == -1)
    	{
    		log_err("munlockall failed");
    	}
    	log_dbg("done");
    }
    /* set the object's state to "shut down" */
    ov_object_shutdown(pobj);

    return;
}

/**
 * To make parameters visible in ks.
 */
OV_DLLFNCEXPORT OV_ACCESS rtov_rtov_getaccess(
	OV_INSTPTR_ov_object	pobj,
	const OV_ELEMENT		*pelem,
	const OV_TICKET			*pticket
) {
    /*    
    *   local variables
    */

    switch(pelem->elemtype)
    {
    case OV_ET_VARIABLE:
    	if(pelem->elemunion.pvar->v_offset >= offsetof(OV_INST_ov_object,__classinfo))
    		return OV_AC_READWRITE;
    	else
    		return ov_object_getaccess(pobj, pelem, pticket);

    	default:
    		return	ov_object_getaccess(pobj, pelem, pticket);
   	}
    return ov_object_getaccess(pobj, pelem, pticket);
}

/**
 * Check if there is already an rtov object in the database and abort if so.
 * (The test is not complete. It works because the default placement for created objects is as the classes
 * last child in the instantiation association. If someone works around this test (by setting a different
 * placement-hint) he probably knows what he's doing.
 */
OV_DLLFNCEXPORT OV_RESULT rtov_rtov_constructor(
	OV_INSTPTR_ov_object 	pobj
) {
	/*
	 *   local variables
	 */
	OV_RESULT    result;
	OV_INSTPTR_ov_object instance = 0;
    /* do what the base class does first */
    result = ov_object_constructor(pobj);
    if(Ov_Fail(result))
    	return result;

        /* do what */
    instance = Ov_GetFirstChild(ov_instantiation, pclass_rtov_rtov);
    if(instance != pobj)
    {
    	log_err("There is already an rtov-object on this server");
    	return OV_ERR_ALREADYEXISTS;
    }


    return OV_ERR_OK;
}

