/*
*	Copyright (C) 2010
*	Chair of Process Control Engineering,
*	Aachen University of Technology.
*	All rights reserved.
*
*	Redistribution and use in source and binary forms, with or without
*	modification, are permitted provided that the following conditions
*	are met:
*	1. Redistributions of source code must retain the above copyright
*	   notice, this list of conditions and the following disclaimer.
*	2. Redistributions in binary form must print or display the above
*	   copyright notice either during startup or must have a means for
*	   the user to view the copyright notice.
*	3. Redistributions in binary form must reproduce the above copyright
*	   notice, this list of conditions and the following disclaimer in
*		the documentation and/or other materials provided with the
*		distribution.
*	4. Neither the name of the Chair of Process Control Engineering nor
*		the name of the Aachen University of Technology may be used to
*		endorse or promote products derived from this software without
*		specific prior written permission.
*
*	THIS SOFTWARE IS PROVIDED BY THE CHAIR OF PROCESS CONTROL ENGINEERING
*	``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
*	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
*	A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE CHAIR OF
*	PROCESS CONTROL ENGINEERING BE LIABLE FOR ANY DIRECT, INDIRECT,
*	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
*	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
*	OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
*	AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
*	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
*	WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
*	POSSIBILITY OF SUCH DAMAGE.
*/
/******************************************************************************
*
*   FILE
*   ----
*   ANYtoANY.c
*
*   History
*   -------
*   2001-06-03   File created
*
*******************************************************************************
*
*   This file is generated by the 'fb_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_iec61131stdfb
#define OV_COMPILE_LIBRARY_iec61131stdfb
#endif


#include "iec61131stdfb.h"
#include "libov/ov_macros.h"
#include "libov/ov_logfile.h"
#include "libov/ov_string.h"
#include "stdfb_macros.h"
#include "helper.h"

#include <float.h>
#include <stdlib.h>

#include <stdio.h>


OV_DLLFNCEXPORT OV_RESULT iec61131stdfb_ANYtoANY_IN_set(
    OV_INSTPTR_iec61131stdfb_ANYtoANY          pobj,
    const OV_ANY*  value
) {
    if((value->value.vartype & OV_VT_KSMASK) == (pobj->v_IN.value.vartype & OV_VT_KSMASK))
		return ov_variable_setanyvalue(&pobj->v_IN, value);
	else
	{
		if(iec61131stdfb_isConnected(Ov_PtrUpCast(fb_functionblock, pobj)))
			return OV_ERR_NOACCESS;
		else
		{			//only allow a different type, if the conversion from this type into the type specified by K is implemented
			switch(value->value.vartype & OV_VT_KSMASK)
			{
				case OV_VT_BYTE:
				case OV_VT_BYTE_VEC:
					switch(pobj->v_K)
					{
						case 1:
						case 2:
						case 3:
						case 4:
						case 5:
						case 6:
						case 7:
						case 17:
						case 18:
						case 19:
						case 20:
						case 21:
						case 22:
						case 23:
							return ov_variable_setanyvalue(&pobj->v_IN, value);
						default:
							return OV_ERR_BADPARAM;
					}
				break;
				
				case OV_VT_BOOL:
					switch(pobj->v_K)
					{
						case 1:
						case 2:
						case 3:
						case 4:
						case 5:
						case 6:
						case 7:
						case 17:
						case 18:
						case 19:
						case 20:
						case 21:
						case 22:
						case 23:
							return ov_variable_setanyvalue(&pobj->v_IN, value);
						default:
							return OV_ERR_BADPARAM;
					}
				break;
				
				case OV_VT_UINT:
				case OV_VT_INT:
				case OV_VT_STRING:
					return ov_variable_setanyvalue(&pobj->v_IN, value);
				break;
				
				case OV_VT_SINGLE:
				case OV_VT_DOUBLE:
				case OV_VT_INT_VEC:
				case OV_VT_UINT_VEC:
				case OV_VT_SINGLE_VEC:
				case OV_VT_DOUBLE_VEC:
				case OV_VT_STRING_VEC:
				case OV_VT_TIME_VEC:
				case OV_VT_TIME_SPAN_VEC:
					switch(pobj->v_K)
					{
						case 2:
						case 3:
						case 4:
						case 5:
						case 6:
						case 7:
						case 8:
						case 9:
						case 17:
						case 18:
						case 19:
						case 20:
						case 21:
						case 22:
						case 23:
						case 24:
						case 25:
							return ov_variable_setanyvalue(&pobj->v_IN, value);
						default:
							return OV_ERR_BADPARAM;
					}
				break;
				
				case OV_VT_TIME:
				case OV_VT_TIME_SPAN:
					switch(pobj->v_K)
					{
						case 2:
						case 3:
						case 4:
						case 5:
						case 6:
						case 7:
						case 8:
						case 9:
						case 18:
						case 19:
						case 20:
						case 21:
						case 22:
						case 23:
						case 24:
						case 25:
							return ov_variable_setanyvalue(&pobj->v_IN, value);
						default:
							return OV_ERR_BADPARAM;
					}
				break;
				
				case OV_VT_BOOL_VEC:
					switch(pobj->v_K)
					{
						case 2:
						case 3:
						case 17:
						case 18:
							return ov_variable_setanyvalue(&pobj->v_IN, value);
						default:
							return OV_ERR_BADPARAM;
					}
				break;
				
				default:
					return OV_ERR_GENERIC;
			}
		}
	}
}

OV_DLLFNCEXPORT OV_RESULT iec61131stdfb_ANYtoANY_K_set(
    OV_INSTPTR_iec61131stdfb_ANYtoANY          pobj,
    const OV_UINT  value
) {
    if(pobj->v_K != value)
	{
		if (iec61131stdfb_isConnected (Ov_PtrUpCast (fb_functionblock, pobj)))
			return OV_ERR_NOACCESS;
		else
		{
			pobj->v_K = value;
			iec61131stdfb_freeVec(&pobj->v_OUT);
			switch(pobj->v_K)
			{
				case 1:
					pobj->v_OUT.value.vartype = OV_VT_BYTE;
				break;
				case 2:
					pobj->v_OUT.value.vartype = OV_VT_BOOL;
				break;
				case 3:
					pobj->v_OUT.value.vartype = OV_VT_UINT;
				break;
				case 4:
					pobj->v_OUT.value.vartype = OV_VT_INT;
				break;
				case 5:
					pobj->v_OUT.value.vartype = OV_VT_SINGLE;
				break;
				case 6:
					pobj->v_OUT.value.vartype = OV_VT_DOUBLE;
				break;
				case 7:
					pobj->v_OUT.value.vartype = OV_VT_STRING;
				break;
				case 8:
					pobj->v_OUT.value.vartype = OV_VT_TIME;
				break;
				case 9:
					pobj->v_OUT.value.vartype = OV_VT_TIME_SPAN;
				break;
				
				case 17:
					pobj->v_OUT.value.vartype = OV_VT_BYTE_VEC;
				break;
				case 18:
					pobj->v_OUT.value.vartype = OV_VT_BOOL_VEC;
				break;
				case 19:
					pobj->v_OUT.value.vartype = OV_VT_UINT_VEC;
				break;
				case 20:
					pobj->v_OUT.value.vartype = OV_VT_INT_VEC;
				break;
				case 21:
					pobj->v_OUT.value.vartype = OV_VT_SINGLE_VEC;
				break;
				case 22:
					pobj->v_OUT.value.vartype = OV_VT_DOUBLE_VEC;
				break;
				case 23:
					pobj->v_OUT.value.vartype = OV_VT_STRING_VEC;
				break;
				case 24:
					pobj->v_OUT.value.vartype = OV_VT_TIME_VEC;
				break;
				case 25:
					pobj->v_OUT.value.vartype = OV_VT_TIME_SPAN_VEC;
				break;
				default:
					return OV_ERR_BADPARAM;
				break;
			}
		}
	}
    
	return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_ANY* iec61131stdfb_ANYtoANY_OUT_get(
    OV_INSTPTR_iec61131stdfb_ANYtoANY          pobj
) {
    return &pobj->v_OUT;
}


OV_DLLFNCEXPORT OV_RESULT iec61131stdfb_ANYtoANY_constructor(OV_INSTPTR_ov_object pobj) {

	OV_RESULT res;
	OV_INSTPTR_iec61131stdfb_ANYtoANY pinst = Ov_StaticPtrCast(iec61131stdfb_ANYtoANY, pobj);
	
	res = fb_functionblock_constructor(pobj);
	
	if(Ov_OK(res))
	{
		pinst->v_IN.value.valueunion.val_double = 0;
		pinst->v_OUT.value.valueunion.val_double = 0;
		pinst->v_IN.value.vartype = OV_VT_INT;
		pinst->v_OUT.value.vartype = OV_VT_SINGLE;
		return OV_ERR_OK;
	}
	else
		return res;
}

OV_DLLFNCEXPORT void iec61131stdfb_ANYtoANY_destructor(OV_INSTPTR_ov_object pobj) {

	OV_INSTPTR_iec61131stdfb_ANYtoANY pinst = Ov_StaticPtrCast(iec61131stdfb_ANYtoANY, pobj);
	
	iec61131stdfb_freeVec(&pinst->v_IN);
	iec61131stdfb_freeVec(&pinst->v_OUT);
	
	fb_functionblock_destructor(pobj);
}

OV_DLLFNCEXPORT void iec61131stdfb_ANYtoANY_typemethod(
	OV_INSTPTR_fb_functionblock	pfb,
	OV_TIME						*pltc
) {
    /*    
    *   local variables
    */
    unsigned int i;
	unsigned int length;
	char * c_temp;
	double d_temp;
	
	OV_STRING s_temp = 0;
	
	OV_INSTPTR_iec61131stdfb_ANYtoANY pinst = Ov_StaticPtrCast(iec61131stdfb_ANYtoANY, pfb);
	
	iec61131stdfb_freeVec(&pinst->v_OUT);
	
	switch(pinst->v_IN.value.vartype & OV_VT_KSMASK)		//conversion from
	{
			/******************************BYTE******************/
		case OV_VT_BYTE:
			switch(pinst->v_K)
			{
				case 1:
					BYTE_TO(BYTE, byte);
				break;
				
				case 2:
					pinst->v_OUT.value.vartype = OV_VT_BOOL;
					if(pinst->v_IN.value.valueunion.val_byte)
						pinst->v_OUT.value.valueunion.val_bool = 1;
					else
						pinst->v_OUT.value.valueunion.val_bool = 0;
				break;
				
				case 3:
					BYTE_TO(UINT, uint);
				break;
				
				case 4:
					BYTE_TO(INT, int);
				break;
				
				case 5:
					BYTE_TO(SINGLE, single);
				break;
				
				case 6:
					BYTE_TO(DOUBLE, double);
				break;
				
				case 7:
					pinst->v_OUT.value.vartype = OV_VT_STRING;
					if(Ov_Fail(ov_string_print(&pinst->v_OUT.value.valueunion.val_string, "%u", pinst->v_IN.value.valueunion.val_byte)))
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 17:
					BYTE_TO_VEC(BYTE, byte);
				break;
				
				case 18:
					pinst->v_OUT.value.vartype = OV_VT_BOOL_VEC;
					if(Ov_Fail(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_bool_vec, 1, BOOL)))
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
					if(pinst->v_IN.value.valueunion.val_byte)
						pinst->v_OUT.value.valueunion.val_bool_vec.value[0] = 1;
					else
						pinst->v_OUT.value.valueunion.val_bool_vec.value[0] = 0;
				break;
				
				case 19:
					BYTE_TO_VEC(UINT, uint);
				break;
				
				case 20:
					BYTE_TO_VEC(INT, int);
				break;
				
				case 21:
					BYTE_TO_VEC(SINGLE, single);
				break;
				
				case 22:
					BYTE_TO_VEC(DOUBLE, double);
				break;
				
				case 23:
					pinst->v_OUT.value.vartype = OV_VT_STRING_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_string_vec, 1, STRING)))
					{
						if(Ov_Fail(ov_string_print(&pinst->v_OUT.value.valueunion.val_string_vec.value[0], "%u", pinst->v_IN.value.valueunion.val_byte)))
						{
							ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
							return;
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
					
				break;
				
				default:
					ov_logfile_error("%s: conversion to specified datatype not implemented", pinst->v_identifier);
					pinst->v_OUT.value.vartype = OV_VT_BOOL;
					pinst->v_OUT.value.valueunion.val_bool = FALSE;
					return;
			}
		break;
		
					/******************************BOOL******************/
		
		case OV_VT_BOOL:
			switch(pinst->v_K)
			{
				case 1:
					BOOL_TO(BYTE, byte);
				break;
				
				case 2:
					pinst->v_OUT.value.vartype = OV_VT_BOOL;
					pinst->v_OUT.value.valueunion.val_bool = pinst->v_IN.value.valueunion.val_bool;
				break;
				
				case 3:
					BOOL_TO(UINT, uint);
				break;
				
				case 4:
					BOOL_TO(INT, int);
				break;
				
				case 5:
					BOOL_TO(SINGLE, single);
				break;
				
				case 6:
					BOOL_TO(DOUBLE, double);
				break;
				
				case 7:
					pinst->v_OUT.value.vartype = OV_VT_STRING;
					if(pinst->v_IN.value.valueunion.val_bool)
					{
						if(Ov_Fail(ov_string_setvalue(&pinst->v_OUT.value.valueunion.val_string, "TRUE")))
						{
							ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
							return;
						}
					}	
					else
						if(Ov_Fail(ov_string_setvalue(&pinst->v_OUT.value.valueunion.val_string, "FALSE")))
						{
							ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
							return;
						}
				break;
				
				case 17:
					BOOL_TO_VEC(BYTE, byte);
				break;
				
				case 18:
					pinst->v_OUT.value.vartype = OV_VT_BOOL_VEC;
					if(Ov_Fail(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_bool_vec, 1, BOOL)))
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
					pinst->v_OUT.value.valueunion.val_bool_vec.value[0] = pinst->v_IN.value.valueunion.val_bool;
				break;
				
				case 19:
					BOOL_TO_VEC(UINT, uint);
				break;
				
				case 20:
					BOOL_TO_VEC(INT, int);
				break;
				
				case 21:
					BOOL_TO_VEC(SINGLE, single);
				break;
				
				case 22:
					BOOL_TO_VEC(DOUBLE, double);
				break;
				
				case 23:
					pinst->v_OUT.value.vartype = OV_VT_STRING_VEC;
					if(Ov_Fail(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_string_vec, 1, STRING)))
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
					
					if(pinst->v_IN.value.valueunion.val_bool)
					{
						if(Ov_Fail(ov_string_setvalue(&pinst->v_OUT.value.valueunion.val_string_vec.value[0], "TRUE")))
						{
							ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
							return;
						}
					}
					else
						if(Ov_Fail(ov_string_setvalue(&pinst->v_OUT.value.valueunion.val_string_vec.value[0], "FALSE")))
						{
							ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
							return;
						}
				break;
				
				default:
					ov_logfile_error("%s: conversion to specified datatype not implemented", pinst->v_identifier);
					pinst->v_OUT.value.vartype = OV_VT_BOOL;
					pinst->v_OUT.value.valueunion.val_bool = FALSE;
					return;
			}
		break;
		
				/******************************UINT******************/
		
		case OV_VT_UINT:
			switch(pinst->v_K)
			{
				case 1:		//BYTE
					pinst->v_OUT.value.vartype = OV_VT_BYTE;
					if(pinst->v_IN.value.valueunion.val_uint > 255)
					{
						ov_logfile_error("%s: value exceeds range of byte", pinst->v_identifier);
						pinst->v_OUT.value.valueunion.val_byte = (OV_BYTE) (pinst->v_IN.value.valueunion.val_uint & 0xFF);
					}
					else
						pinst->v_OUT.value.valueunion.val_byte = (OV_BYTE) pinst->v_IN.value.valueunion.val_uint;
				break;
				
				case 2:		//BOOL
					pinst->v_OUT.value.vartype = OV_VT_BOOL;
					if(pinst->v_IN.value.valueunion.val_uint)
						pinst->v_OUT.value.valueunion.val_bool = 1;
					else
						pinst->v_OUT.value.valueunion.val_bool = 0;
				break;
				
				case 3:		//UINT
					pinst->v_OUT.value.vartype = OV_VT_UINT;
					pinst->v_OUT.value.valueunion.val_uint = pinst->v_IN.value.valueunion.val_uint;
				break;
				
				case 4:		//INT
					pinst->v_OUT.value.vartype = OV_VT_INT;
					if(pinst->v_IN.value.valueunion.val_uint > OV_VL_MAXINT)
					{
						ov_logfile_error("%s: value exceeds range of int", pinst->v_identifier);
						pinst->v_OUT.value.valueunion.val_int = pinst->v_IN.value.valueunion.val_uint;
					}
					else
						pinst->v_OUT.value.valueunion.val_int = pinst->v_IN.value.valueunion.val_uint;
				break;
				
				case 5:		//SINGLE
					pinst->v_OUT.value.vartype = OV_VT_SINGLE;
					if(pinst->v_IN.value.valueunion.val_uint >= 10000000 || pinst->v_IN.value.valueunion.val_uint < -10000000)	//7 Digits precision ok
						ov_logfile_warning("%s: large integer value, possible loss of precision due to conversion to single", pinst->v_identifier);
					pinst->v_OUT.value.valueunion.val_single = (OV_SINGLE) pinst->v_IN.value.valueunion.val_uint;
				break;
				
				case 6:		//DOUBLE
					pinst->v_OUT.value.vartype = OV_VT_DOUBLE;
					pinst->v_OUT.value.valueunion.val_double = pinst->v_IN.value.valueunion.val_uint;
				break;
				
				case 7:		//STRING
					pinst->v_OUT.value.vartype = OV_VT_STRING;
					if(Ov_Fail(ov_string_print(&pinst->v_OUT.value.valueunion.val_string, "%u", pinst->v_IN.value.valueunion.val_uint)))
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 8:		//TIME
					pinst->v_OUT.value.vartype = OV_VT_TIME;
					pinst->v_OUT.value.valueunion.val_time.secs = pinst->v_IN.value.valueunion.val_uint;
					pinst->v_OUT.value.valueunion.val_time.usecs = 0;
					
				break;
				
				case 9:		//TIME_SPAN
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN;
					pinst->v_OUT.value.valueunion.val_time_span.secs = pinst->v_IN.value.valueunion.val_uint / 1000;
					pinst->v_OUT.value.valueunion.val_time.usecs = (pinst->v_IN.value.valueunion.val_uint % 1000) * 1000;
				break;
				
				case 17:	//BYTE_VEC
					pinst->v_OUT.value.vartype = OV_VT_BYTE_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_byte_vec, sizeof(int) / sizeof(char), BYTE)))
					{
						*(unsigned int *)pinst->v_OUT.value.valueunion.val_byte_vec.value = pinst->v_IN.value.valueunion.val_uint;
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 18:	//BOOL_VEC
					pinst->v_OUT.value.vartype = OV_VT_BOOL_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_bool_vec, 1, BOOL)))
					{
						if(pinst->v_IN.value.valueunion.val_uint)
							pinst->v_OUT.value.valueunion.val_bool_vec.value[0] = 1;
						else
							pinst->v_OUT.value.valueunion.val_bool_vec.value[0] = 0;
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 19:	//UINT_VEC
					pinst->v_OUT.value.vartype = OV_VT_UINT_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_uint_vec, 1, UINT)))
						pinst->v_OUT.value.valueunion.val_uint_vec.value[0] = pinst->v_IN.value.valueunion.val_uint;
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 20:	//INT_VEC
					pinst->v_OUT.value.vartype = OV_VT_INT_VEC;
					if(Ov_Fail(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_int_vec, 1, INT)))
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
					
					if(pinst->v_IN.value.valueunion.val_uint > OV_VL_MAXINT)
						ov_logfile_error("%s: value exceeds range of int", pinst->v_identifier);
					pinst->v_OUT.value.valueunion.val_int_vec.value[0] = pinst->v_IN.value.valueunion.val_uint;
				break;
				
				case 21:	//SINGLE_VEC
					pinst->v_OUT.value.vartype = OV_VT_SINGLE_VEC;
					if(Ov_Fail(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_single_vec, 1, SINGLE)))
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
					
					if(pinst->v_IN.value.valueunion.val_uint > 10000000)
						ov_logfile_warning("%s: possibly loss of precision", pinst->v_identifier);
					pinst->v_OUT.value.valueunion.val_single_vec.value[0] = (OV_SINGLE) pinst->v_IN.value.valueunion.val_uint;
				break;
				
				case 22:	//DOUBLE_VEC
					pinst->v_OUT.value.vartype = OV_VT_DOUBLE_VEC;
					if(Ov_Fail(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_double_vec, 1, DOUBLE)))
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
					pinst->v_OUT.value.valueunion.val_double_vec.value[0] = pinst->v_IN.value.valueunion.val_uint;
				break;
				
				case 23:	//STRING_VEC
					pinst->v_OUT.value.vartype = OV_VT_STRING_VEC;
					if(Ov_Fail(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_string_vec, 1, STRING)))
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
					
					if(Ov_Fail(ov_string_print(&pinst->v_OUT.value.valueunion.val_string_vec.value[0], "%u", pinst->v_IN.value.valueunion.val_uint)))
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
					
				break;
				
				case 24:	//TIME_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_VEC;
					if(Ov_Fail(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_vec, 1, TIME)))
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
					pinst->v_OUT.value.valueunion.val_time_vec.value[0].secs = pinst->v_IN.value.valueunion.val_uint;
					pinst->v_OUT.value.valueunion.val_time_vec.value[0].usecs = 0;
				break;
				
				case 25:	//TIME_SPAN_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN_VEC;
					if(Ov_Fail(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_span_vec, 1, TIME_SPAN)))
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
					pinst->v_OUT.value.valueunion.val_time_span_vec.value[0].secs = pinst->v_IN.value.valueunion.val_uint / 1000;
					pinst->v_OUT.value.valueunion.val_time_vec.value[0].usecs = (pinst->v_IN.value.valueunion.val_uint % 1000) * 1000;
				break;
				
				default:
					ov_logfile_error("%s: conversion to specified datatype not implemented", pinst->v_identifier);
					pinst->v_OUT.value.vartype = OV_VT_BOOL;
					pinst->v_OUT.value.valueunion.val_bool = FALSE;
					return;
			}
		break;
		
				/******************************INT******************/
		
		case OV_VT_INT:
			switch(pinst->v_K)
			{
				case 1:		//BYTE
					pinst->v_OUT.value.vartype = OV_VT_BYTE;
					if(pinst->v_IN.value.valueunion.val_int < 0)
					{
						ov_logfile_error("%s: trying to convert negative integer to byte (unsigned)", pinst->v_identifier);
						pinst->v_OUT.value.valueunion.val_byte = (pinst->v_IN.value.valueunion.val_int & 0xFF);
					}
					else
						if(pinst->v_IN.value.valueunion.val_int > 255)
						{
							ov_logfile_error("%s: value exceeds range of byte", pinst->v_identifier);
							pinst->v_OUT.value.valueunion.val_byte = (pinst->v_IN.value.valueunion.val_int & 0xFF);
						}
						else
							pinst->v_OUT.value.valueunion.val_byte = (OV_BYTE) pinst->v_IN.value.valueunion.val_int;
				break;
				
				case 2:		//BOOL
					pinst->v_OUT.value.vartype = OV_VT_BOOL;
					if(pinst->v_IN.value.valueunion.val_int)
						pinst->v_OUT.value.valueunion.val_bool = 1;
					else
						pinst->v_OUT.value.valueunion.val_bool = 0;
				break;
				
				case 3:		//UINT
					pinst->v_OUT.value.vartype = OV_VT_UINT;
					pinst->v_OUT.value.valueunion.val_uint = pinst->v_IN.value.valueunion.val_int;
					if(pinst->v_IN.value.valueunion.val_int < 0)
						ov_logfile_error("%s: trying to convert negative value to unsigned int", pinst->v_identifier);
				break;
				
				case 4:		//INT
					pinst->v_OUT.value.vartype = OV_VT_INT;
					pinst->v_OUT.value.valueunion.val_int = pinst->v_IN.value.valueunion.val_int;
				break;
				
				case 5:		//SINGLE
					pinst->v_OUT.value.vartype = OV_VT_SINGLE;
					if(pinst->v_IN.value.valueunion.val_int >= 10000000)	//7 Digits precision ok
						ov_logfile_warning("%s: large integer value, possible loss of precision due to conversion to single", pinst->v_identifier);
					pinst->v_OUT.value.valueunion.val_single = (OV_SINGLE) pinst->v_IN.value.valueunion.val_int;
				break;
				
				case 6:		//DOUBLE
					pinst->v_OUT.value.vartype = OV_VT_DOUBLE;
					pinst->v_OUT.value.valueunion.val_double = pinst->v_IN.value.valueunion.val_int;
				break;
				
				case 7:		//STRING
					pinst->v_OUT.value.vartype = OV_VT_STRING;
					if(Ov_Fail(ov_string_print(&pinst->v_OUT.value.valueunion.val_string, "%d", pinst->v_IN.value.valueunion.val_int)))
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 8:		//TIME
					pinst->v_OUT.value.vartype = OV_VT_TIME;
					if(pinst->v_IN.value.valueunion.val_int >= 0)
						pinst->v_OUT.value.valueunion.val_time.secs = pinst->v_IN.value.valueunion.val_int;
					else
					{
						ov_logfile_error("%s: trying to convert negative value to time datatype, this is not possible", pinst->v_identifier);
						pinst->v_OUT.value.valueunion.val_time.secs = 0;			//integer taken for seconds (iec61131-s says miliseconds, but then value is not large enough)
					}
					pinst->v_OUT.value.valueunion.val_time.usecs = 0;
				break;
				
				case 9:		//TIME_SPAN
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN;
					pinst->v_OUT.value.valueunion.val_time_span.secs = pinst->v_IN.value.valueunion.val_int / 1000;
					pinst->v_OUT.value.valueunion.val_time.usecs = (pinst->v_IN.value.valueunion.val_int % 1000) * 1000;
				break;
				
				case 17:	//BYTE_VEC
					pinst->v_OUT.value.vartype = OV_VT_BYTE_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_byte_vec, sizeof(int) / sizeof(char), BYTE)))
					{
						*(int *)pinst->v_OUT.value.valueunion.val_byte_vec.value = pinst->v_IN.value.valueunion.val_int;	
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 18:	//BOOL_VEC
					pinst->v_OUT.value.vartype = OV_VT_BOOL_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_bool_vec, 1, BOOL)))
					{
						if(pinst->v_IN.value.valueunion.val_int)
							pinst->v_OUT.value.valueunion.val_bool_vec.value[0] = 1;
						else
							pinst->v_OUT.value.valueunion.val_bool_vec.value[0] = 0;
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 19:	//UINT_VEC
					pinst->v_OUT.value.vartype = OV_VT_UINT_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_uint_vec, 1, UINT)))
					{
						if(pinst->v_IN.value.valueunion.val_int < 0)
						{
							ov_logfile_error("%s: trying to convert negative value to unsigned int", pinst->v_identifier);
							pinst->v_OUT.value.valueunion.val_uint_vec.value[0] = pinst->v_IN.value.valueunion.val_int;
						}
						else
							pinst->v_OUT.value.valueunion.val_uint_vec.value[0] = pinst->v_IN.value.valueunion.val_int;
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 20:	//INT_VEC
					pinst->v_OUT.value.vartype = OV_VT_INT_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_int_vec, 1, INT)))
					{
						pinst->v_OUT.value.valueunion.val_int_vec.value[0] = pinst->v_IN.value.valueunion.val_int;
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 21:	//SINGLE_VEC
					pinst->v_OUT.value.vartype = OV_VT_SINGLE_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_single_vec, 1, SINGLE)))
					{
						if(pinst->v_IN.value.valueunion.val_int > 10000000)
							ov_logfile_warning("%s: large integer value, possible loss of precision due to conversion to single", pinst->v_identifier);
						
						pinst->v_OUT.value.valueunion.val_single_vec.value[0] = (OV_SINGLE) pinst->v_IN.value.valueunion.val_int;
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 22:	//DOUBLE_VEC
					pinst->v_OUT.value.vartype = OV_VT_DOUBLE_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_double_vec, 1, DOUBLE)))
					{
						pinst->v_OUT.value.valueunion.val_double_vec.value[0] = pinst->v_IN.value.valueunion.val_int;
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 23:	//STRING_VEC
					pinst->v_OUT.value.vartype = OV_VT_STRING_VEC;
					if(Ov_Fail(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_string_vec, 1, STRING)))
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
					
					if(Ov_Fail(ov_string_print(&pinst->v_OUT.value.valueunion.val_string_vec.value[0], "%d", pinst->v_IN.value.valueunion.val_int)))
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 24:	//TIME_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_VEC;
					if(Ov_Fail(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_vec, 1, TIME)))
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
					if(pinst->v_IN.value.valueunion.val_int >= 0)
						pinst->v_OUT.value.valueunion.val_time_vec.value[0].secs = pinst->v_IN.value.valueunion.val_int;
					else
					{
						ov_logfile_error("%s: trying to convert negative integer to time. this is not possible", pinst->v_identifier);
						pinst->v_OUT.value.valueunion.val_time_vec.value[0].secs = 0;
					}
					pinst->v_OUT.value.valueunion.val_time_vec.value[0].usecs = 0;
				break;
				
				case 25:	//TIME_SPAN_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN_VEC;
					if(Ov_Fail(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_span_vec, 1, TIME_SPAN)))
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
					pinst->v_OUT.value.valueunion.val_time_span_vec.value[0].secs = pinst->v_IN.value.valueunion.val_int / 1000;
					pinst->v_OUT.value.valueunion.val_time_vec.value[0].usecs = (pinst->v_IN.value.valueunion.val_int % 1000) * 1000;
				break;
				
				default:
					ov_logfile_error("%s: conversion to specified datatype not implemented", pinst->v_identifier);
					pinst->v_OUT.value.vartype = OV_VT_BOOL;
					pinst->v_OUT.value.valueunion.val_bool = FALSE;
					return;
			}
		break;
		
		/******************************SINGLE******************/
		
		case OV_VT_SINGLE:
			switch(pinst->v_K)
			{
				case 2:		//BOOL
					pinst->v_OUT.value.vartype = OV_VT_BOOL;
					if(pinst->v_IN.value.valueunion.val_single)
						pinst->v_OUT.value.valueunion.val_bool = 1;
					else
						pinst->v_OUT.value.valueunion.val_bool = 0;
				break;
				
				case 3:		//UINT
					pinst->v_OUT.value.vartype = OV_VT_UINT;
					if(pinst->v_IN.value.valueunion.val_single >= 0)
					{
						if(pinst->v_IN.value.valueunion.val_single > OV_VL_MAXUINT)	
							ov_logfile_error("%s: value exceeds range of unsigned int", pinst->v_identifier);
						pinst->v_OUT.value.valueunion.val_uint = (OV_UINT) pinst->v_IN.value.valueunion.val_single;
						if((pinst->v_IN.value.valueunion.val_single - pinst->v_OUT.value.valueunion.val_uint) > 0.5)		//round up
							pinst->v_OUT.value.valueunion.val_uint++;
						else
							if(((pinst->v_IN.value.valueunion.val_single - pinst->v_OUT.value.valueunion.val_uint) == 0.5) && (pinst->v_OUT.value.valueunion.val_uint % 2 != 0))	//round up, if this is even
								pinst->v_OUT.value.valueunion.val_uint++;
					}
					else
						ov_logfile_error("%s: trying to convert engative value to unsigned integer", pinst->v_identifier);
				break;
				
				case 4:		//INT
					pinst->v_OUT.value.vartype = OV_VT_INT;
					if(pinst->v_IN.value.valueunion.val_single > OV_VL_MAXINT || pinst->v_IN.value.valueunion.val_single < -(int) OV_VL_MAXINT)	
							ov_logfile_error("%s: value exceeds range of int", pinst->v_identifier);
					pinst->v_OUT.value.valueunion.val_int = (OV_INT) pinst->v_IN.value.valueunion.val_single;
					if((pinst->v_IN.value.valueunion.val_single - pinst->v_OUT.value.valueunion.val_int) > 0.5)		//round up
						pinst->v_OUT.value.valueunion.val_int++;
					else
						if((pinst->v_IN.value.valueunion.val_single - pinst->v_OUT.value.valueunion.val_int) < -0.5)		//round down
							pinst->v_OUT.value.valueunion.val_int--;
						else
							if(((pinst->v_IN.value.valueunion.val_single - pinst->v_OUT.value.valueunion.val_int) == 0.5) && (pinst->v_OUT.value.valueunion.val_int % 2 != 0))	//round up, if this is even
								pinst->v_OUT.value.valueunion.val_int++;
							else
								if(((pinst->v_IN.value.valueunion.val_single - pinst->v_OUT.value.valueunion.val_int) == -0.5) && (pinst->v_OUT.value.valueunion.val_int % 2 != 0))
									pinst->v_OUT.value.valueunion.val_int--;
				break;
				
				case 5:		//SINGLE
					pinst->v_OUT.value.vartype = OV_VT_SINGLE;
					pinst->v_OUT.value.valueunion.val_single = pinst->v_IN.value.valueunion.val_single;
				break;
				
				case 6:		//DOUBLE
					pinst->v_OUT.value.vartype = OV_VT_DOUBLE;
					pinst->v_OUT.value.valueunion.val_double = pinst->v_IN.value.valueunion.val_single;
				break;
				
				case 7:		//STRING
					pinst->v_OUT.value.vartype = OV_VT_STRING;
					if(Ov_Fail(ov_string_print(&pinst->v_OUT.value.valueunion.val_string, "%f", pinst->v_IN.value.valueunion.val_single)))
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 8:		//TIME
					pinst->v_OUT.value.vartype = OV_VT_TIME;
					if(pinst->v_IN.value.valueunion.val_single >= 0)
					{			
						if(pinst->v_IN.value.valueunion.val_single > (float) OV_VL_MAXUINT)	
							ov_logfile_error("%s: value exceeds range of time", pinst->v_identifier);
						pinst->v_OUT.value.valueunion.val_time.secs = (OV_UINT) pinst->v_IN.value.valueunion.val_single;
						pinst->v_OUT.value.valueunion.val_time.usecs = (OV_UINT) (pinst->v_IN.value.valueunion.val_single - pinst->v_OUT.value.valueunion.val_time.secs ) * 1000000;	//subtracting seconds and converting to microseconds
					}
					else
						ov_logfile_error("%s: trying to convert negative value to time, this is not possible", pinst->v_identifier);
				break;
				
				case 9:		//TIME_SPAN
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN;
					if(pinst->v_IN.value.valueunion.val_single > (float) OV_VL_MAXINT || pinst->v_IN.value.valueunion.val_single < -(float) OV_VL_MAXINT)	
						ov_logfile_error("%s: value exceeds range of time_span", pinst->v_identifier);
					pinst->v_OUT.value.valueunion.val_time_span.secs = (OV_INT) pinst->v_IN.value.valueunion.val_single;
					pinst->v_OUT.value.valueunion.val_time_span.usecs = (OV_INT) (pinst->v_IN.value.valueunion.val_single - pinst->v_OUT.value.valueunion.val_time_span.secs) * 1000000;	//subtracting seconds and converting to microseconds
					
				break;
				
				case 17:	//BYTE_VEC		byte vector with length of 4  represents a DWORD
					pinst->v_OUT.value.vartype = OV_VT_BYTE_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_byte_vec, sizeof(float) / sizeof(char), BYTE)))
					{
						*(float *)pinst->v_OUT.value.valueunion.val_byte_vec.value = pinst->v_IN.value.valueunion.val_single;		//4 bytes are one float, bitwise transfer, no memory problems unless size of float is changed
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 18:	//BOOL_VEC
					pinst->v_OUT.value.vartype = OV_VT_BOOL_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_bool_vec, 1, BOOL)))
					{
						if(pinst->v_IN.value.valueunion.val_single)
							pinst->v_OUT.value.valueunion.val_bool_vec.value[0] = 1;
						else
							pinst->v_OUT.value.valueunion.val_bool_vec.value[0] = 0;
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 19:	//UINT_VEC
					pinst->v_OUT.value.vartype = OV_VT_UINT_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_uint_vec, 1, UINT)))
					{
						if(pinst->v_IN.value.valueunion.val_single >= 0)
						{
							if(pinst->v_IN.value.valueunion.val_single > OV_VL_MAXUINT)	
								ov_logfile_error("%s: value exceeds range of unsigned int", pinst->v_identifier);
							pinst->v_OUT.value.valueunion.val_uint_vec.value[0] = (OV_UINT) pinst->v_IN.value.valueunion.val_single;
							if((pinst->v_IN.value.valueunion.val_single - pinst->v_OUT.value.valueunion.val_uint_vec.value[0]) > 0.5)		//round up
								pinst->v_OUT.value.valueunion.val_uint_vec.value[0]++;
							else
								if(((pinst->v_IN.value.valueunion.val_single - pinst->v_OUT.value.valueunion.val_uint_vec.value[0]) == 0.5) && (pinst->v_OUT.value.valueunion.val_uint_vec.value[0] % 2 != 0))	//round up, if this is even
									pinst->v_OUT.value.valueunion.val_uint_vec.value[0]++;
						}
						else
							ov_logfile_error("%s: trying to convert engative value to unsigned integer", pinst->v_identifier);
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 20:	//INT_VEC
					pinst->v_OUT.value.vartype = OV_VT_INT_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_int_vec, 1, INT)))
					{
						if(pinst->v_IN.value.valueunion.val_single > OV_VL_MAXINT)	
							ov_logfile_error("%s: value exceeds range of int", pinst->v_identifier);
						pinst->v_OUT.value.valueunion.val_int_vec.value[0] = (OV_INT) pinst->v_IN.value.valueunion.val_single;
						if((pinst->v_IN.value.valueunion.val_single - pinst->v_OUT.value.valueunion.val_int_vec.value[0]) > 0.5)		//round up
							pinst->v_OUT.value.valueunion.val_int_vec.value[0]++;
						else
							if((pinst->v_IN.value.valueunion.val_single - pinst->v_OUT.value.valueunion.val_int_vec.value[0]) < -0.5)		//round down
								pinst->v_OUT.value.valueunion.val_int_vec.value[0]--;
							else
								if(((pinst->v_IN.value.valueunion.val_single - pinst->v_OUT.value.valueunion.val_int_vec.value[0]) == 0.5) && (pinst->v_OUT.value.valueunion.val_int_vec.value[0] % 2 != 0))	//round up, if this is even
									pinst->v_OUT.value.valueunion.val_int_vec.value[0]++;
								else
									if(((pinst->v_IN.value.valueunion.val_single - pinst->v_OUT.value.valueunion.val_int_vec.value[0]) == -0.5) && (pinst->v_OUT.value.valueunion.val_int_vec.value[0] % 2 != 0))
										pinst->v_OUT.value.valueunion.val_int_vec.value[0]--;
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 21:	//SINGLE_VEC
					pinst->v_OUT.value.vartype = OV_VT_SINGLE_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_single_vec, 1, SINGLE)))
						pinst->v_OUT.value.valueunion.val_single_vec.value[0] = pinst->v_IN.value.valueunion.val_single;
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 22:	//DOUBLE_VEC
					pinst->v_OUT.value.vartype = OV_VT_DOUBLE_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_double_vec, 1, DOUBLE)))
						pinst->v_OUT.value.valueunion.val_double_vec.value[0] = pinst->v_IN.value.valueunion.val_single;
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 23:	//STRING_VEC
					pinst->v_OUT.value.vartype = OV_VT_STRING_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_string_vec, 1, STRING)))
					{
						if(Ov_Fail(ov_string_print(&pinst->v_OUT.value.valueunion.val_string_vec.value[0], "%f", pinst->v_IN.value.valueunion.val_single)))
						{
							ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
							return;
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 24:	//TIME_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_vec, 1, TIME)))
					{
						if(pinst->v_IN.value.valueunion.val_single >= 0)
						{			
							if(pinst->v_IN.value.valueunion.val_single > (float) OV_VL_MAXUINT)	
								ov_logfile_error("%s: value exceeds range of time", pinst->v_identifier);
							pinst->v_OUT.value.valueunion.val_time_vec.value[0].secs = (OV_UINT) pinst->v_IN.value.valueunion.val_single;	
							pinst->v_OUT.value.valueunion.val_time_vec.value[0].usecs = (OV_UINT)
								((pinst->v_IN.value.valueunion.val_single - pinst->v_OUT.value.valueunion.val_time_vec.value[0].secs) * 1000000);	//subtracting seconds and converting to microseconds
						}
					else
						ov_logfile_error("%s: trying to convert negative value to time, this is not possible", pinst->v_identifier);
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 25:	//TIME_SPAN_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_span_vec, 1, TIME_SPAN)))
					{
						if(pinst->v_IN.value.valueunion.val_single > (float) OV_VL_MAXINT || pinst->v_IN.value.valueunion.val_single < -(float) OV_VL_MAXINT)	
							ov_logfile_error("%s: value exceeds range of time_span", pinst->v_identifier);
						pinst->v_OUT.value.valueunion.val_time_span_vec.value[0].secs = (OV_INT) pinst->v_IN.value.valueunion.val_single;
						pinst->v_OUT.value.valueunion.val_time_span_vec.value[0].usecs = (OV_INT)
							((pinst->v_IN.value.valueunion.val_single - pinst->v_OUT.value.valueunion.val_time_span_vec.value[0].secs) * 1000000);	//subtracting seconds and converting to microseconds
							
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				default:
					ov_logfile_error("%s: conversion to specified datatype not implemented", pinst->v_identifier);
					pinst->v_OUT.value.vartype = OV_VT_BOOL;
					pinst->v_OUT.value.valueunion.val_bool = FALSE;
					return;
			}
		break;
		
		/******************************DOUBLE******************/
		
		case OV_VT_DOUBLE:
			switch(pinst->v_K)
			{
				case 2:		//BOOL
					pinst->v_OUT.value.vartype = OV_VT_BOOL;
					if(pinst->v_IN.value.valueunion.val_double)
						pinst->v_OUT.value.valueunion.val_bool = 1;
					else
						pinst->v_OUT.value.valueunion.val_bool = 0;
				break;
				
				case 3:		//UINT
					pinst->v_OUT.value.vartype = OV_VT_UINT;
					if(pinst->v_IN.value.valueunion.val_double >= 0)
					{
						if(pinst->v_IN.value.valueunion.val_double > OV_VL_MAXUINT)	
							ov_logfile_error("%s: value exceeds range of unsigned int", pinst->v_identifier);
						pinst->v_OUT.value.valueunion.val_uint = (OV_UINT) pinst->v_IN.value.valueunion.val_double;
						if((pinst->v_IN.value.valueunion.val_double - pinst->v_OUT.value.valueunion.val_uint) > 0.5)		//round up
							pinst->v_OUT.value.valueunion.val_uint++;
						else
							if(((pinst->v_IN.value.valueunion.val_double - pinst->v_OUT.value.valueunion.val_uint) == 0.5) && (pinst->v_OUT.value.valueunion.val_uint % 2 != 0))	//round up, if this is even
								pinst->v_OUT.value.valueunion.val_uint++;
					}
					else
						ov_logfile_error("%s: trying to convert engative value to unsigned integer", pinst->v_identifier);
				break;
				
				case 4:		//INT
					pinst->v_OUT.value.vartype = OV_VT_INT;
					if(pinst->v_IN.value.valueunion.val_double > OV_VL_MAXINT)	
							ov_logfile_error("%s: value exceeds range of int", pinst->v_identifier);
					pinst->v_OUT.value.valueunion.val_int = (OV_INT) pinst->v_IN.value.valueunion.val_double;
					if((pinst->v_IN.value.valueunion.val_double - pinst->v_OUT.value.valueunion.val_int) > 0.5)		//round up
						pinst->v_OUT.value.valueunion.val_int++;
					else
						if((pinst->v_IN.value.valueunion.val_double - pinst->v_OUT.value.valueunion.val_int) < -0.5)		//round down
							pinst->v_OUT.value.valueunion.val_int--;
						else
							if(((pinst->v_IN.value.valueunion.val_double - pinst->v_OUT.value.valueunion.val_int) == 0.5) && (pinst->v_OUT.value.valueunion.val_int % 2 != 0))	//round up, if this is even
								pinst->v_OUT.value.valueunion.val_int++;
							else
								if(((pinst->v_IN.value.valueunion.val_double - pinst->v_OUT.value.valueunion.val_int) == -0.5) && (pinst->v_OUT.value.valueunion.val_int % 2 != 0))
									pinst->v_OUT.value.valueunion.val_int--;
				break;
				
				case 5:		//SINGLE
					pinst->v_OUT.value.vartype = OV_VT_SINGLE;
					if(pinst->v_IN.value.valueunion.val_double <= FLT_MAX)
						pinst->v_OUT.value.valueunion.val_single = (OV_SINGLE) pinst->v_IN.value.valueunion.val_double;
					else
						ov_logfile_error("%s: value exceeds range of single", pinst->v_identifier);
				break;
				
				case 6:		//DOUBLE
					pinst->v_OUT.value.vartype = OV_VT_DOUBLE;
					pinst->v_OUT.value.valueunion.val_double = pinst->v_IN.value.valueunion.val_double;
				break;
				
				case 7:		//STRING
					pinst->v_OUT.value.vartype = OV_VT_STRING;
					if(Ov_Fail(ov_string_print(&pinst->v_OUT.value.valueunion.val_string, "%f", pinst->v_IN.value.valueunion.val_double)))
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 8:		//TIME
					pinst->v_OUT.value.vartype = OV_VT_TIME;
					if(pinst->v_IN.value.valueunion.val_double >= 0)
					{			
						if(pinst->v_IN.value.valueunion.val_double > (double) OV_VL_MAXUINT)	
							ov_logfile_error("%s: value exceeds range of time", pinst->v_identifier);
						pinst->v_OUT.value.valueunion.val_time.secs = (OV_UINT) pinst->v_IN.value.valueunion.val_double;	
						pinst->v_OUT.value.valueunion.val_time.usecs = (OV_UINT) ((pinst->v_IN.value.valueunion.val_double - pinst->v_OUT.value.valueunion.val_time.secs) * 1000000);	//subtracting seconds and converting to microseconds
					}
					else
						ov_logfile_error("%s: trying to convert negative value to time, this is not possible", pinst->v_identifier);
				break;
				
				case 9:		//TIME_SPAN
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN;
					if(pinst->v_IN.value.valueunion.val_double > (double) OV_VL_MAXINT || pinst->v_IN.value.valueunion.val_double < -(double) OV_VL_MAXINT)	
							ov_logfile_error("%s: value exceeds range of time_span", pinst->v_identifier);
					pinst->v_OUT.value.valueunion.val_time_span.secs = (OV_INT) pinst->v_IN.value.valueunion.val_double;
					pinst->v_OUT.value.valueunion.val_time_span.usecs = (OV_INT) ((pinst->v_IN.value.valueunion.val_double - pinst->v_OUT.value.valueunion.val_time_span.secs) * 1000000);
					
				break;
				
				case 17:	//BYTE_VEC		byte vector with length of 8  represents a QWORD
					pinst->v_OUT.value.vartype = OV_VT_BYTE_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_byte_vec, sizeof(double) / sizeof(char), BYTE)))
					{
						*(double *)pinst->v_OUT.value.valueunion.val_byte_vec.value = pinst->v_IN.value.valueunion.val_double;		//8 bytes are one double, bitwise transfer, no memory problems unless size of uint is changed
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
					
				break;
				
				case 18:	//BOOL_VEC
					pinst->v_OUT.value.vartype = OV_VT_BOOL_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_bool_vec, 1, BOOL)))
					{
						if(pinst->v_IN.value.valueunion.val_double)
							pinst->v_OUT.value.valueunion.val_bool_vec.value[0] = 1;
						else
							pinst->v_OUT.value.valueunion.val_bool_vec.value[0] = 0;
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 19:	//UINT_VEC
					pinst->v_OUT.value.vartype = OV_VT_UINT_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_uint_vec, 1, UINT)))
					{
						if(pinst->v_IN.value.valueunion.val_double >= 0)
						{
							if(pinst->v_IN.value.valueunion.val_double > OV_VL_MAXUINT)	
								ov_logfile_error("%s: value exceeds range of unsigned int", pinst->v_identifier);
							pinst->v_OUT.value.valueunion.val_uint_vec.value[0] = (OV_UINT) pinst->v_IN.value.valueunion.val_double;
							if((pinst->v_IN.value.valueunion.val_double - pinst->v_OUT.value.valueunion.val_uint_vec.value[0]) > 0.5)		//round up
								pinst->v_OUT.value.valueunion.val_uint++;
							else
								if(((pinst->v_IN.value.valueunion.val_double - pinst->v_OUT.value.valueunion.val_uint_vec.value[0]) == 0.5) && (pinst->v_OUT.value.valueunion.val_uint_vec.value[0] % 2 != 0))	//round up, if this is even
									pinst->v_OUT.value.valueunion.val_uint++;
						}
					else
						ov_logfile_error("%s: trying to convert engative value to unsigned integer", pinst->v_identifier);
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 20:	//INT_VEC
					pinst->v_OUT.value.vartype = OV_VT_INT_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_int_vec, 1, INT)))
					{
						if(pinst->v_IN.value.valueunion.val_double > OV_VL_MAXINT)	
							ov_logfile_error("%s: value exceeds range of int", pinst->v_identifier);
						pinst->v_OUT.value.valueunion.val_int_vec.value[0] = (OV_INT) pinst->v_IN.value.valueunion.val_double;
						if((pinst->v_IN.value.valueunion.val_double - pinst->v_OUT.value.valueunion.val_int_vec.value[0]) > 0.5)		//round up
							pinst->v_OUT.value.valueunion.val_int_vec.value[0]++;
						else
							if((pinst->v_IN.value.valueunion.val_double - pinst->v_OUT.value.valueunion.val_int_vec.value[0]) < -0.5)		//round down
								pinst->v_OUT.value.valueunion.val_int_vec.value[0]--;
							else
								if(((pinst->v_IN.value.valueunion.val_double - pinst->v_OUT.value.valueunion.val_int_vec.value[0]) == 0.5) && (pinst->v_OUT.value.valueunion.val_int_vec.value[0] % 2 != 0))	//round up, if this is even
									pinst->v_OUT.value.valueunion.val_int_vec.value[0]++;
								else
									if(((pinst->v_IN.value.valueunion.val_double - pinst->v_OUT.value.valueunion.val_int_vec.value[0]) == -0.5) && (pinst->v_OUT.value.valueunion.val_int_vec.value[0] % 2 != 0))
										pinst->v_OUT.value.valueunion.val_int_vec.value[0]--;
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 21:	//SINGLE_VEC
					pinst->v_OUT.value.vartype = OV_VT_SINGLE_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_single_vec, 1, SINGLE)))
						pinst->v_OUT.value.valueunion.val_single_vec.value[0] = (OV_SINGLE) pinst->v_IN.value.valueunion.val_double;
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
					if(pinst->v_IN.value.valueunion.val_double > FLT_MAX)
						ov_logfile_error("%s: value exceeds range of single", pinst->v_identifier);
				break;
				
				case 22:	//DOUBLE_VEC
					pinst->v_OUT.value.vartype = OV_VT_DOUBLE_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_double_vec, 1, DOUBLE)))
						pinst->v_OUT.value.valueunion.val_double_vec.value[0] = pinst->v_IN.value.valueunion.val_double;
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 23:	//STRING_VEC
					pinst->v_OUT.value.vartype = OV_VT_STRING_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_string_vec, 1, STRING)))
					{
						if(Ov_Fail(ov_string_print(&pinst->v_OUT.value.valueunion.val_string_vec.value[0], "%f", pinst->v_IN.value.valueunion.val_double)))
						{
							ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
							return;
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 24:	//TIME_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_vec, 1, TIME)))
					{
						if(pinst->v_IN.value.valueunion.val_double >= 0)
						{			
							if(pinst->v_IN.value.valueunion.val_double > (float) OV_VL_MAXUINT)	
								ov_logfile_error("%s: value exceeds range of time", pinst->v_identifier);
							pinst->v_OUT.value.valueunion.val_time_vec.value[0].secs = (OV_UINT) pinst->v_IN.value.valueunion.val_double;	
							pinst->v_OUT.value.valueunion.val_time_vec.value[0].usecs = (OV_UINT)
								((pinst->v_IN.value.valueunion.val_double - pinst->v_OUT.value.valueunion.val_time_vec.value[0].secs) * 1000000);	
						}
					else
						ov_logfile_error("%s: trying to convert negative value to time, this is not possible", pinst->v_identifier);
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 25:	//TIME_SPAN_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_span_vec, 1, TIME_SPAN)))
					{
						if(pinst->v_IN.value.valueunion.val_double > (float) OV_VL_MAXINT || pinst->v_IN.value.valueunion.val_double < -(float) OV_VL_MAXINT)	
							ov_logfile_error("%s: value exceeds range of time_span", pinst->v_identifier);
						pinst->v_OUT.value.valueunion.val_time_span_vec.value[0].secs = (OV_INT) pinst->v_IN.value.valueunion.val_double;	
						pinst->v_OUT.value.valueunion.val_time_span_vec.value[0].usecs = (OV_INT)
							((pinst->v_IN.value.valueunion.val_double - pinst->v_OUT.value.valueunion.val_time_span_vec.value[0].secs) * 1000000);	
						
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				default:
					ov_logfile_error("%s: conversion to specified datatype not implemented", pinst->v_identifier);
					pinst->v_OUT.value.vartype = OV_VT_BOOL;
					pinst->v_OUT.value.valueunion.val_bool = FALSE;
					return;
			}
		break;
		
				/******************************STRING******************/
		
		case OV_VT_STRING:
			switch(pinst->v_K)
			{
				case 1:		//BYTE
					pinst->v_OUT.value.vartype = OV_VT_BYTE;
					pinst->v_OUT.value.valueunion.val_byte = pinst->v_IN.value.valueunion.val_string[0];
				break;
				
				case 2:		//BOOL
					pinst->v_OUT.value.vartype = OV_VT_BOOL;
					if(ov_string_getlength(pinst->v_IN.value.valueunion.val_string))
						pinst->v_OUT.value.valueunion.val_bool = TRUE;
					else
						pinst->v_OUT.value.valueunion.val_bool = FALSE;
				break;
				
				case 3:		//UINT
					pinst->v_OUT.value.vartype = OV_VT_UINT;
					pinst->v_OUT.value.valueunion.val_uint = strtoul(pinst->v_IN.value.valueunion.val_string, NULL, 10);
				break;
				
				case 4:		//INT
					pinst->v_OUT.value.vartype = OV_VT_INT;
					pinst->v_OUT.value.valueunion.val_int = strtol(pinst->v_IN.value.valueunion.val_string, NULL, 10);
				break;
				
				case 5:		//SINGLE
					pinst->v_OUT.value.vartype = OV_VT_SINGLE;
					pinst->v_OUT.value.valueunion.val_single = (OV_SINGLE) strtod(pinst->v_IN.value.valueunion.val_string, NULL);
				break;
				
				case 6:		//DOUBLE
					pinst->v_OUT.value.vartype = OV_VT_DOUBLE;
					pinst->v_OUT.value.valueunion.val_double = strtod(pinst->v_IN.value.valueunion.val_string, NULL);
				break;
				
				case 7:		//STRING
					pinst->v_OUT.value.vartype = OV_VT_STRING;
					if(Ov_Fail(ov_string_setvalue(&pinst->v_OUT.value.valueunion.val_string, pinst->v_IN.value.valueunion.val_string)))
					{
						ov_logfile_error("%s: memory allocation failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 8:		//TIME
					pinst->v_OUT.value.vartype = OV_VT_TIME;
					pinst->v_OUT.value.valueunion.val_time.secs = 0;
					pinst->v_OUT.value.valueunion.val_time.usecs = 0;
					if(Ov_Fail(ov_time_asciitotime(&pinst->v_OUT.value.valueunion.val_time, pinst->v_IN.value.valueunion.val_string)))
					{
						ov_logfile_error("%s: converting string to time failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 9:		//TIME_SPAN
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN;
					d_temp = strtod(pinst->v_IN.value.valueunion.val_string, NULL);
					pinst->v_OUT.value.valueunion.val_time_span.secs = (OV_INT) d_temp;
					pinst->v_OUT.value.valueunion.val_time_span.usecs = (OV_INT) ((d_temp - pinst->v_OUT.value.valueunion.val_time_span.secs) * 1000000);
					
				break;
				
				case 17:	//BYTE_VEC
					pinst->v_OUT.value.vartype = OV_VT_BYTE_VEC;
					length = ov_string_getlength(pinst->v_IN.value.valueunion.val_string);
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_byte_vec, length, BYTE)))
					{
						for(i=0; i < length; i++)
							pinst->v_OUT.value.valueunion.val_byte_vec.value[i] = pinst->v_IN.value.valueunion.val_string[i];
					}
					else
					{
						ov_logfile_error("%s: memory allocation failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 18:	//BOOL_VEC
					pinst->v_OUT.value.vartype = OV_VT_BOOL_VEC;
					if(Ov_Fail(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_bool_vec, 1, BOOL)))
					{
						ov_logfile_error("%s: memory allocation failed, no operation performed", pinst->v_identifier);
						return;
					}
					if(ov_string_getlength(pinst->v_IN.value.valueunion.val_string))
						pinst->v_OUT.value.valueunion.val_bool_vec.value[0] = TRUE;
					else
						pinst->v_OUT.value.valueunion.val_bool_vec.value[0] = FALSE;
				break;
				
				case 19:	//UINT_VEC
					pinst->v_OUT.value.vartype = OV_VT_UINT_VEC;
					i = 1;
					c_temp = pinst->v_IN.value.valueunion.val_string;
					while(i)
					{
						if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_uint_vec, i, UINT)))
						{
							pinst->v_OUT.value.valueunion.val_uint_vec.value[i-1] = strtoul(c_temp, &c_temp, 10);
							if(c_temp)	//skip whitespaces
								while(*c_temp == ' ' || *c_temp == '\t')
									c_temp += sizeof(char);
									
							if(pinst->v_OUT.value.valueunion.val_uint_vec.value[i-1] && *c_temp == ';')	//read next integer, if values are divided by ';'
							{
								i++;
								c_temp += sizeof(char);
							}
							else
							{
								i = 0;
								break;
							}
						}
						else
						{
							ov_logfile_error("%s: memory allocation failed, no operation performed", pinst->v_identifier);
							return;
						}
						
					}
				break;
				
				case 20:	//INT_VEC
					pinst->v_OUT.value.vartype = OV_VT_INT_VEC;
					i = 1;
					c_temp = pinst->v_IN.value.valueunion.val_string;
					while(i)
					{
						if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_int_vec, i, INT)))
						{
							pinst->v_OUT.value.valueunion.val_int_vec.value[i-1] = strtol(c_temp, &c_temp, 10);
							if(c_temp)	//skip whitespaces
								while(*c_temp == ' ' || *c_temp == '\t')
									c_temp += sizeof(char);
							if(pinst->v_OUT.value.valueunion.val_int_vec.value[i-1] && *c_temp == ';')	//read next integer, if values are divided by ',', '.', '|', ';' or ':'
							{
								i++;
								c_temp += sizeof(char);
							}
							else
							{
								i = 0;
								break;
							}
						}
						else
						{
							ov_logfile_error("%s: memory allocation failed, no operation performed", pinst->v_identifier);
							return;
						}
						
					}
				break;
				
				case 21:	//SINGLE_VEC
					pinst->v_OUT.value.vartype = OV_VT_SINGLE_VEC;
					i = 1;
					c_temp = pinst->v_IN.value.valueunion.val_string;
					while(i)
					{
						if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_single_vec, i, SINGLE)))
						{
							pinst->v_OUT.value.valueunion.val_single_vec.value[i-1] = (OV_SINGLE) strtod(c_temp, &c_temp);
							if(c_temp)	//skip whitespaces
								while(*c_temp == ' ' || *c_temp == '\t')
									c_temp += sizeof(char);
							if(pinst->v_OUT.value.valueunion.val_single_vec.value[i-1] && *c_temp == ';')	//read next integer, if values are divided by ',', '.', '|', ';' or ':'
							{
								i++;
								c_temp += sizeof(char);
							}
							else
							{
								i = 0;
								break;
							}
						}
						else
						{
							ov_logfile_error("%s: memory allocation failed, no operation performed", pinst->v_identifier);
							return;
						}
						
					}
				break;
				
				case 22:	//DOUBLE_VEC
					pinst->v_OUT.value.vartype = OV_VT_DOUBLE_VEC;
					i = 1;
					c_temp = pinst->v_IN.value.valueunion.val_string;
					while(i)
					{
						if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_double_vec, i, DOUBLE)))
						{
							pinst->v_OUT.value.valueunion.val_double_vec.value[i-1] = strtod(c_temp, &c_temp);
							if(c_temp)	//skip whitespaces
								while(*c_temp == ' ' || *c_temp == '\t')
									c_temp += sizeof(char);
							if(pinst->v_OUT.value.valueunion.val_double_vec.value[i-1] && *c_temp == ';')	//read next integer, if values are divided by ',', '.', '|', ';' or ':'
							{
								i++;
								c_temp += sizeof(char);
							}
							else
							{
								i = 0;
								break;
							}
						}
						else
						{
							ov_logfile_error("%s: memory allocation failed, no operation performed", pinst->v_identifier);
							return;
						}
						
					}
				break;
				
				case 23:	//STRING_VEC
					pinst->v_OUT.value.vartype = OV_VT_STRING_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_string_vec, 1, STRING)))
					{
						if(Ov_Fail(ov_string_setvalue(&pinst->v_OUT.value.valueunion.val_string_vec.value[0], pinst->v_IN.value.valueunion.val_string)))
						{
							ov_logfile_error("%s: memory allocation failed, no operation performed", pinst->v_identifier);
							return;
						}
					}
					else
					{
						ov_logfile_error("%s: memory allocation failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 24:	//TIME_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_vec, 1, TIME)))
					{
						pinst->v_OUT.value.valueunion.val_time_vec.value[0].secs = 0;
						pinst->v_OUT.value.valueunion.val_time_vec.value[0].usecs = 0;
						if(Ov_Fail(ov_time_asciitotime(&pinst->v_OUT.value.valueunion.val_time_vec.value[0], pinst->v_IN.value.valueunion.val_string)))
						{
							ov_logfile_error("%s: converting string to time_vec failed, no operation performed", pinst->v_identifier);
							return;
						}
					}
					else
					{
						ov_logfile_error("%s: memory allocation failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 25:	//TIME_SPAN_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_span_vec, 1, TIME_SPAN)))
					{
						d_temp = strtod(pinst->v_IN.value.valueunion.val_string, NULL);
						pinst->v_OUT.value.valueunion.val_time_span_vec.value[0].secs = (OV_INT) d_temp;
						pinst->v_OUT.value.valueunion.val_time_span_vec.value[0].usecs = (OV_INT) ((d_temp - pinst->v_OUT.value.valueunion.val_time_span.secs) * 1000000);
						
					}
				break;
				
				default:
					ov_logfile_error("%s: conversion to specified datatype not implemented", pinst->v_identifier);
					pinst->v_OUT.value.vartype = OV_VT_BOOL;
					pinst->v_OUT.value.valueunion.val_bool = FALSE;
					return;
			}
		break;
		
			/******************************TIME******************/
		
		case OV_VT_TIME:
			switch(pinst->v_K)
			{
				case 2:		//BOOL
					pinst->v_OUT.value.vartype = OV_VT_BOOL;
					if(pinst->v_IN.value.valueunion.val_time.secs || pinst->v_IN.value.valueunion.val_time.usecs)
						pinst->v_OUT.value.valueunion.val_bool = 1;
					else
						pinst->v_OUT.value.valueunion.val_bool = 0;
				break;
				
				case 3:		//UINT
					pinst->v_OUT.value.vartype = OV_VT_UINT;
					pinst->v_OUT.value.valueunion.val_uint = pinst->v_IN.value.valueunion.val_time.secs;
				break;
				
				case 4:		//INT
					pinst->v_OUT.value.vartype = OV_VT_INT;
					if(pinst->v_IN.value.valueunion.val_time.secs <= OV_VL_MAXINT)
						pinst->v_OUT.value.valueunion.val_int = pinst->v_IN.value.valueunion.val_time.secs;
					else
					{
						ov_logfile_error("%s: value exceeds range of int", pinst->v_identifier);
						pinst->v_OUT.value.valueunion.val_int = 0;
					}
				break;
				
				case 5:		//SINGLE		treated as seconds
					pinst->v_OUT.value.vartype = OV_VT_SINGLE;
					pinst->v_OUT.value.valueunion.val_single = (float) pinst->v_IN.value.valueunion.val_time.secs * 1000000;
					pinst->v_OUT.value.valueunion.val_single += (float) pinst->v_IN.value.valueunion.val_time.usecs;
					pinst->v_OUT.value.valueunion.val_single /= 1000000;
				break;
				
				case 6:		//DOUBLE
					pinst->v_OUT.value.vartype = OV_VT_DOUBLE;
					pinst->v_OUT.value.valueunion.val_double = (double) pinst->v_IN.value.valueunion.val_time.secs * 1000000;
					pinst->v_OUT.value.valueunion.val_double += (double) pinst->v_IN.value.valueunion.val_time.usecs;
					pinst->v_OUT.value.valueunion.val_double /= 1000000;
				break;
				
				case 7:		//STRING
					pinst->v_OUT.value.vartype = OV_VT_STRING;
					c_temp = ov_time_timetoascii(&pinst->v_IN.value.valueunion.val_time);
					if(Ov_Fail(ov_string_setvalue(&pinst->v_OUT.value.valueunion.val_string, c_temp)))
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 8:		//TIME
					pinst->v_OUT.value.vartype = OV_VT_TIME;
					pinst->v_OUT.value.valueunion.val_time = pinst->v_IN.value.valueunion.val_time;
				break;
				
				case 9:		//TIME_SPAN
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN;
					pinst->v_OUT.value.valueunion.val_time_span.secs = pinst->v_IN.value.valueunion.val_time.secs;
					pinst->v_OUT.value.valueunion.val_time_span.usecs = pinst->v_IN.value.valueunion.val_time.usecs;
					if(pinst->v_IN.value.valueunion.val_time.secs > OV_VL_MAXINT)
						ov_logfile_error("%s: value exceeds range", pinst->v_identifier);
				break;
				
				case 18:	//BOOL_VEC
					pinst->v_OUT.value.vartype = OV_VT_BOOL_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_bool_vec, 1, BOOL)))
					{
						if(pinst->v_IN.value.valueunion.val_time.secs || pinst->v_IN.value.valueunion.val_time.usecs)
							pinst->v_OUT.value.valueunion.val_bool_vec.value[0] = 1;
						else
							pinst->v_OUT.value.valueunion.val_bool_vec.value[0] = 0;
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 19:	//UINT_VEC
					pinst->v_OUT.value.vartype = OV_VT_UINT_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_uint_vec, 2, UINT)))
					{
						pinst->v_OUT.value.valueunion.val_uint_vec.value[0] = pinst->v_IN.value.valueunion.val_time.secs;
						pinst->v_OUT.value.valueunion.val_uint_vec.value[1] = pinst->v_IN.value.valueunion.val_time.usecs;
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 20:	//INT_VEC
					pinst->v_OUT.value.vartype = OV_VT_INT_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_int_vec, 2, INT)))
					{
						if(pinst->v_IN.value.valueunion.val_time.secs <= OV_VL_MAXINT)
						{
							pinst->v_OUT.value.valueunion.val_int_vec.value[0] = pinst->v_IN.value.valueunion.val_time.secs;
							pinst->v_OUT.value.valueunion.val_int_vec.value[1] = pinst->v_IN.value.valueunion.val_time.usecs;
						}
						else
						{
							pinst->v_OUT.value.valueunion.val_int_vec.value[0] = 0;
							ov_logfile_error("%s: value exceeds range of int", pinst->v_identifier);
						}
						
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 21:	//SINGLE_VEC
					pinst->v_OUT.value.vartype = OV_VT_SINGLE_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_single_vec, 1, SINGLE)))
					{
						pinst->v_OUT.value.valueunion.val_single_vec.value[0] = (float)pinst->v_IN.value.valueunion.val_time.secs * 1000000;
						pinst->v_OUT.value.valueunion.val_single_vec.value[0] += (float) pinst->v_IN.value.valueunion.val_time.usecs;
						pinst->v_OUT.value.valueunion.val_single_vec.value[0] /= 1000000;
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 22:	//DOUBLE_VEC
					pinst->v_OUT.value.vartype = OV_VT_DOUBLE_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_double_vec, 1, DOUBLE)))
					{
						pinst->v_OUT.value.valueunion.val_double_vec.value[0] = (double) pinst->v_IN.value.valueunion.val_time.secs * 1000000;
						pinst->v_OUT.value.valueunion.val_double_vec.value[0] += (double) pinst->v_IN.value.valueunion.val_time.usecs ;
						pinst->v_OUT.value.valueunion.val_double_vec.value[0] /= 1000000;
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 23:	//STRING_VEC
					pinst->v_OUT.value.vartype = OV_VT_STRING_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_string_vec, 1, STRING)))
					{
						c_temp = ov_time_timetoascii(&pinst->v_IN.value.valueunion.val_time);
						if(Ov_Fail(ov_string_setvalue(&(pinst->v_OUT.value.valueunion.val_string_vec.value[0]), c_temp)))
						{
							ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
							return;
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 24:	//TIME_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_vec, 1, TIME)))
					{
						pinst->v_OUT.value.valueunion.val_time_vec.value[0] = pinst->v_IN.value.valueunion.val_time;
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 25:	//TIME_SPAN_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_span_vec, 1, TIME_SPAN)))
					{
						pinst->v_OUT.value.valueunion.val_time_span_vec.value[0].secs = pinst->v_IN.value.valueunion.val_time.secs;
						if(pinst->v_IN.value.valueunion.val_time.secs > OV_VL_MAXINT)
							ov_logfile_error("%s: value exceeds range", pinst->v_identifier);
						pinst->v_OUT.value.valueunion.val_time_span_vec.value[0].usecs = pinst->v_IN.value.valueunion.val_time.usecs;
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				default:
					ov_logfile_error("%s: conversion to specified datatype not implemented", pinst->v_identifier);
					pinst->v_OUT.value.vartype = OV_VT_BOOL;
					pinst->v_OUT.value.valueunion.val_bool = FALSE;
					return;
			}
		break;
		
			/******************************TIME_SPAN******************/
		
		case OV_VT_TIME_SPAN:
			switch(pinst->v_K)
			{
				case 2:		//BOOL
					pinst->v_OUT.value.vartype = OV_VT_BOOL;
					if(pinst->v_IN.value.valueunion.val_time_span.secs || pinst->v_IN.value.valueunion.val_time_span.usecs)
						pinst->v_OUT.value.valueunion.val_bool = 1;
					else
						pinst->v_OUT.value.valueunion.val_bool = 0;
				break;
				
				case 3:		//UINT
					pinst->v_OUT.value.vartype = OV_VT_UINT;
					if(pinst->v_IN.value.valueunion.val_time_span.secs >= 0)
						pinst->v_OUT.value.valueunion.val_uint = pinst->v_IN.value.valueunion.val_time_span.secs;
					else
					{
						pinst->v_OUT.value.valueunion.val_time_span.secs = 0;
						ov_logfile_error("%s: value exceeds range of unsigned int", pinst->v_identifier);
					}
				break;
				
				case 4:		//INT
					pinst->v_OUT.value.vartype = OV_VT_INT;
					pinst->v_OUT.value.valueunion.val_int = pinst->v_IN.value.valueunion.val_time_span.secs;
				break;
				
				case 5:		//SINGLE
					pinst->v_OUT.value.vartype = OV_VT_SINGLE;
					pinst->v_OUT.value.valueunion.val_single = (float) pinst->v_IN.value.valueunion.val_time_span.secs * 1000000;
					pinst->v_OUT.value.valueunion.val_single += (float) pinst->v_IN.value.valueunion.val_time_span.usecs;
					pinst->v_OUT.value.valueunion.val_single /= 1000000;
				break;
				
				case 6:		//DOUBLE
					pinst->v_OUT.value.vartype = OV_VT_DOUBLE;
					pinst->v_OUT.value.valueunion.val_double = (double) pinst->v_IN.value.valueunion.val_time_span.secs * 1000000;
					pinst->v_OUT.value.valueunion.val_double += (double) pinst->v_IN.value.valueunion.val_time_span.usecs;
					pinst->v_OUT.value.valueunion.val_double /= 1000000;
				break;
				
				case 7:		//STRING
					pinst->v_OUT.value.vartype = OV_VT_STRING;
					d_temp = (double) pinst->v_IN.value.valueunion.val_time_span.secs * 1000000;
					d_temp += (double) pinst->v_IN.value.valueunion.val_time_span.usecs;
					d_temp /= 1000000;
					if(Ov_Fail(ov_string_print(&pinst->v_OUT.value.valueunion.val_string, 
						"%f", d_temp)))
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 8:		//TIME
					pinst->v_OUT.value.vartype = OV_VT_TIME;
					pinst->v_OUT.value.valueunion.val_time.secs = pinst->v_IN.value.valueunion.val_time_span.secs;
					pinst->v_OUT.value.valueunion.val_time.usecs = pinst->v_IN.value.valueunion.val_time_span.usecs;
					
				break;
				
				case 9:		//TIME_SPAN
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN;
					pinst->v_OUT.value.valueunion.val_time_span = pinst->v_IN.value.valueunion.val_time_span;
				break;
				
				case 18:	//BOOL_VEC
						pinst->v_OUT.value.vartype = OV_VT_BOOL_VEC;
						if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_bool_vec, 1, BOOL)))
						{
							if(pinst->v_IN.value.valueunion.val_time_span.secs || pinst->v_IN.value.valueunion.val_time_span.usecs)
								pinst->v_OUT.value.valueunion.val_bool_vec.value[0] = 1;
							else
							pinst->v_OUT.value.valueunion.val_bool_vec.value[0] = 0;
						}
						else
						{
							ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
							return;
						}
						
				break;
				
				case 19:	//UINT_VEC
					pinst->v_OUT.value.vartype = OV_VT_UINT_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_uint_vec, 2, UINT)))
					{
						if(pinst->v_IN.value.valueunion.val_time_span.secs >= 0)
						{
							pinst->v_OUT.value.valueunion.val_uint_vec.value[0] = pinst->v_IN.value.valueunion.val_time_span.secs;
							pinst->v_OUT.value.valueunion.val_uint_vec.value[1] = pinst->v_IN.value.valueunion.val_time_span.usecs;
						}
						else
						{
							pinst->v_OUT.value.valueunion.val_uint_vec.value[0] = 0;
							pinst->v_OUT.value.valueunion.val_uint_vec.value[1] = 0;
							ov_logfile_error("%s: trying to convert negative time span to uint", pinst->v_identifier);
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 20:	//INT_VEC
					pinst->v_OUT.value.vartype = OV_VT_INT_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_int_vec, 2, INT)))
					{
						pinst->v_OUT.value.valueunion.val_int_vec.value[0] = pinst->v_IN.value.valueunion.val_time_span.secs;
						pinst->v_OUT.value.valueunion.val_int_vec.value[1] = pinst->v_IN.value.valueunion.val_time_span.usecs;
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}

				break;
				
				case 21:	//SINGLE_VEC
					pinst->v_OUT.value.vartype = OV_VT_SINGLE_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_single_vec, 1, SINGLE)))
					{
						pinst->v_OUT.value.valueunion.val_single_vec.value[0] = (float)pinst->v_IN.value.valueunion.val_time_span.secs * 1000000;
						pinst->v_OUT.value.valueunion.val_single_vec.value[0] += (float) pinst->v_IN.value.valueunion.val_time_span.usecs;
						pinst->v_OUT.value.valueunion.val_single_vec.value[0] /= 1000000;
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 22:	//DOUBLE_VEC
					pinst->v_OUT.value.vartype = OV_VT_DOUBLE_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_double_vec, 1, DOUBLE)))
					{
						pinst->v_OUT.value.valueunion.val_double_vec.value[0] = (double) pinst->v_IN.value.valueunion.val_time_span.secs * 1000000;
						pinst->v_OUT.value.valueunion.val_double_vec.value[0] += (double) pinst->v_IN.value.valueunion.val_time_span.usecs ;
						pinst->v_OUT.value.valueunion.val_double_vec.value[0] /= 1000000;
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 23:	//STRING_VEC
					pinst->v_OUT.value.vartype = OV_VT_STRING_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_string_vec, 1, STRING)))
					{
						d_temp = (double) pinst->v_IN.value.valueunion.val_time_span.secs * 1000000;
						d_temp += (double) pinst->v_IN.value.valueunion.val_time_span.usecs;
						d_temp /= 1000000;
						if(Ov_Fail(ov_string_print(&pinst->v_OUT.value.valueunion.val_string_vec.value[0], 
							"%f", d_temp)))
						{
							ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
							return;
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 24:	//TIME_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_vec, 1, TIME)))
					{
						if(pinst->v_IN.value.valueunion.val_time_span.secs > 0)
						{
							pinst->v_OUT.value.valueunion.val_time_vec.value[0].secs = pinst->v_IN.value.valueunion.val_time_span.secs;
							pinst->v_OUT.value.valueunion.val_time_vec.value[0].usecs = pinst->v_IN.value.valueunion.val_time_span.usecs;
						}
						else
						{
							pinst->v_OUT.value.valueunion.val_time_vec.value[0].secs = 0;
							pinst->v_OUT.value.valueunion.val_time_vec.value[0].usecs = 0;
							ov_logfile_error("%s: trying to convert negative time span to time", pinst->v_identifier);
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 25:	//TIME_SPAN_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_span_vec, 1, TIME_SPAN)))
					{
						pinst->v_OUT.value.valueunion.val_time_span_vec.value[0] = pinst->v_IN.value.valueunion.val_time_span;
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				default:
					ov_logfile_error("%s: conversion to specified datatype not implemented", pinst->v_identifier);
					pinst->v_OUT.value.vartype = OV_VT_BOOL;
					pinst->v_OUT.value.valueunion.val_bool = FALSE;
					return;
			}
		break;
		
		
		
		/*Vectors**/
		
		/******************************BYTE_VEC******************/
		
		case OV_VT_BYTE_VEC:
			if(pinst->v_IN.value.valueunion.val_byte_vec.veclen)
			switch(pinst->v_K)
			{
				case 1:		//BYTE
					pinst->v_OUT.value.vartype = OV_VT_BYTE;
					pinst->v_OUT.value.valueunion.val_byte = pinst->v_IN.value.valueunion.val_byte_vec.value[0];
				break;
				
				case 2:		//BOOL
					STDFB_VEC_TO_BOOL(byte);
				break;
				
				case 3:		//UINT
					STDFB_VEC_TO_UINT(byte);
				break;
				
				case 4:		//INT
					STDFB_BYTE_VEC_TO(INT, int);
				break;
				
				case 5:		//SINGLE
					STDFB_BYTE_VEC_TO(SINGLE, single);
				break;
				
				case 6:		//DOUBLE
					STDFB_BYTE_VEC_TO(DOUBLE, double);
				break;
				
				case 7:		//STRING
					pinst->v_OUT.value.vartype = OV_VT_STRING;
					s_temp = (OV_STRING) ov_malloc((pinst->v_IN.value.valueunion.val_byte_vec.veclen + 1) * sizeof(char));
					if(s_temp)
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_byte_vec.veclen; i++)
							s_temp[i] = pinst->v_IN.value.valueunion.val_byte_vec.value[i];
						s_temp[i] = 0;
						if(Ov_Fail(ov_string_setvalue(&pinst->v_OUT.value.valueunion.val_string, s_temp)))
						{
							ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
							ov_free(s_temp);
							return;
						}
						ov_free(s_temp);
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 17:	//BYTE_VEC
						STDFB_VEC_TO_BYTE_VEC(BYTE, byte);
				break;
				
				case 18:	//BOOL_VEC
					STDFB_VEC_TO_BOOL_VEC(BYTE, byte);
				break;
				
				case 19:	//UINT_VEC
					STDFB_BYTE_VEC_TO_VEC(UINT, uint);
				break;
				
				case 20:	//INT_VEC
					STDFB_BYTE_VEC_TO_VEC(INT, int);
				break;
				
				case 21:	//SINGLE_VEC
					STDFB_BYTE_VEC_TO_VEC(SINGLE, single);
				break;
				
				case 22:	//DOUBLE_VEC
					STDFB_BYTE_VEC_TO_VEC(DOUBLE, double);
				break;
				
				case 23:	//STRING_VEC
					pinst->v_OUT.value.vartype = OV_VT_STRING_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_string_vec, 1, STRING)))
					{
						s_temp = (OV_STRING) ov_malloc((pinst->v_IN.value.valueunion.val_byte_vec.veclen + 1) * sizeof(char));
						if(s_temp)
						{
							for(i=0; i < pinst->v_IN.value.valueunion.val_byte_vec.veclen; i++)
								s_temp[i] = pinst->v_IN.value.valueunion.val_byte_vec.value[i];
							s_temp[i] = 0;
							if(Ov_Fail(ov_string_setvalue(&pinst->v_OUT.value.valueunion.val_string_vec.value[0], s_temp)))
							{
								ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
								ov_free(s_temp);
								return;
							}
							ov_free(s_temp);
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				default:
					ov_logfile_error("%s: conversion to specified datatype not implemented", pinst->v_identifier);
					pinst->v_OUT.value.vartype = OV_VT_BOOL;
					pinst->v_OUT.value.valueunion.val_bool = FALSE;
					return;
			}
			else
			{
				ov_logfile_error("%s: vectors of length 0 cannot be converted", pinst->v_identifier);
				pinst->v_OUT.value.vartype = OV_VT_BOOL;
				pinst->v_OUT.value.valueunion.val_bool = FALSE;
			}
		break;
		
			/******************************BOOL_VEC******************/
		
		case OV_VT_BOOL_VEC:
			if(pinst->v_IN.value.valueunion.val_bool_vec.veclen)
			switch(pinst->v_K)
			{
				case 2:		//BOOL
					STDFB_VEC_TO_BOOL(bool);
				break;
				
				case 3:		//UINT
					STDFB_VEC_TO_UINT(bool);
				break;
			
				case 17:	//BYTE_VEC
					pinst->v_OUT.value.vartype = OV_VT_BYTE_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_byte_vec, pinst->v_IN.value.valueunion.val_bool_vec.veclen, BYTE)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_bool_vec.veclen; i++)
							if(pinst->v_IN.value.valueunion.val_bool_vec.value[i])
								pinst->v_OUT.value.valueunion.val_byte_vec.value[i] = 1;
							else
								pinst->v_OUT.value.valueunion.val_byte_vec.value[i] = 0;
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 18:	//BOOL_VEC
					pinst->v_OUT.value.vartype = OV_VT_BOOL_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_bool_vec, pinst->v_IN.value.valueunion.val_bool_vec.veclen, BOOL)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_bool_vec.veclen; i++)
							pinst->v_OUT.value.valueunion.val_bool_vec.value[i] = pinst->v_IN.value.valueunion.val_bool_vec.value[i];
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				default:
					ov_logfile_error("%s: conversion to specified datatype not implemented", pinst->v_identifier);
					pinst->v_OUT.value.vartype = OV_VT_BOOL;
					pinst->v_OUT.value.valueunion.val_bool = FALSE;
					return;
			}
			else
			{
				ov_logfile_error("%s: vectors of length 0 cannot be converted", pinst->v_identifier);
				pinst->v_OUT.value.vartype = OV_VT_BOOL;
				pinst->v_OUT.value.valueunion.val_bool = FALSE;
			}
		break;
		
			/******************************UINT_VEC******************/
		
		case OV_VT_UINT_VEC:
			if(pinst->v_IN.value.valueunion.val_uint_vec.veclen)
			switch(pinst->v_K)
			{
				case 2:		//BOOL
					STDFB_VEC_TO_BOOL(uint);
				break;
				
				case 3:		//UINT
					STDFB_VEC_TO_UINT(uint);
				break;
				
				case 4:		//INT
					pinst->v_OUT.value.vartype = OV_VT_INT;
					if(pinst->v_IN.value.valueunion.val_uint_vec.value[0] <= OV_VL_MAXINT)
						pinst->v_OUT.value.valueunion.val_int = pinst->v_IN.value.valueunion.val_uint_vec.value[0];
					else
					{
						pinst->v_OUT.value.valueunion.val_int = 0;
						ov_logfile_error("%s: value exceeds range of int", pinst->v_identifier);
					}
				break;
				
				case 5:		//SINGLE
					pinst->v_OUT.value.vartype = OV_VT_SINGLE;
					pinst->v_OUT.value.valueunion.val_single = (OV_SINGLE) pinst->v_IN.value.valueunion.val_uint_vec.value[0];
					if(pinst->v_IN.value.valueunion.val_uint_vec.value[0] > 10000000)
						ov_logfile_warning("%s: converting large integer to single, possible loss of precision", pinst->v_identifier);
				break;
				
				case 6:		//DOUBLE
					pinst->v_OUT.value.vartype = OV_VT_DOUBLE;
					pinst->v_OUT.value.valueunion.val_double = pinst->v_IN.value.valueunion.val_uint_vec.value[0];
				break;
				
				case 7:		//STRING
					pinst->v_OUT.value.vartype = OV_VT_STRING;
					if(pinst->v_IN.value.valueunion.val_uint_vec.veclen)
						if(Ov_Fail(ov_string_print(&pinst->v_OUT.value.valueunion.val_string, "%u", pinst->v_IN.value.valueunion.val_uint_vec.value[0])))
						{
							ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
							return;

						}
				break;
				
				case 8:		//TIME
					pinst->v_OUT.value.vartype = OV_VT_TIME;
					if(pinst->v_IN.value.valueunion.val_uint_vec.veclen >= 2)
					{
						pinst->v_OUT.value.valueunion.val_time.secs = pinst->v_IN.value.valueunion.val_uint_vec.value[0];
						pinst->v_OUT.value.valueunion.val_time.usecs = pinst->v_IN.value.valueunion.val_uint_vec.value[1];
					}
					else
					{
						ov_logfile_error("%s: vector too short to be converted to time datatype", pinst->v_identifier);
					}
						
				break;
				
				case 9:		//TIME_SPAN
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN;
					if(pinst->v_IN.value.valueunion.val_uint_vec.veclen >= 2)
					{
						if(pinst->v_IN.value.valueunion.val_uint_vec.value[0] < OV_VL_MAXINT)
							pinst->v_OUT.value.valueunion.val_time_span.secs = pinst->v_IN.value.valueunion.val_uint_vec.value[0];
						else
							ov_logfile_error("%s: value excceds range", pinst->v_identifier);
						
						if(pinst->v_IN.value.valueunion.val_uint_vec.value[1] < OV_VL_MAXINT)
							pinst->v_OUT.value.valueunion.val_time_span.usecs = pinst->v_IN.value.valueunion.val_uint_vec.value[1];
						else
							ov_logfile_error("%s: value excceds range", pinst->v_identifier);
					}
					else
					{
						ov_logfile_error("%s: vector too short to be converted to time datatype", pinst->v_identifier);
					}
				break;
				
				case 17:	//BYTE_VEC
					STDFB_VEC_TO_BYTE_VEC(UINT, uint);
				break;
				
				case 18:	//BOOL_VEC
					STDFB_VEC_TO_BOOL_VEC(UINT, uint);
				break;
				
				case 19:	//UINT_VEC
					STDFB_AINT_VEC_TO_UINT_VEC(UINT, uint);
				break;
				
				case 20:	//INT_VEC
					STDFB_AINT_VEC_TO_INT_VEC(UINT, uint);
				break;
				
				case 21:	//SINGLE_VEC
					STDFB_AINT_VEC_TO_SINGLE_VEC(UINT, uint);
				break;
				
				case 22:	//DOUBLE_VEC
					STDFB_VEC_TO_DOUBLE_VEC(UINT, uint);
				break;
				
				case 23:	//STRING_VEC
					pinst->v_OUT.value.vartype = OV_VT_STRING_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_string_vec, pinst->v_IN.value.valueunion.val_uint_vec.veclen, STRING)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_uint_vec.veclen; i++)
							if(Ov_Fail(ov_string_print(&pinst->v_OUT.value.valueunion.val_string_vec.value[i], "%u", pinst->v_IN.value.valueunion.val_uint_vec.value[i])))
							{
								ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
								return;
							}
					}
					else	
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 24:	//TIME_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_VEC;
					length = pinst->v_IN.value.valueunion.val_uint_vec.veclen / 2;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_vec, length, TIME)))
					{
						for(i=0; i < length; i++)
						{
							pinst->v_OUT.value.valueunion.val_time_vec.value[i].secs = pinst->v_IN.value.valueunion.val_uint_vec.value[i * 2];
							pinst->v_OUT.value.valueunion.val_time_vec.value[i].usecs = pinst->v_IN.value.valueunion.val_uint_vec.value[i * 2 + 1];
						}
					}
					else	
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 25:	//TIME_SPAN_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN_VEC;
					length = pinst->v_IN.value.valueunion.val_uint_vec.veclen / 2;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_span_vec, length, TIME_SPAN)))
					{
						for(i=0; i < length; i++)
						{
							if(pinst->v_IN.value.valueunion.val_uint_vec.value[i * 2] < OV_VL_MAXINT)
								pinst->v_OUT.value.valueunion.val_time_span_vec.value[i].secs = pinst->v_IN.value.valueunion.val_uint_vec.value[i * 2];
							else
								ov_logfile_error("%s: value in element %d exceeds range", pinst->v_identifier, i * 2);
							if(pinst->v_IN.value.valueunion.val_uint_vec.value[i * 2 + 1] < OV_VL_MAXINT)
								pinst->v_OUT.value.valueunion.val_time_span_vec.value[i].usecs = pinst->v_IN.value.valueunion.val_uint_vec.value[i * 2 + 1];
							else
								ov_logfile_error("%s: value in element %d exceeds range", pinst->v_identifier, i * 2 + 1);
						}
					}
					else	
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				default:
					ov_logfile_error("%s: conversion to specified datatype not implemented", pinst->v_identifier);
					pinst->v_OUT.value.vartype = OV_VT_BOOL;
					pinst->v_OUT.value.valueunion.val_bool = FALSE;
					return;
			}
			else
			{
				ov_logfile_error("%s: vectors of length 0 cannot be converted", pinst->v_identifier);
				pinst->v_OUT.value.vartype = OV_VT_BOOL;
				pinst->v_OUT.value.valueunion.val_bool = FALSE;
			}
		break;
		
			/******************************INT_VEC******************/
		
		case OV_VT_INT_VEC:
			if(pinst->v_IN.value.valueunion.val_int_vec.veclen)
			switch(pinst->v_K)
			{
				
				case 2:		//BOOL
					STDFB_VEC_TO_BOOL(int);
				break;
				
				case 3:		//UINT
					STDFB_VEC_TO_UINT(int)
				break;
				
				case 4:		//INT
					pinst->v_OUT.value.vartype = OV_VT_INT;
					pinst->v_OUT.value.valueunion.val_int = pinst->v_IN.value.valueunion.val_int_vec.value[0];
				break;
				
				case 5:		//SINGLE
					pinst->v_OUT.value.vartype = OV_VT_SINGLE;
					pinst->v_OUT.value.valueunion.val_single = (OV_SINGLE) pinst->v_IN.value.valueunion.val_int_vec.value[0];
					if(pinst->v_IN.value.valueunion.val_int_vec.value[0] > 10000000 || pinst->v_IN.value.valueunion.val_int_vec.value[0] < -10000000)
						ov_logfile_warning("%s: converting large integer value to single, possible loss of precision", pinst->v_identifier);
				break;
				
				case 6:		//DOUBLE
					pinst->v_OUT.value.vartype = OV_VT_DOUBLE;
					pinst->v_OUT.value.valueunion.val_double = pinst->v_IN.value.valueunion.val_int_vec.value[0];
				break;
				
				case 7:		//STRING
					pinst->v_OUT.value.vartype = OV_VT_STRING;
					if(Ov_Fail(ov_string_print(&pinst->v_OUT.value.valueunion.val_string, "%d", pinst->v_IN.value.valueunion.val_int_vec.value[0])))
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 8:		//TIME
					pinst->v_OUT.value.vartype = OV_VT_TIME;
					if(pinst->v_IN.value.valueunion.val_int_vec.veclen >= 2)
					{
						if(pinst->v_IN.value.valueunion.val_int_vec.value[0] >=0 ) 
							pinst->v_OUT.value.valueunion.val_time.secs = pinst->v_IN.value.valueunion.val_int_vec.value[0];
						else
							ov_logfile_error("%s: value exceeds range of time", pinst->v_identifier);
						
						if(pinst->v_IN.value.valueunion.val_int_vec.value[1] >=0 ) 
							pinst->v_OUT.value.valueunion.val_time.usecs = pinst->v_IN.value.valueunion.val_int_vec.value[1];
						else
							ov_logfile_error("%s: value exceeds range of time", pinst->v_identifier);
					}
					else
						ov_logfile_error("%s: vector too short to be converted into time datatype", pinst->v_identifier);
				break;
				
				case 9:		//TIME_SPAN
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN;
					if(pinst->v_IN.value.valueunion.val_int_vec.veclen >= 2)
					{
						pinst->v_OUT.value.valueunion.val_time_span.secs = pinst->v_IN.value.valueunion.val_int_vec.value[0];
						pinst->v_OUT.value.valueunion.val_time_span.usecs = pinst->v_IN.value.valueunion.val_int_vec.value[1];
					}
					else
						ov_logfile_error("%s: vector too short to be converted into time datatype", pinst->v_identifier);
				break;
				
				case 17:	//BYTE_VEC
					STDFB_VEC_TO_BYTE_VEC(INT, int);
				break;
				
				case 18:	//BOOL_VEC
					STDFB_VEC_TO_BOOL_VEC(INT, int);
				break;
				
				case 19:	//UINT_VEC
					STDFB_AINT_VEC_TO_UINT_VEC(INT, int);
				break;
				
				case 20:	//INT_VEC
					STDFB_AINT_VEC_TO_INT_VEC(INT, int);
				break;
				
				case 21:	//SINGLE_VEC
					STDFB_AINT_VEC_TO_SINGLE_VEC(INT, int);
					if(pinst->v_IN.value.valueunion.val_int_vec.value[i] < -10000000)
						ov_logfile_warning("%s: converting large integer value in element %d to single, possible loss of precision", pinst->v_identifier, i);
				break;
				
				case 22:	//DOUBLE_VEC
					STDFB_VEC_TO_DOUBLE_VEC(INT, int);
				break;
				
				case 23:	//STRING_VEC
					pinst->v_OUT.value.vartype = OV_VT_STRING_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_string_vec, pinst->v_IN.value.valueunion.val_int_vec.veclen, STRING)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_int_vec.veclen; i++)
							if(Ov_Fail(ov_string_print(&pinst->v_OUT.value.valueunion.val_string_vec.value[i], "%d", pinst->v_IN.value.valueunion.val_int_vec.value[i])))
							{
								ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
								return;
							}
					}
					else	
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 24:	//TIME_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_VEC;
					length = pinst->v_IN.value.valueunion.val_int_vec.veclen / 2;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_vec, length, TIME)))
					{
						for(i=0; i < length; i++)
						{
							if(pinst->v_IN.value.valueunion.val_int_vec.value[i * 2] > 0)
								pinst->v_OUT.value.valueunion.val_time_vec.value[i].secs = pinst->v_IN.value.valueunion.val_int_vec.value[i * 2];
							else
								ov_logfile_error("%s: trying to convert negative value to time datatype in element %u", pinst->v_identifier, i * 2);
							if(pinst->v_IN.value.valueunion.val_int_vec.value[i * 2 + 1] > 0)	
								pinst->v_OUT.value.valueunion.val_time_vec.value[i].usecs = pinst->v_IN.value.valueunion.val_int_vec.value[i * 2 + 1];
							else
								ov_logfile_error("%s: trying to convert negative value to time datatype in element %u", pinst->v_identifier, i * 2 + 1);
						}
					}
					else	
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 25:	//TIME_SPAN_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN_VEC;
					length = pinst->v_IN.value.valueunion.val_int_vec.veclen / 2;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_span_vec, length, TIME_SPAN)))
					{
						for(i=0; i < length; i++)
						{
							pinst->v_OUT.value.valueunion.val_time_span_vec.value[i].secs = pinst->v_IN.value.valueunion.val_int_vec.value[i * 2];
							pinst->v_OUT.value.valueunion.val_time_span_vec.value[i].usecs = pinst->v_IN.value.valueunion.val_int_vec.value[i * 2 + 1];
						}
					}
					else	
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				default:
					ov_logfile_error("%s: conversion to specified datatype not implemented", pinst->v_identifier);
					pinst->v_OUT.value.vartype = OV_VT_BOOL;
					pinst->v_OUT.value.valueunion.val_bool = FALSE;
					return;
			}
			else
			{
				ov_logfile_error("%s: vectors of length 0 cannot be converted", pinst->v_identifier);
				pinst->v_OUT.value.vartype = OV_VT_BOOL;
				pinst->v_OUT.value.valueunion.val_bool = FALSE;
			}
		break;
		
				/******************************SINGLE_VEC******************/
		
		case OV_VT_SINGLE_VEC:
			if(pinst->v_IN.value.valueunion.val_single_vec.veclen)
			switch(pinst->v_K)
			{
				
				case 2:		//BOOL
					STDFB_VEC_TO_BOOL(single);
				break;
				
				case 3:		//UINT
					STDFB_VEC_TO_UINT(single)
				break;
				
				case 4:		//INT
					pinst->v_OUT.value.vartype = OV_VT_INT;
					if(pinst->v_IN.value.valueunion.val_single_vec.value[0] > OV_VL_MAXINT || pinst->v_IN.value.valueunion.val_single_vec.value[0] < -(int)OV_VL_MAXINT)	
							ov_logfile_error("%s: value exceeds range of int", pinst->v_identifier);
					pinst->v_OUT.value.valueunion.val_int = (OV_INT) pinst->v_IN.value.valueunion.val_single_vec.value[0];
					if((pinst->v_IN.value.valueunion.val_single_vec.value[0] - pinst->v_OUT.value.valueunion.val_int) > 0.5)		//round up
						pinst->v_OUT.value.valueunion.val_int++;
					else
						if((pinst->v_IN.value.valueunion.val_single_vec.value[0] - pinst->v_OUT.value.valueunion.val_int) < -0.5)		//round down
							pinst->v_OUT.value.valueunion.val_int--;
						else
							if(((pinst->v_IN.value.valueunion.val_single_vec.value[0] - pinst->v_OUT.value.valueunion.val_int) == 0.5) && (pinst->v_OUT.value.valueunion.val_int % 2 != 0))	//round up, if this is even
								pinst->v_OUT.value.valueunion.val_int++;
							else
								if(((pinst->v_IN.value.valueunion.val_single_vec.value[0] - pinst->v_OUT.value.valueunion.val_int) == -0.5) && (pinst->v_OUT.value.valueunion.val_int % 2 != 0))
									pinst->v_OUT.value.valueunion.val_int--;
				break;
				
				case 5:		//SINGLE
					pinst->v_OUT.value.vartype = OV_VT_SINGLE;
					pinst->v_OUT.value.valueunion.val_single = pinst->v_IN.value.valueunion.val_single_vec.value[0];
				break;
				
				case 6:		//DOUBLE
					pinst->v_OUT.value.vartype = OV_VT_DOUBLE;
					pinst->v_OUT.value.valueunion.val_double = pinst->v_IN.value.valueunion.val_single_vec.value[0];
				break;
				
				case 7:		//STRING
					pinst->v_OUT.value.vartype = OV_VT_STRING;
					if(Ov_Fail(ov_string_print(&pinst->v_OUT.value.valueunion.val_string, "%f", pinst->v_IN.value.valueunion.val_single_vec.value[0])))
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 8:		//TIME
					pinst->v_OUT.value.vartype = OV_VT_TIME;
					if(pinst->v_IN.value.valueunion.val_single_vec.value[0] >= 0)
					{			
						if(pinst->v_IN.value.valueunion.val_single_vec.value[0] > (float) OV_VL_MAXUINT)	
							ov_logfile_error("%s: value exceeds range of time", pinst->v_identifier);
						pinst->v_OUT.value.valueunion.val_time.secs = (OV_UINT) pinst->v_IN.value.valueunion.val_single_vec.value[0];
						pinst->v_OUT.value.valueunion.val_time.usecs = (OV_UINT) ((pinst->v_IN.value.valueunion.val_single_vec.value[0] - pinst->v_OUT.value.valueunion.val_time.secs ) * 1000000);	//subtracting seconds and converting to microseconds
					}
					else
						ov_logfile_error("%s: trying to convert negative value to time, this is not possible", pinst->v_identifier);
					
				break;
				
				case 9:		//TIME_SPAN
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN;
					if(pinst->v_IN.value.valueunion.val_single_vec.value[0] > (float) OV_VL_MAXINT || pinst->v_IN.value.valueunion.val_single_vec.value[0] < -(float) OV_VL_MAXINT)	
						ov_logfile_error("%s: value exceeds range of time_span", pinst->v_identifier);
					pinst->v_OUT.value.valueunion.val_time_span.secs = (OV_INT) pinst->v_IN.value.valueunion.val_single_vec.value[0];
					pinst->v_OUT.value.valueunion.val_time_span.usecs = (OV_INT) ((pinst->v_IN.value.valueunion.val_single_vec.value[0]
						- pinst->v_OUT.value.valueunion.val_time_span.secs) * 1000000);	//subtracting seconds and converting to microseconds
					
				break;
				
				case 17:	//BYTE_VEC
					STDFB_VEC_TO_BYTE_VEC(SINGLE, single);
				break;
				
				case 18:	//BOOL_VEC
					STDFB_VEC_TO_BOOL_VEC(SINGLE, single);
				break;
				
				case 19:	//UINT_VEC
					pinst->v_OUT.value.vartype = OV_VT_UINT_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_uint_vec, pinst->v_IN.value.valueunion.val_single_vec.veclen, UINT)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_single_vec.veclen; i++)
						{
							if(pinst->v_IN.value.valueunion.val_single_vec.value[i] >= 0)
							{
								if(pinst->v_IN.value.valueunion.val_single_vec.value[i] > OV_VL_MAXUINT)	
									ov_logfile_error("%s: value in element %u exceeds range of unsigned int", pinst->v_identifier, i);
								pinst->v_OUT.value.valueunion.val_uint_vec.value[i] = (OV_UINT) pinst->v_IN.value.valueunion.val_single_vec.value[i];
								if((pinst->v_IN.value.valueunion.val_single_vec.value[i] - pinst->v_OUT.value.valueunion.val_uint_vec.value[i]) > 0.5)		//round up
									pinst->v_OUT.value.valueunion.val_uint_vec.value[i]++;
								else
									if(((pinst->v_IN.value.valueunion.val_single_vec.value[i] - pinst->v_OUT.value.valueunion.val_uint_vec.value[i]) == 0.5) && (pinst->v_OUT.value.valueunion.val_uint_vec.value[i] % 2 != 0))	//round up, if this is even
										pinst->v_OUT.value.valueunion.val_uint_vec.value[i]++;
							}
							else
								ov_logfile_error("%s: trying to convert negative value in element %u to unsigned integer", pinst->v_identifier, i);
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 20:	//INT_VEC
					pinst->v_OUT.value.vartype = OV_VT_INT_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_int_vec, pinst->v_IN.value.valueunion.val_single_vec.veclen, INT)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_single_vec.veclen; i++)
						{
							if(pinst->v_IN.value.valueunion.val_single_vec.value[i] > OV_VL_MAXINT || pinst->v_IN.value.valueunion.val_single_vec.value[i] < -(int)OV_VL_MAXINT)	
								ov_logfile_error("%s: value in element %u exceeds range of int", pinst->v_identifier, i);
							pinst->v_OUT.value.valueunion.val_int_vec.value[i] = (OV_INT) pinst->v_IN.value.valueunion.val_single_vec.value[i];
							if((pinst->v_IN.value.valueunion.val_single_vec.value[i] - pinst->v_OUT.value.valueunion.val_int_vec.value[i]) > 0.5)		//round up
								pinst->v_OUT.value.valueunion.val_int_vec.value[i]++;
							else
								if((pinst->v_IN.value.valueunion.val_single_vec.value[i] - pinst->v_OUT.value.valueunion.val_int_vec.value[i]) < -0.5)		//round down
									pinst->v_OUT.value.valueunion.val_int_vec.value[i]--;
								else
									if(((pinst->v_IN.value.valueunion.val_single_vec.value[i] - pinst->v_OUT.value.valueunion.val_int_vec.value[i]) == 0.5) && (pinst->v_OUT.value.valueunion.val_int_vec.value[i] % 2 != 0))	//round up, if this is even
										pinst->v_OUT.value.valueunion.val_int_vec.value[i]++;
									else
										if(((pinst->v_IN.value.valueunion.val_single_vec.value[i] - pinst->v_OUT.value.valueunion.val_int_vec.value[i]) == -0.5) && (pinst->v_OUT.value.valueunion.val_int_vec.value[i] % 2 != 0))
											pinst->v_OUT.value.valueunion.val_int_vec.value[i]--;
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 21:	//SINGLE_VEC
					pinst->v_OUT.value.vartype = OV_VT_SINGLE_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_single_vec, pinst->v_IN.value.valueunion.val_single_vec.veclen, SINGLE)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_single_vec.veclen; i++)
							pinst->v_OUT.value.valueunion.val_single_vec.value[i] = pinst->v_IN.value.valueunion.val_single_vec.value[i];
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 22:	//DOUBLE_VEC
					STDFB_VEC_TO_DOUBLE_VEC(SINGLE, single);
				break;
				
				case 23:	//STRING_VEC
					pinst->v_OUT.value.vartype = OV_VT_STRING_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_string_vec, pinst->v_IN.value.valueunion.val_single_vec.veclen, STRING)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_single_vec.veclen; i++)
							if(Ov_Fail(ov_string_print(&pinst->v_OUT.value.valueunion.val_string_vec.value[i], "%f", pinst->v_IN.value.valueunion.val_single_vec.value[i])))
							{
								ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
								return;
							}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 24:	//TIME_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_vec, pinst->v_IN.value.valueunion.val_single_vec.veclen, TIME)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_single_vec.veclen; i++)
						{
							if(pinst->v_IN.value.valueunion.val_single_vec.value[i] >= 0)
							{			
								if(pinst->v_IN.value.valueunion.val_single_vec.value[i] > (float) OV_VL_MAXUINT)	
									ov_logfile_error("%s: value in element %u exceeds range of time", pinst->v_identifier, i);
								pinst->v_OUT.value.valueunion.val_time_vec.value[i].secs = (OV_UINT) pinst->v_IN.value.valueunion.val_single_vec.value[i];
								pinst->v_OUT.value.valueunion.val_time_vec.value[i].usecs = (OV_UINT)
									((pinst->v_IN.value.valueunion.val_single_vec.value[i] - pinst->v_OUT.value.valueunion.val_time_vec.value[i].secs ) * 1000000);	//subtracting seconds and converting to microseconds
							}
							else
								ov_logfile_error("%s: trying to convert negative value in element %u to time, this is not possible", pinst->v_identifier, i);
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 25:	//TIME_SPAN_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_span_vec, pinst->v_IN.value.valueunion.val_single_vec.veclen, TIME_SPAN)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_single_vec.veclen; i++)
						{
							if(pinst->v_IN.value.valueunion.val_single_vec.value[i] > (float) OV_VL_MAXINT || pinst->v_IN.value.valueunion.val_single_vec.value[i] < -(float) OV_VL_MAXINT)	
								ov_logfile_error("%s: value in element %u exceeds range of time_span", pinst->v_identifier, i);
							pinst->v_OUT.value.valueunion.val_time_span_vec.value[i].secs = (OV_INT) pinst->v_IN.value.valueunion.val_single_vec.value[i];
							pinst->v_OUT.value.valueunion.val_time_span_vec.value[i].usecs = (OV_INT) ((pinst->v_IN.value.valueunion.val_single_vec.value[i]
								- pinst->v_OUT.value.valueunion.val_time_span_vec.value[i].secs) * 1000000);	//subtracting seconds and converting to microseconds
							
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				default:
					ov_logfile_error("%s: conversion to specified datatype not implemented", pinst->v_identifier);
					pinst->v_OUT.value.vartype = OV_VT_BOOL;
					pinst->v_OUT.value.valueunion.val_bool = FALSE;
					return;
			}
			else
			{
				ov_logfile_error("%s: vectors of length 0 cannot be converted", pinst->v_identifier);
				pinst->v_OUT.value.vartype = OV_VT_BOOL;
				pinst->v_OUT.value.valueunion.val_bool = FALSE;
			}
		break;
		
			/******************************DOUBLE_VEC******************/
		
		case OV_VT_DOUBLE_VEC:
			if(pinst->v_IN.value.valueunion.val_double_vec.veclen)
			switch(pinst->v_K)
			{
								
				case 2:		//BOOL
					STDFB_VEC_TO_BOOL(double);
				break;
				
				case 3:		//UINT
					STDFB_VEC_TO_UINT(double)
				break;
				
				case 4:		//INT
					pinst->v_OUT.value.vartype = OV_VT_INT;
					if(pinst->v_IN.value.valueunion.val_double_vec.value[0] > OV_VL_MAXINT || pinst->v_IN.value.valueunion.val_double_vec.value[0] < -(int)OV_VL_MAXINT)	
							ov_logfile_error("%s: value exceeds range of int", pinst->v_identifier);
					pinst->v_OUT.value.valueunion.val_int = (OV_INT) pinst->v_IN.value.valueunion.val_double_vec.value[0];
					if((pinst->v_IN.value.valueunion.val_double_vec.value[0] - pinst->v_OUT.value.valueunion.val_int) > 0.5)		//round up
						pinst->v_OUT.value.valueunion.val_int++;
					else
						if((pinst->v_IN.value.valueunion.val_double_vec.value[0] - pinst->v_OUT.value.valueunion.val_int) < -0.5)		//round down
							pinst->v_OUT.value.valueunion.val_int--;
						else
							if(((pinst->v_IN.value.valueunion.val_double_vec.value[0] - pinst->v_OUT.value.valueunion.val_int) == 0.5) && (pinst->v_OUT.value.valueunion.val_int % 2 != 0))	//round up, if this is even
								pinst->v_OUT.value.valueunion.val_int++;
							else
								if(((pinst->v_IN.value.valueunion.val_double_vec.value[0] - pinst->v_OUT.value.valueunion.val_int) == -0.5) && (pinst->v_OUT.value.valueunion.val_int % 2 != 0))
									pinst->v_OUT.value.valueunion.val_int--;
				break;
				
				case 5:		//SINGLE
					pinst->v_OUT.value.vartype = OV_VT_SINGLE;
					if(pinst->v_IN.value.valueunion.val_double_vec.value[0] < FLT_MAX && pinst->v_IN.value.valueunion.val_double_vec.value[0] > -FLT_MAX)
						pinst->v_OUT.value.valueunion.val_single = (OV_SINGLE) pinst->v_IN.value.valueunion.val_double_vec.value[0];
					else
						ov_logfile_error("%s: value exceeds range of single", pinst->v_identifier);
				break;
				
				case 6:		//DOUBLE
					pinst->v_OUT.value.vartype = OV_VT_DOUBLE;
					pinst->v_OUT.value.valueunion.val_double = pinst->v_IN.value.valueunion.val_double_vec.value[0];
				break;
				
				case 7:		//STRING
					pinst->v_OUT.value.vartype = OV_VT_STRING;
					if(Ov_Fail(ov_string_print(&pinst->v_OUT.value.valueunion.val_string, "%f", pinst->v_IN.value.valueunion.val_double_vec.value[0])))
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 8:		//TIME
					pinst->v_OUT.value.vartype = OV_VT_TIME;
					if(pinst->v_IN.value.valueunion.val_double_vec.value[0] >= 0)
					{			
						if(pinst->v_IN.value.valueunion.val_double_vec.value[0] > (double) OV_VL_MAXUINT)	
							ov_logfile_error("%s: value exceeds range of time", pinst->v_identifier);
						pinst->v_OUT.value.valueunion.val_time.secs = (OV_UINT) pinst->v_IN.value.valueunion.val_double_vec.value[0];
						pinst->v_OUT.value.valueunion.val_time.usecs = (OV_UINT) (pinst->v_IN.value.valueunion.val_double_vec.value[0] - pinst->v_OUT.value.valueunion.val_time.secs ) * 1000000;	//subtracting seconds and converting to microseconds
					}
					else
						ov_logfile_error("%s: trying to convert negative value to time, this is not possible", pinst->v_identifier);
				break;
				
				case 9:		//TIME_SPAN
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN;
					if(pinst->v_IN.value.valueunion.val_double_vec.value[0] > (double) OV_VL_MAXINT 
						|| pinst->v_IN.value.valueunion.val_double_vec.value[0] < -(double) OV_VL_MAXINT)	
							ov_logfile_error("%s: value exceeds range of time_span", pinst->v_identifier);
					pinst->v_OUT.value.valueunion.val_time_span.secs = (OV_INT) pinst->v_IN.value.valueunion.val_double_vec.value[0];
					pinst->v_OUT.value.valueunion.val_time_span.usecs = (OV_INT) ((pinst->v_IN.value.valueunion.val_double_vec.value[0]
						- pinst->v_OUT.value.valueunion.val_time_span.secs) * 1000000);	//subtracting seconds and converting to microseconds
					
				break;
				
				case 17:	//BYTE_VEC
					STDFB_VEC_TO_BYTE_VEC(DOUBLE, double);
				break;
				
				case 18:	//BOOL_VEC
					STDFB_VEC_TO_BOOL_VEC(DOUBLE, double);
				break;
				
				case 19:	//UINT_VEC
					pinst->v_OUT.value.vartype = OV_VT_UINT_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_uint_vec, pinst->v_IN.value.valueunion.val_double_vec.veclen, UINT)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_double_vec.veclen; i++)
						{
							if(pinst->v_IN.value.valueunion.val_double_vec.value[i] >= 0)
							{
								if(pinst->v_IN.value.valueunion.val_double_vec.value[i] > OV_VL_MAXUINT)	
									ov_logfile_error("%s: value in element %u exceeds range of unsigned int", pinst->v_identifier, i);
								pinst->v_OUT.value.valueunion.val_uint_vec.value[i] = (OV_UINT) pinst->v_IN.value.valueunion.val_double_vec.value[i];
								if((pinst->v_IN.value.valueunion.val_double_vec.value[i] - pinst->v_OUT.value.valueunion.val_uint_vec.value[i]) > 0.5)		//round up
									pinst->v_OUT.value.valueunion.val_uint_vec.value[i]++;
								else
									if(((pinst->v_IN.value.valueunion.val_double_vec.value[i] - pinst->v_OUT.value.valueunion.val_uint_vec.value[i]) == 0.5) && (pinst->v_OUT.value.valueunion.val_uint_vec.value[i] % 2 != 0))	//round up, if this is even
										pinst->v_OUT.value.valueunion.val_uint_vec.value[i]++;
							}
							else
								ov_logfile_error("%s: trying to convert negative value in element %u to unsigned integer", pinst->v_identifier, i);
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 20:	//INT_VEC
					pinst->v_OUT.value.vartype = OV_VT_INT_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_int_vec, pinst->v_IN.value.valueunion.val_double_vec.veclen, INT)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_double_vec.veclen; i++)
						{
							if(pinst->v_IN.value.valueunion.val_double_vec.value[i] > OV_VL_MAXINT || pinst->v_IN.value.valueunion.val_double_vec.value[i] < -(int)OV_VL_MAXINT)	
								ov_logfile_error("%s: value in element %u exceeds range of int", pinst->v_identifier, i);
							pinst->v_OUT.value.valueunion.val_int_vec.value[i] = (OV_INT) pinst->v_IN.value.valueunion.val_double_vec.value[i];
							if((pinst->v_IN.value.valueunion.val_double_vec.value[i] - pinst->v_OUT.value.valueunion.val_int_vec.value[i]) > 0.5)		//round up
								pinst->v_OUT.value.valueunion.val_int_vec.value[i]++;
							else
								if((pinst->v_IN.value.valueunion.val_double_vec.value[i] - pinst->v_OUT.value.valueunion.val_int_vec.value[i]) < -0.5)		//round down
									pinst->v_OUT.value.valueunion.val_int_vec.value[i]--;
								else
									if(((pinst->v_IN.value.valueunion.val_double_vec.value[i] - pinst->v_OUT.value.valueunion.val_int_vec.value[i]) == 0.5) && (pinst->v_OUT.value.valueunion.val_int_vec.value[i] % 2 != 0))	//round up, if this is even
										pinst->v_OUT.value.valueunion.val_int_vec.value[i]++;
									else
										if(((pinst->v_IN.value.valueunion.val_double_vec.value[i] - pinst->v_OUT.value.valueunion.val_int_vec.value[i]) == -0.5) && (pinst->v_OUT.value.valueunion.val_int_vec.value[i] % 2 != 0))
											pinst->v_OUT.value.valueunion.val_int_vec.value[i]--;
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 21:	//SINGLE_VEC
					pinst->v_OUT.value.vartype = OV_VT_SINGLE_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_single_vec, pinst->v_IN.value.valueunion.val_double_vec.veclen, SINGLE)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_double_vec.veclen; i++)
						{
							if(pinst->v_IN.value.valueunion.val_double_vec.value[i] < FLT_MAX || pinst->v_IN.value.valueunion.val_double_vec.value[i] > -FLT_MAX)	
							{
								pinst->v_OUT.value.valueunion.val_single_vec.value[i] = (OV_SINGLE) pinst->v_IN.value.valueunion.val_double_vec.value[i];
							}
							else
								ov_logfile_error("%s: value in element %u exceeds range of single", pinst->v_identifier, i);
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 22:	//DOUBLE_VEC
					STDFB_VEC_TO_DOUBLE_VEC(DOUBLE, double);
				break;
				
				case 23:	//STRING_VEC
					pinst->v_OUT.value.vartype = OV_VT_STRING_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_string_vec, pinst->v_IN.value.valueunion.val_double_vec.veclen, STRING)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_double_vec.veclen; i++)
							if(Ov_Fail(ov_string_print(&pinst->v_OUT.value.valueunion.val_string_vec.value[i], "%f", pinst->v_IN.value.valueunion.val_double_vec.value[i])))
							{
								ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
								return;
							}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 24:	//TIME_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_vec, pinst->v_IN.value.valueunion.val_double_vec.veclen, TIME)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_double_vec.veclen; i++)
						{
							if(pinst->v_IN.value.valueunion.val_double_vec.value[i] >= 0)
							{			
								if(pinst->v_IN.value.valueunion.val_double_vec.value[i] > (double) OV_VL_MAXUINT)	
									ov_logfile_error("%s: value in element %u exceeds range of time", pinst->v_identifier, i);
								pinst->v_OUT.value.valueunion.val_time_vec.value[i].secs = (OV_UINT) pinst->v_IN.value.valueunion.val_double_vec.value[i];
								pinst->v_OUT.value.valueunion.val_time_vec.value[i].usecs = (OV_UINT)
									((pinst->v_IN.value.valueunion.val_double_vec.value[i] - pinst->v_OUT.value.valueunion.val_time_vec.value[i].secs ) * 1000000);	//subtracting seconds and converting to microseconds
							}
							else
								ov_logfile_error("%s: trying to convert negative value in element %u to time, this is not possible", pinst->v_identifier, i);
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 25:	//TIME_SPAN_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_span_vec, pinst->v_IN.value.valueunion.val_double_vec.veclen, TIME_SPAN)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_double_vec.veclen; i++)
						{
							if(pinst->v_IN.value.valueunion.val_double_vec.value[i] > (double) OV_VL_MAXINT 
								|| pinst->v_IN.value.valueunion.val_double_vec.value[i] < -(double) OV_VL_MAXINT)	
									ov_logfile_error("%s: value in element %u exceeds range of time_span", pinst->v_identifier, i);
							pinst->v_OUT.value.valueunion.val_time_span_vec.value[i].secs = (OV_INT) pinst->v_IN.value.valueunion.val_double_vec.value[i];
							pinst->v_OUT.value.valueunion.val_time_span_vec.value[i].usecs = (OV_INT) ((pinst->v_IN.value.valueunion.val_double_vec.value[i]
								- pinst->v_OUT.value.valueunion.val_time_span_vec.value[i].secs) * 1000000);	//subtracting seconds and converting to microseconds
							
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				default:
					ov_logfile_error("%s: conversion to specified datatype not implemented", pinst->v_identifier);
					pinst->v_OUT.value.vartype = OV_VT_BOOL;
					pinst->v_OUT.value.valueunion.val_bool = FALSE;
					return;
			}
			else
			{
				ov_logfile_error("%s: vectors of length 0 cannot be converted", pinst->v_identifier);
				pinst->v_OUT.value.vartype = OV_VT_BOOL;
				pinst->v_OUT.value.valueunion.val_bool = FALSE;
			}
		break;
		
				/******************************STRING_VEC******************/
		
		case OV_VT_STRING_VEC:
			if(pinst->v_IN.value.valueunion.val_string_vec.veclen)
			switch(pinst->v_K)
			{
				case 2:		//BOOL
					STDFB_VEC_TO_BOOL(string);
				break;
				
				case 3:		//UINT
					STDFB_VEC_TO_UINT(string)
				break;
				
				case 4:		//INT
					pinst->v_OUT.value.vartype = OV_VT_INT;
					pinst->v_OUT.value.valueunion.val_int = strtol(pinst->v_IN.value.valueunion.val_string_vec.value[0], NULL, 10);
				break;
				
				case 5:		//SINGLE
					pinst->v_OUT.value.vartype = OV_VT_SINGLE;
					pinst->v_OUT.value.valueunion.val_single = (OV_SINGLE) strtod(pinst->v_IN.value.valueunion.val_string_vec.value[0], NULL);
				break;
				
				case 6:		//DOUBLE
					pinst->v_OUT.value.vartype = OV_VT_DOUBLE;
					pinst->v_OUT.value.valueunion.val_double = strtod(pinst->v_IN.value.valueunion.val_string_vec.value[0], NULL);
				break;
				
				case 7:		//STRING
					pinst->v_OUT.value.vartype = OV_VT_STRING;
					if(Ov_Fail(ov_string_setvalue(&pinst->v_OUT.value.valueunion.val_string, pinst->v_IN.value.valueunion.val_string_vec.value[0])))
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 8:		//TIME
					pinst->v_OUT.value.vartype = OV_VT_TIME;
					pinst->v_OUT.value.valueunion.val_time.secs = 0;
					pinst->v_OUT.value.valueunion.val_time.usecs = 0;
					if(Ov_Fail(ov_time_asciitotime(&pinst->v_OUT.value.valueunion.val_time, pinst->v_IN.value.valueunion.val_string_vec.value[0])))
					{
						ov_logfile_error("%s: converting string_vec to time failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 9:		//TIME_SPAN
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN;
					d_temp = strtod(pinst->v_IN.value.valueunion.val_string_vec.value[0], NULL);
					pinst->v_OUT.value.valueunion.val_time_span.secs = (OV_INT) d_temp;
					pinst->v_OUT.value.valueunion.val_time_span.usecs = (OV_INT) ((d_temp - pinst->v_OUT.value.valueunion.val_time_span.secs) * 1000000);
				break;
				
				case 17:	//BYTE_VEC
					pinst->v_OUT.value.vartype = OV_VT_BYTE_VEC;
					length = ov_string_getlength(pinst->v_IN.value.valueunion.val_string_vec.value[0]);
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_byte_vec, length, BYTE)))
					{
						for(i=0; i < length; i++)
							pinst->v_OUT.value.valueunion.val_byte_vec.value[i] = (pinst->v_IN.value.valueunion.val_string_vec.value[0])[i];
					}
					else
					{
						ov_logfile_error("%s: memory allocation failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 18:	//BOOL_VEC
					STDFB_VEC_TO_BOOL_VEC(STRING, string);
				break;
				
				case 19:	//UINT_VEC
					pinst->v_OUT.value.vartype = OV_VT_UINT_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_uint_vec, pinst->v_IN.value.valueunion.val_string_vec.veclen, UINT)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_string_vec.veclen; i++)
						{
							pinst->v_OUT.value.valueunion.val_uint_vec.value[i] = strtoul(pinst->v_IN.value.valueunion.val_string_vec.value[i], NULL, 10);
						}
					}
					else
					{
						ov_logfile_error("%s: memory allocation failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 20:	//INT_VEC
					pinst->v_OUT.value.vartype = OV_VT_INT_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_int_vec, pinst->v_IN.value.valueunion.val_string_vec.veclen, INT)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_string_vec.veclen; i++)
						{
							pinst->v_OUT.value.valueunion.val_int_vec.value[i] = strtol(pinst->v_IN.value.valueunion.val_string_vec.value[i], NULL, 10);
						}
					}
					else
					{
						ov_logfile_error("%s: memory allocation failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 21:	//SINGLE_VEC
					pinst->v_OUT.value.vartype = OV_VT_SINGLE_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_single_vec, pinst->v_IN.value.valueunion.val_string_vec.veclen, SINGLE)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_string_vec.veclen; i++)
						{
							pinst->v_OUT.value.valueunion.val_single_vec.value[i] = (OV_SINGLE) strtod(pinst->v_IN.value.valueunion.val_string_vec.value[i], NULL);
						}
					}
					else
					{
						ov_logfile_error("%s: memory allocation failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 22:	//DOUBLE_VEC
					pinst->v_OUT.value.vartype = OV_VT_DOUBLE_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_double_vec, pinst->v_IN.value.valueunion.val_string_vec.veclen, DOUBLE)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_string_vec.veclen; i++)
						{
							pinst->v_OUT.value.valueunion.val_double_vec.value[i] = strtod(pinst->v_IN.value.valueunion.val_string_vec.value[i], NULL);
						}
					}
					else
					{
						ov_logfile_error("%s: memory allocation failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 23:	//STRING_VEC
					pinst->v_OUT.value.vartype = OV_VT_STRING_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_string_vec, pinst->v_IN.value.valueunion.val_string_vec.veclen, STRING)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_string_vec.veclen; i++)
						{
							if(Ov_Fail(ov_string_setvalue(&pinst->v_OUT.value.valueunion.val_string_vec.value[i], pinst->v_IN.value.valueunion.val_string_vec.value[i])))
							{
								ov_logfile_error("%s: memory allocation failed, no operation performed", pinst->v_identifier);
								return;
							}
						}
					}
					else
					{
						ov_logfile_error("%s: memory allocation failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 24:	//TIME_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_vec, pinst->v_IN.value.valueunion.val_string_vec.veclen, TIME)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_string_vec.veclen; i++){
							pinst->v_OUT.value.valueunion.val_time_vec.value[i].secs = 0;
							pinst->v_OUT.value.valueunion.val_time_vec.value[i].usecs = 0;
							if(Ov_Fail(ov_time_asciitotime(&pinst->v_OUT.value.valueunion.val_time_vec.value[i], pinst->v_IN.value.valueunion.val_string_vec.value[i])))
							{
								ov_logfile_error("%s: converting string_vec to time_vec failed, no operation performed", pinst->v_identifier);
								return;
							}
						}
					}
					else
					{
						ov_logfile_error("%s: memory allocation failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 25:	//TIME_SPAN_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_span_vec, pinst->v_IN.value.valueunion.val_string_vec.veclen, TIME_SPAN)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_string_vec.veclen; i++)
						{
							d_temp = strtod(pinst->v_IN.value.valueunion.val_string_vec.value[i], NULL);
							pinst->v_OUT.value.valueunion.val_time_span_vec.value[i].secs = (OV_INT) d_temp;
							pinst->v_OUT.value.valueunion.val_time_span_vec.value[i].usecs = (OV_INT) 
								((d_temp - pinst->v_OUT.value.valueunion.val_time_span_vec.value[i].secs) * 1000000);
							
						}
					}
					else
					{
						ov_logfile_error("%s: memory allocation failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				default:
					ov_logfile_error("%s: conversion to specified datatype not implemented", pinst->v_identifier);
					pinst->v_OUT.value.vartype = OV_VT_BOOL;
					pinst->v_OUT.value.valueunion.val_bool = FALSE;
					return;
			}
			else
			{
				ov_logfile_error("%s: vectors of length 0 cannot be converted", pinst->v_identifier);
				pinst->v_OUT.value.vartype = OV_VT_BOOL;
				pinst->v_OUT.value.valueunion.val_bool = FALSE;
			}
		break;
		
				/******************************TIME_VEC******************/
		
		case OV_VT_TIME_VEC:
			if(pinst->v_IN.value.valueunion.val_time_vec.veclen)
			switch(pinst->v_K)
			{
				case 2:		//BOOL
					STDFB_VEC_TO_BOOL(time);
				break;
				
				case 3:		//UINT
					STDFB_VEC_TO_UINT(time)
				break;
				
				case 4:		//INT
					pinst->v_OUT.value.vartype = OV_VT_INT;
					if(pinst->v_IN.value.valueunion.val_time_vec.value[0].secs <= OV_VL_MAXINT)
						pinst->v_OUT.value.valueunion.val_int = pinst->v_IN.value.valueunion.val_time_vec.value[0].secs;
					else
						ov_logfile_error("%s: value exceeds range of int", pinst->v_identifier);
				break;
				
				case 5:		//SINGLE
					pinst->v_OUT.value.vartype = OV_VT_SINGLE;
					if(pinst->v_IN.value.valueunion.val_time_vec.value[0].secs > 10000000)
						ov_logfile_warning("%s: converting large integer to single, possible loss of precision", pinst->v_identifier);
					pinst->v_OUT.value.valueunion.val_single = (float) pinst->v_IN.value.valueunion.val_time_vec.value[0].secs * 1000000;
					pinst->v_OUT.value.valueunion.val_single += (float) pinst->v_IN.value.valueunion.val_time_vec.value[0].usecs;
					pinst->v_OUT.value.valueunion.val_single /= 1000000;
				break;
				
				case 6:		//DOUBLE
					pinst->v_OUT.value.vartype = OV_VT_DOUBLE;
					pinst->v_OUT.value.valueunion.val_double = (double) pinst->v_IN.value.valueunion.val_time_vec.value[0].secs * 1000000;
					pinst->v_OUT.value.valueunion.val_double += (double) pinst->v_IN.value.valueunion.val_time_vec.value[0].usecs;
					pinst->v_OUT.value.valueunion.val_double /= 1000000;
				break;
				
				case 7:		//STRING
					pinst->v_OUT.value.vartype = OV_VT_STRING;
					c_temp = ov_time_timetoascii(&(pinst->v_IN.value.valueunion.val_time_vec.value[0]));
					if(Ov_Fail(ov_string_setvalue(&pinst->v_OUT.value.valueunion.val_string, c_temp)))
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 8:		//TIME
					pinst->v_OUT.value.vartype = OV_VT_TIME;
					pinst->v_OUT.value.valueunion.val_time = pinst->v_IN.value.valueunion.val_time_vec.value[0];
				break;
				
				case 9:		//TIME_SPAN
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN;
					if(pinst->v_IN.value.valueunion.val_time_vec.value[0].secs < OV_VL_MAXINT)
					{
						pinst->v_OUT.value.valueunion.val_time_span.secs = pinst->v_IN.value.valueunion.val_time_vec.value[0].secs;
						pinst->v_OUT.value.valueunion.val_time_span.usecs = pinst->v_IN.value.valueunion.val_time_vec.value[0].usecs;
					}
					else
						ov_logfile_error("%s: value exceeds range of time span", pinst->v_identifier);
				break;
				
				case 17:	//BYTE_VEC
					STDFB_VEC_TO_BYTE_VEC(TIME, time);
				break;
				
				case 18:	//BOOL_VEC
					pinst->v_OUT.value.vartype= OV_VT_BOOL_VEC;	
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_bool_vec, pinst->v_IN.value.valueunion.val_time_vec.veclen, BOOL)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_time_vec.veclen; i++)
							if(pinst->v_IN.value.valueunion.val_time_vec.value[i].secs || pinst->v_IN.value.valueunion.val_time_vec.value[i].usecs)
								pinst->v_OUT.value.valueunion.val_bool_vec.value[i] = TRUE;
							else
								pinst->v_OUT.value.valueunion.val_bool_vec.value[i] = FALSE;
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 19:	//UINT_VEC
					pinst->v_OUT.value.vartype= OV_VT_UINT_VEC;	
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_uint_vec, pinst->v_IN.value.valueunion.val_time_vec.veclen, UINT)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_time_vec.veclen; i++)
							pinst->v_OUT.value.valueunion.val_uint_vec.value[i] = pinst->v_IN.value.valueunion.val_time_vec.value[i].secs;
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 20:	//INT_VEC
					pinst->v_OUT.value.vartype= OV_VT_INT_VEC;	
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_int_vec, pinst->v_IN.value.valueunion.val_time_vec.veclen, INT)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_time_vec.veclen; i++)
							if(pinst->v_IN.value.valueunion.val_time_vec.value[i].secs <= OV_VL_MAXINT)
								pinst->v_OUT.value.valueunion.val_int_vec.value[i] = pinst->v_IN.value.valueunion.val_time_vec.value[i].secs;
							else
								ov_logfile_error("%s: value in element %u exceeds range of int", pinst->v_identifier, i);
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 21:	//SINGLE_VEC
					pinst->v_OUT.value.vartype = OV_VT_SINGLE_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_single_vec, pinst->v_IN.value.valueunion.val_time_vec.veclen, SINGLE)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_time_vec.veclen; i++)
						{
							if(pinst->v_IN.value.valueunion.val_time_vec.value[i].secs > 10000000)
								ov_logfile_warning("%s: converting large integer in element %u to single, possible loss of precision", pinst->v_identifier, i);
							pinst->v_OUT.value.valueunion.val_single_vec.value[i] = (float) pinst->v_IN.value.valueunion.val_time_vec.value[i].secs * 1000000;
							pinst->v_OUT.value.valueunion.val_single_vec.value[i] += (float) pinst->v_IN.value.valueunion.val_time_vec.value[i].usecs;
							pinst->v_OUT.value.valueunion.val_single_vec.value[i] /= 1000000;
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 22:	//DOUBLE_VEC
					pinst->v_OUT.value.vartype = OV_VT_DOUBLE_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_double_vec, pinst->v_IN.value.valueunion.val_time_vec.veclen, DOUBLE)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_time_vec.veclen; i++)
						{
							pinst->v_OUT.value.valueunion.val_double_vec.value[i] = (double) pinst->v_IN.value.valueunion.val_time_vec.value[i].secs * 1000000;
							pinst->v_OUT.value.valueunion.val_double_vec.value[i] += (double) pinst->v_IN.value.valueunion.val_time_vec.value[i].usecs;
							pinst->v_OUT.value.valueunion.val_double_vec.value[i] /= 1000000;
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 23:	//STRING_VEC
					pinst->v_OUT.value.vartype = OV_VT_STRING_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_string_vec, pinst->v_IN.value.valueunion.val_time_vec.veclen, STRING)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_time_vec.veclen; i++)
						{
							c_temp = ov_time_timetoascii(&(pinst->v_IN.value.valueunion.val_time_vec.value[i]));
							if(Ov_Fail(ov_string_setvalue(&(pinst->v_OUT.value.valueunion.val_string_vec.value[i]), c_temp)))
							{
								ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
								return;
							}
							
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 24:	//TIME_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_vec, pinst->v_IN.value.valueunion.val_time_vec.veclen, TIME)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_time_vec.veclen; i++)
						{
							pinst->v_OUT.value.valueunion.val_time_vec.value[i] = pinst->v_IN.value.valueunion.val_time_vec.value[i];
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 25:	//TIME_SPAN_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_span_vec, pinst->v_IN.value.valueunion.val_time_vec.veclen, TIME_SPAN)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_time_vec.veclen; i++)
						{
							if(pinst->v_IN.value.valueunion.val_time_vec.value[i].secs < OV_VL_MAXINT)
							{
								pinst->v_OUT.value.valueunion.val_time_span_vec.value[i].secs = pinst->v_IN.value.valueunion.val_time_vec.value[i].secs;
								pinst->v_OUT.value.valueunion.val_time_span_vec.value[i].usecs = pinst->v_IN.value.valueunion.val_time_vec.value[i].usecs;
							}
							else
								ov_logfile_error("%s: value in element %u exceeds range of time span", pinst->v_identifier, i);
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				default:
					ov_logfile_error("%s: conversion to specified datatype not implemented", pinst->v_identifier);
					return;
			}
			else
			{
				ov_logfile_error("%s: vectors of length 0 cannot be converted", pinst->v_identifier);
				pinst->v_OUT.value.vartype = OV_VT_BOOL;
				pinst->v_OUT.value.valueunion.val_bool = FALSE;
			}
		break;
		
				/******************************TIME_SPAN_VEC******************/
		
		case OV_VT_TIME_SPAN_VEC:
			if(pinst->v_IN.value.valueunion.val_time_span_vec.veclen)
			switch(pinst->v_K)
			{
				case 2:		//BOOL
					STDFB_VEC_TO_BOOL(time_span);
				break;
				
				case 3:		//UINT
					STDFB_VEC_TO_UINT(time_span)
				break;
				
				case 4:		//INT
					pinst->v_OUT.value.vartype = OV_VT_INT;
					pinst->v_OUT.value.valueunion.val_int = pinst->v_IN.value.valueunion.val_time_span_vec.value[0].secs;
				break;
				
				case 5:		//SINGLE
					pinst->v_OUT.value.vartype = OV_VT_SINGLE;
					pinst->v_OUT.value.valueunion.val_single = (float) pinst->v_IN.value.valueunion.val_time_span_vec.value[0].secs * 1000000;
					if(pinst->v_IN.value.valueunion.val_time_span_vec.value[0].secs >= 10000000 || pinst->v_IN.value.valueunion.val_time_span_vec.value[0].secs <= -10000000)
						ov_logfile_warning("%s: converting large integer to single, possible loss of precision", pinst->v_identifier);
					pinst->v_OUT.value.valueunion.val_single += (float) pinst->v_IN.value.valueunion.val_time_span_vec.value[0].usecs;
					pinst->v_OUT.value.valueunion.val_single /= 1000000;
				break;
				
				case 6:		//DOUBLE
					pinst->v_OUT.value.vartype = OV_VT_DOUBLE;
					pinst->v_OUT.value.valueunion.val_double = (double) pinst->v_IN.value.valueunion.val_time_span_vec.value[0].secs * 1000000;
					pinst->v_OUT.value.valueunion.val_double += (double) pinst->v_IN.value.valueunion.val_time_span_vec.value[0].usecs;
					pinst->v_OUT.value.valueunion.val_double /= 1000000;
				break;
				
				case 7:		//STRING
					pinst->v_OUT.value.vartype = OV_VT_STRING;
					d_temp = (double) pinst->v_IN.value.valueunion.val_time_span_vec.value[0].secs * 1000000;
					d_temp += (double) pinst->v_IN.value.valueunion.val_time_span_vec.value[0].usecs;
					d_temp /= 1000000;
					if(Ov_Fail(ov_string_print(&pinst->v_OUT.value.valueunion.val_string, "%f", d_temp)))
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 8:		//TIME
					pinst->v_OUT.value.vartype = OV_VT_TIME;
					if(pinst->v_IN.value.valueunion.val_time_span_vec.value[0].secs >= 0)
					{
						pinst->v_OUT.value.valueunion.val_time.secs = pinst->v_IN.value.valueunion.val_time_span_vec.value[0].secs;
						pinst->v_OUT.value.valueunion.val_time.usecs = pinst->v_IN.value.valueunion.val_time_span_vec.value[0].usecs;
					}
					else
					{
						ov_logfile_error("%s: trying to convert negtive value to time", pinst->v_identifier);
					}
				break;
				
				case 9:		//TIME_SPAN
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN;
					pinst->v_OUT.value.valueunion.val_time_span = pinst->v_IN.value.valueunion.val_time_span_vec.value[0];
				break;
				
				case 17:	//BYTE_VEC
					STDFB_VEC_TO_BYTE_VEC(TIME_SPAN, time_span);
				break;
				
				case 18:	//BOOL_VEC
					pinst->v_OUT.value.vartype = OV_VT_BOOL_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_bool_vec, pinst->v_IN.value.valueunion.val_time_span_vec.veclen, BOOL)))
					{
						for(i=0; i < pinst->v_OUT.value.valueunion.val_bool_vec.veclen; i++)
						{
							if(pinst->v_IN.value.valueunion.val_time_span_vec.value[i].secs || pinst->v_IN.value.valueunion.val_time_span_vec.value[i].usecs)
								pinst->v_OUT.value.valueunion.val_bool_vec.value[i] = TRUE;
							else
								pinst->v_OUT.value.valueunion.val_bool_vec.value[i] = FALSE;
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 19:	//UINT_VEC
					pinst->v_OUT.value.vartype = OV_VT_UINT_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_uint_vec, pinst->v_IN.value.valueunion.val_time_span_vec.veclen, UINT)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_time_span_vec.veclen; i++)
						{
							if(pinst->v_IN.value.valueunion.val_time_span_vec.value[i].secs >= 0)
								pinst->v_OUT.value.valueunion.val_uint_vec.value[i] = pinst->v_IN.value.valueunion.val_time_span_vec.value[i].secs;
							else
								ov_logfile_error("%s: trying to convert negative value in element %u to uint", pinst->v_identifier, i);
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 20:	//INT_VEC
					pinst->v_OUT.value.vartype = OV_VT_INT_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_int_vec, pinst->v_IN.value.valueunion.val_time_span_vec.veclen, INT)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_time_span_vec.veclen; i++)
							pinst->v_OUT.value.valueunion.val_int_vec.value[i] = pinst->v_IN.value.valueunion.val_time_span_vec.value[i].secs;
						
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 21:	//SINGLE_VEC
					pinst->v_OUT.value.vartype = OV_VT_SINGLE_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_single_vec, pinst->v_IN.value.valueunion.val_time_span_vec.veclen, SINGLE)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_time_span_vec.veclen; i++)
						{
							if(pinst->v_IN.value.valueunion.val_time_span_vec.value[i].secs >= 10000000)
								ov_logfile_warning("%s: converting large integer in element %u to single, possilbe loss of precision", pinst->v_identifier, i);
							pinst->v_OUT.value.valueunion.val_single_vec.value[i] = (float) pinst->v_IN.value.valueunion.val_time_span_vec.value[i].secs * 1000000;
							pinst->v_OUT.value.valueunion.val_single_vec.value[i] += (float) pinst->v_IN.value.valueunion.val_time_span_vec.value[i].usecs;
							pinst->v_OUT.value.valueunion.val_single_vec.value[i] /= 1000000;
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 22:	//DOUBLE_VEC
					pinst->v_OUT.value.vartype = OV_VT_DOUBLE_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_double_vec, pinst->v_IN.value.valueunion.val_time_span_vec.veclen, DOUBLE)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_time_span_vec.veclen; i++)
						{
							pinst->v_OUT.value.valueunion.val_double_vec.value[i] = (float) pinst->v_IN.value.valueunion.val_time_span_vec.value[i].secs * 1000000;
							pinst->v_OUT.value.valueunion.val_double_vec.value[i] += (float) pinst->v_IN.value.valueunion.val_time_span_vec.value[i].usecs;
							pinst->v_OUT.value.valueunion.val_double_vec.value[i] /= 1000000;
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 23:	//STRING_VEC
					pinst->v_OUT.value.vartype = OV_VT_STRING_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_string_vec, pinst->v_IN.value.valueunion.val_time_span_vec.veclen, STRING)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_time_span_vec.veclen; i++)
						{
							d_temp = (float) pinst->v_IN.value.valueunion.val_time_span_vec.value[i].secs * 1000000;
							d_temp += (float) pinst->v_IN.value.valueunion.val_time_span_vec.value[i].usecs;
							d_temp /= 1000000;
							if(Ov_Fail(ov_string_print(&(pinst->v_OUT.value.valueunion.val_string_vec.value[i]), "%f", d_temp)))
							{
								ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
								return;
							}
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 24:	//TIME_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_vec, pinst->v_IN.value.valueunion.val_time_span_vec.veclen, TIME)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_time_span_vec.veclen; i++)
						{
							if(pinst->v_IN.value.valueunion.val_time_span_vec.value[i].secs >= 0)
							{
								pinst->v_OUT.value.valueunion.val_time_vec.value[i].secs = pinst->v_IN.value.valueunion.val_time_span_vec.value[i].secs;
								pinst->v_OUT.value.valueunion.val_time_vec.value[i].usecs = pinst->v_IN.value.valueunion.val_time_span_vec.value[i].usecs;
							}
							else
								ov_logfile_error("%s: trying to convert negative value in element %u to time", pinst->v_identifier, i);
						}
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				case 25:	//TIME_SPAN_VEC
					pinst->v_OUT.value.vartype = OV_VT_TIME_SPAN_VEC;
					if(Ov_OK(Ov_SetDynamicVectorLength(&pinst->v_OUT.value.valueunion.val_time_span_vec, pinst->v_IN.value.valueunion.val_time_span_vec.veclen, TIME_SPAN)))
					{
						for(i=0; i < pinst->v_IN.value.valueunion.val_time_span_vec.veclen; i++)
							pinst->v_OUT.value.valueunion.val_time_span_vec.value[i] = pinst->v_IN.value.valueunion.val_time_span_vec.value[i];
						
					}
					else
					{
						ov_logfile_error("%s: allocation of memory failed, no operation performed", pinst->v_identifier);
						return;
					}
				break;
				
				default:
					ov_logfile_error("%s: conversion to specified datatype not implemented", pinst->v_identifier);
					pinst->v_OUT.value.vartype = OV_VT_BOOL;
					pinst->v_OUT.value.valueunion.val_bool = FALSE;
					return;
			}
			else
			{
				ov_logfile_error("%s: vectors of length 0 cannot be converted", pinst->v_identifier);
				pinst->v_OUT.value.vartype = OV_VT_BOOL;
				pinst->v_OUT.value.valueunion.val_bool = FALSE;
			}

		break;
		
		default:
			ov_logfile_error("%s: non-standard datatype specified, no conversion implemented", pinst->v_identifier);
			pinst->v_OUT.value.vartype = OV_VT_BOOL;
			pinst->v_OUT.value.valueunion.val_bool = FALSE;
			return;
			
	}
	
		/************** handling states ********************************/
		
	STDFB_STATE(IN);
	
	/***************** handling timestamps ************************/
	STDFB_TIMESTAMP(IN);
	
	
    return;
}

