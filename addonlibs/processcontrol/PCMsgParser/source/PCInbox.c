
/******************************************************************************
*
*   FILE
*   ----
*   PCInbox.c
*
*   History
*   -------
*   2013-05-07   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_PCMsgParser
#define OV_COMPILE_LIBRARY_PCMsgParser
#endif


#include "PCMsgParser.h"
#include "libov/ov_macros.h"
#include "libov/ov_logfile.h"
#include <string.h>


OV_DLLFNCEXPORT OV_RESULT PCMsgParser_PCInbox_constructor(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
    OV_RESULT    result;

    /* do what the base class does first */
    result = ov_object_constructor(pobj);
    if(Ov_Fail(result))
         return result;

    /* do what */


    return OV_ERR_OK;
}

/*
 * return OV_ERR_BADVALUE if element is not found (or not valid)
 */

OV_RESULT PCMsgParser_getElementData(char const* xml, const OV_STRING elemName, OV_STRING* pData)
{
	OV_UINT dataLength;
	OV_STRING beginElement = NULL;
	char const* tempPtr =  xml;

	if(!xml || !elemName)
		return OV_ERR_BADPARAM;

	beginElement = strstr(xml, elemName);
	if(!beginElement)
		return OV_ERR_BADVALUE;

	while(beginElement && (*(beginElement-1) != '<'))
	{/*	go over the string and check if this is an element name	*/
		beginElement++;
		beginElement = strstr(beginElement, elemName);
	}

	/*	jump to end of tag	*/
	tempPtr = strchr(beginElement, '>');
	if(!tempPtr)
		return OV_ERR_BADVALUE;
	if(*(tempPtr-1) == '/')
	{	/*	no Data	*/
		*pData = NULL;
		return OV_ERR_OK;
	}

	tempPtr++;
	/*	now it points to the begin of the data	*/
	for(dataLength = 0; tempPtr[dataLength] != '<'; dataLength++)
	{
		if(!tempPtr[dataLength])
			return OV_ERR_BADVALUE;	/*	file ends before end of element --> invalid	*/
	}

	*pData = ov_memstack_alloc(dataLength+1);
	if(!*pData)
		return OV_ERR_HEAPOUTOFMEMORY;

	strncpy(*pData, tempPtr, dataLength);
	(*pData)[dataLength] = '\0';


	return OV_ERR_OK;
}

OV_STRING PCMsgParser_skipWhiteSpace(OV_STRING input)
{
	OV_STRING temp;
	for(temp = input; *temp &&(*temp == ' ' || *temp == '\t' || *temp == '\r' || *temp == '\n'); temp++)
		;
	return temp;
}

void PCMsgParser_rStrip(OV_STRING input)
{
	OV_STRING temp;
	for(temp = input; *temp; temp++)
		;	/*	seek to end	*/
	while(temp>input && (*temp == ' ' || *temp == '\t' || *temp == '\r' || *temp == '\n'))
	{
		*temp = '\0';
		temp--;
	}
	return;
}

OV_DLLFNCEXPORT void PCMsgParser_PCInbox_typemethod(
		OV_INSTPTR_fb_functionblock	pfb,
		OV_TIME						*pltc
) {
	OV_INSTPTR_PCMsgParser_PCInbox this = Ov_StaticPtrCast(PCMsgParser_PCInbox, pfb);
	OV_INSTPTR_MessageSys_Message pMsg = NULL;
	OV_INSTPTR_ov_object	pMsgObj = NULL;
	OV_INSTPTR_ov_object	pNextMsgObj = NULL;
	OV_INSTPTR_ov_domain	pParentDomain = NULL;
	OV_INSTPTR_cmdlib_processcontrol pProcessControl = NULL;
	OV_UINT waitingMsgs = 0;
	OV_RESULT result;

	OV_STRING commander = NULL;
	OV_STRING command = NULL;
	OV_STRING value = NULL;
	OV_STRING order = NULL;


	/*	check if we are in the containment of a process control object	*/
	pParentDomain = Ov_GetParent(ov_containment, this);
	if(Ov_CanCastTo(cmdlib_processcontrol, pParentDomain))
		pProcessControl = Ov_StaticPtrCast(cmdlib_processcontrol, pParentDomain);
	else
	{
		ov_logfile_error("PCInbox %s not in the containment of a process control unit. deactivating.", this->v_identifier);
		this->v_actimode = 0;
		return;
	}


	pMsgObj = Ov_GetFirstChild(ov_containment, this);
	while(pMsgObj)
	{
		if(Ov_CanCastTo(MessageSys_Message, pMsgObj))
			waitingMsgs++;

		pMsgObj = Ov_GetNextChild(ov_containment, pMsgObj);
	}

	if(this->v_fiFoQueue)
	{	/*	starting working with the oldest --> delete the newer ones	*/
		pMsgObj = Ov_GetLastChild(ov_containment, this);
	}
	else
	{	/*	starting working with the newest --> delete the older ones	*/
		pMsgObj = Ov_GetFirstChild(ov_containment, this);
	}

	if(waitingMsgs > this->v_queueLength)
	{	/*	too many messages	*/
		while((waitingMsgs > this->v_queueLength) && pMsgObj)	/*	iterate over messages if there are too many. delete the object if it is a message	*/
		{
			if(this->v_fiFoQueue)
			{	/*	starting with the oldest --> delete the newer ones	*/
				pNextMsgObj = Ov_GetPreviousChild(ov_containment, pMsgObj);
				if(Ov_CanCastTo(MessageSys_Message, pMsgObj))
				{
					Ov_DeleteObject(pMsgObj);
					pMsgObj = pNextMsgObj;
					waitingMsgs--;
				}
				else
					pMsgObj = pNextMsgObj;
			}
			else
			{	/*	starting with the newest --> delete the older ones	*/
				pNextMsgObj = Ov_GetNextChild(ov_containment, pMsgObj);
				if(Ov_CanCastTo(MessageSys_Message, pMsgObj))
				{
					Ov_DeleteObject(pMsgObj);
					pMsgObj = pNextMsgObj;
					waitingMsgs--;
				}
				else
					pMsgObj = pNextMsgObj;
			}
		}
	}

	if(waitingMsgs)
	{	/*	there are messages waiting for processing	*/
		/*	get the Message to process (sort out other objects	*/
		while(pMsgObj && (!Ov_CanCastTo(MessageSys_Message, pMsgObj)))
		{
			if(this->v_fiFoQueue)
				pMsgObj = Ov_GetPreviousChild(ov_containment, pMsgObj);
			else
				pMsgObj = Ov_GetNextChild(ov_containment, pMsgObj);

		}
		if(pMsgObj)
		{
			pMsg = Ov_StaticPtrCast(MessageSys_Message, pMsgObj);
			/*	from here on we surely know
			 * 1. pMsg is of type Message or derived
			 * 2. pMsg is the message to work with basing on the queue type	*/

			ov_memstack_lock();

			/*	get the necessary information from the message	*/
			/*	get commander from senderservice	*/
			commander = MessageSys_Message_senderComponent_get(pMsg);

			/*	get Operation	*/
			result = PCMsgParser_getElementData(MessageSys_Message_msgBody_get(pMsg), "Operation", &command);
			if(Ov_Fail(result))
			{
				if(result != OV_ERR_HEAPOUTOFMEMORY)
					Ov_DeleteObject(pMsg);	/*	Message is corrupted --> delete it	*/

				ov_memstack_unlock();
				return;
			}

			if(!command)
			{
				ov_logfile_info("%s: no Operation found in message -->deleting it", this->v_identifier);
				Ov_DeleteObject(pMsg);	/*	Message is corrupted --> delete it	*/
				ov_memstack_unlock();
				return;
			}

			command = PCMsgParser_skipWhiteSpace(command);
			PCMsgParser_rStrip(command);

			/*	get Value	*/
			result = PCMsgParser_getElementData(MessageSys_Message_msgBody_get(pMsg), "KVP", &value);
			if(Ov_Fail(result))
			{
				if(result != OV_ERR_HEAPOUTOFMEMORY)
					Ov_DeleteObject(pMsg);	/*	Message is corrupted --> delete it	*/

				ov_memstack_unlock();
				return;
			}

			if(!value)
			{
				value = ov_memstack_alloc(2);
				value = "0";
			}

			value = PCMsgParser_skipWhiteSpace(value);
			PCMsgParser_rStrip(value);

			/*	concatenate to order and set it	*/

			order = ov_memstack_alloc(strlen(commander)+strlen(command)+strlen(value)+3);	/*	commander;command;value\0	*/
			if(!order)
			{
				ov_memstack_unlock();
				return;
			}
			sprintf(order, "%s;%s;%s", commander, command, value);
			//ov_logfile_debug("%s: order:\n\t%s", this->v_identifier, order);
			cmdlib_processcontrol_order_set(pProcessControl, order);
			/*	delete parsed message	*/
			Ov_DeleteObject(pMsg);
			ov_memstack_unlock();
		}

	}


	return;
}

