
/******************************************************************************
*
*   FILE
*   ----
*   PCInbox.c
*
*   History
*   -------
*   2013-05-07   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_PCMsgParser
#define OV_COMPILE_LIBRARY_PCMsgParser
#endif


#include "PCMsgParser.h"
#include "libov/ov_macros.h"
#include "libov/ov_logfile.h"
#include "libov/ov_result.h"
#include "acplt_simpleMsgHandling.h"
#include <string.h>
#define IsFlagSet(flags, name)	(flags & (1 << (name-'a')))

OV_DLLFNCEXPORT OV_RESULT PCMsgParser_PCInbox_constructor(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
    OV_RESULT    result;

    /* do what the base class does first */
    result = ov_object_constructor(pobj);
    if(Ov_Fail(result))
         return result;

    /* do what */


    return OV_ERR_OK;
}


OV_DLLFNCEXPORT void PCMsgParser_PCInbox_typemethod(
		OV_INSTPTR_fb_functionblock	pfb,
		OV_TIME						*pltc
) {
	OV_INSTPTR_PCMsgParser_PCInbox this = Ov_StaticPtrCast(PCMsgParser_PCInbox, pfb);
	OV_INSTPTR_MessageSys_Message pMsg = NULL;
	OV_INSTPTR_ov_object	pMsgObj = NULL;
	OV_INSTPTR_ov_object	pNextMsgObj = NULL;
	OV_INSTPTR_ov_domain	pParentDomain = NULL;
	OV_INSTPTR_fb_functionchart pParentChart = NULL;
	OV_INSTPTR_ssc_controlchart pParentControlChart = NULL;
	OV_INSTPTR_cmdlib_processcontrol pProcessControl = NULL;
	OV_BOOL parentIsPC = FALSE;
	OV_UINT waitingMsgs = 0;
	OV_RESULT result;

	OV_INSTPTR_fb_port		commandPort = NULL;
	OV_ANY tempany = {{OV_VT_STRING, {0}}, 0, {0, 0}};
	OV_STRING MsgBody = NULL;
	OV_STRING command = NULL;
	OV_STRING value = NULL;
	OV_STRING order = NULL;
	OV_STRING service = NULL;
	OV_STRING_VEC ids = {0, NULL};
	OV_STRING_VEC values = {0, NULL};
	OV_STRING_VEC types = {0, NULL};
	OV_STRING_VEC units = {0, NULL};

	/*	check if we are in the containment of a process control object	*/
	pParentDomain = Ov_GetParent(ov_containment, this);
	if(Ov_CanCastTo(fb_functionchart, pParentDomain))
	{
		parentIsPC = FALSE;
		pParentChart = Ov_StaticPtrCast(fb_functionchart, pParentDomain);
		pParentControlChart = Ov_DynamicPtrCast(ssc_controlchart, pParentDomain);
	}
	else if(Ov_CanCastTo(cmdlib_processcontrol, pParentDomain))
	{
		parentIsPC = TRUE;
		pProcessControl = Ov_StaticPtrCast(cmdlib_processcontrol, pParentDomain);
	}
	else
	{
		ov_logfile_error("PCInbox %s not in the containment of a process control unit. deactivating.", this->v_identifier);
		this->v_actimode = 0;
		return;
	}


	pMsgObj = Ov_GetFirstChild(ov_containment, this);
	while(pMsgObj)
	{
		if(Ov_CanCastTo(MessageSys_Message, pMsgObj))
			waitingMsgs++;

		pMsgObj = Ov_GetNextChild(ov_containment, pMsgObj);
	}

	if(this->v_fiFoQueue)
	{	/*	starting working with the oldest --> delete the newer ones	*/
		pMsgObj = Ov_GetLastChild(ov_containment, this);
	}
	else
	{	/*	starting working with the newest --> delete the older ones	*/
		pMsgObj = Ov_GetFirstChild(ov_containment, this);
	}

	if(waitingMsgs > this->v_queueLength)
	{	/*	too many messages	*/
		while((waitingMsgs > this->v_queueLength) && pMsgObj)	/*	iterate over messages if there are too many. delete the object if it is a message	*/
		{
			if(this->v_fiFoQueue)
			{	/*	starting with the oldest --> delete the newer ones	*/
				pNextMsgObj = Ov_GetPreviousChild(ov_containment, pMsgObj);
				if(Ov_CanCastTo(MessageSys_Message, pMsgObj))
				{
					Ov_DeleteObject(pMsgObj);
					pMsgObj = pNextMsgObj;
					waitingMsgs--;
				}
				else
					pMsgObj = pNextMsgObj;
			}
			else
			{	/*	starting with the newest --> delete the older ones	*/
				pNextMsgObj = Ov_GetNextChild(ov_containment, pMsgObj);
				if(Ov_CanCastTo(MessageSys_Message, pMsgObj))
				{
					Ov_DeleteObject(pMsgObj);
					pMsgObj = pNextMsgObj;
					waitingMsgs--;
				}
				else
					pMsgObj = pNextMsgObj;
			}
		}
	}

	if(waitingMsgs)
	{	/*	there are messages waiting for processing	*/
		/*	get the Message to process (sort out other objects	*/
		while(pMsgObj && (!Ov_CanCastTo(MessageSys_Message, pMsgObj)))
		{
			if(this->v_fiFoQueue)
				pMsgObj = Ov_GetPreviousChild(ov_containment, pMsgObj);
			else
				pMsgObj = Ov_GetNextChild(ov_containment, pMsgObj);

		}
		if(pMsgObj)
		{
			pMsg = Ov_StaticPtrCast(MessageSys_Message, pMsgObj);
			/*	from here on we surely know
			 * 1. pMsg is of type Message or derived
			 * 2. pMsg is the message to work with basing on the queue type	*/

			MsgBody = MessageSys_Message_msgBody_get(pMsg);
			ov_memstack_lock();
			/*	DEBUG: print MSG-Body	*/
			/*	ov_logfile_debug("Msg-Body:\n\n%s\n\n", MsgBody);	*/
			result = acplt_simpleMsg_parseFlatBody(MsgBody, &service, &command, FALSE, NULL,	&ids, &values, &units, &types);
			if(Ov_Fail(result))
			{
				ov_logfile_info("%s: parsing message body failed. reason: %s", this->v_identifier, ov_result_getresulttext(result));
				Ov_DeleteObject(pMsg);	/*	Message is corrupted --> delete it	*/
				ov_memstack_unlock();
				return;
			}
			/*	check message	*/
			if(ids.veclen > 2 || ids.veclen < 1)
			{
				ov_logfile_info("%s: malformed message --> deleting it", this->v_identifier);
				Ov_DeleteObject(pMsg);	/*	Message is corrupted --> delete it	*/
				ov_memstack_unlock();
				return;
			}
			if(ids.value[0] && ov_string_compare(ids.value[0], "cmdr") != OV_STRCMP_EQUAL)
			{
				ov_logfile_info("%s: malformed message --> deleting it", this->v_identifier);
				Ov_DeleteObject(pMsg);	/*	Message is corrupted --> delete it	*/
				ov_memstack_unlock();
				return;
			}
			if(ids.veclen == 2)
			{
				if(ids.value[1] && ov_string_compare(ids.value[1], "Value") != OV_STRCMP_EQUAL)
				{
					ov_logfile_info("%s: malformed message --> deleting it", this->v_identifier);
					Ov_DeleteObject(pMsg);	/*	Message is corrupted --> delete it	*/
					ov_memstack_unlock();
					return;
				}
			}
			/*	get service	and Operation	*/
			if(ov_string_compare(service, "ProcessControl") != OV_STRCMP_EQUAL)
			{
				ov_logfile_info("%s: unknown service requested --> deleting message", this->v_identifier);
				Ov_DeleteObject(pMsg);	/*	Message is corrupted --> delete it	*/
				ov_memstack_unlock();
				return;
			}


			if(ids.veclen == 2 && values.value[1])
			{	/*	value found	*/
				value = values.value[1];
			}
			else
			{	/*	now value found, set zo 0	*/
				value = "0";
			}
			/*	concatenate to order and set it	*/
			/*	DEBUG	*/
			/*	ov_logfile_info("%s %d: setting order", this->v_identifier, __LINE__);	*/
			order = ov_memstack_alloc(strlen(values.value[0])+strlen(command)+strlen(value)+3);	/*	commander;command;value\0	*/
			if(!order)
			{
				ov_memstack_unlock();
				ov_logfile_info("%s: could not create order, heap is out of memory", this->v_identifier);
				return;
			}
			sprintf(order, "%s;%s;%s", values.value[0], command, value);
			if(parentIsPC == TRUE)
			{
				/*	ov_logfile_debug("order:\n\n\t%s\n\n", order);	*/
				cmdlib_processcontrol_order_set(pProcessControl, order);
			}
			else
			{

				if(pParentControlChart){
					if(Ov_Fail(ssc_controlchart_CMD_set(pParentControlChart, order))){
						ov_logfile_error("Could not set \"CMD\" of parent control chart.");
					}
				} else {
					tempany.value.valueunion.val_string = order;
					commandPort=Ov_DynamicPtrCast(fb_port, Ov_SearchChild(ov_containment,pParentChart,"CMD"));
					if(commandPort)
					{
						if(IsFlagSet(commandPort->v_flags, 'i'))
						{
							if(Ov_CanCastTo(fb_stringport, commandPort))
							{
								ov_logfile_debug("Setting port \"CMD\" to: \"%s\".", order);
								ov_string_setvalue(&((Ov_StaticPtrCast(fb_stringport, commandPort))->v_value), order);
							}
							else if(Ov_CanCastTo(fb_anyport, commandPort))
							{
								ov_logfile_debug("Setting port \"CMD\" to: \"%s\".", order);
								Ov_SetAnyValue(&((Ov_StaticPtrCast(fb_anyport, commandPort))->v_value), &tempany);
							}
							else
							{
								ov_logfile_error("Port \"CMD\" is of wrong type.");
							}
						}
						else
						{
							ov_logfile_error("Port \"CMD\" not an input.");
						}
					}
					else
					{
						ov_logfile_error("Port \"CMD\" not found.");
					}
				}
			}
			/*	delete parsed message	*/
			Ov_DeleteObject(pMsg);
			ov_memstack_unlock();
		}
	}
	return;
}

