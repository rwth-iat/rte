
/******************************************************************************
*
*   FILE
*   ----
*   IOChannel.c
*
*   History
*   -------
*   2015-04-29   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_modbusTcpLib
#define OV_COMPILE_LIBRARY_modbusTcpLib
#endif


#include "modbusTcpLib.h"
#include "libov/ov_macros.h"


OV_DLLFNCEXPORT OV_RESULT modbusTcpLib_IOChannel_address_set(
    OV_INSTPTR_modbusTcpLib_IOChannel          pobj,
    const OV_INT  value
) {
	if(pobj->v_actimode == 1
			|| Ov_GetParent(modbusTcpLib_requestToChannel, pobj)
			|| Ov_GetParent(modbusTcpLib_toNextChannel, pobj)){
		return OV_ERR_NOACCESS;
	}
    pobj->v_address = value;
    return OV_ERR_OK;
}

OV_DLLFNCEXPORT void modbusTcpLib_IOChannel_typemethod(
	OV_INSTPTR_fb_functionblock	pfb,
	OV_TIME						*pltc
) {
   return;
}

OV_DLLFNCEXPORT OV_RESULT modbusTcpLib_IOChannel_constructor(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
    OV_INSTPTR_modbusTcpLib_IOChannel pinst = Ov_StaticPtrCast(modbusTcpLib_IOChannel, pobj);
    OV_INSTPTR_ov_domain	pParentDomain	=	NULL;
    OV_INSTPTR_modbusTcpLib_Slave	pSlave	=	NULL;
    OV_RESULT    result;

    /* do what the base class does first */
    result = fb_functionblock_constructor(pobj);
    if(Ov_Fail(result))
         return result;

    /* do what */
    pParentDomain = Ov_GetParent(ov_containment, pobj);
    if(!pParentDomain){
    	pParentDomain = Ov_StaticPtrCast(ov_domain, pobj->v_pouterobject);
    }
    if(pParentDomain){
    	pSlave = Ov_DynamicPtrCast(modbusTcpLib_Slave, pParentDomain);
    	if(!pSlave){
    		return OV_ERR_BADPATH;
    	}
    } else {
    	return OV_ERR_GENERIC;
    }
    return Ov_LinkPlaced(fb_tasklist, pSlave, pinst, OV_PMH_END);
}

OV_DLLFNCEXPORT OV_RESULT modbusTcpLib_IOChannel_rename(
	OV_INSTPTR_ov_object	pobj,
	OV_STRING				newid,
	OV_INSTPTR_ov_domain	pnewparent
) {
    /*    
    *   local variables
    */
	OV_INSTPTR_modbusTcpLib_Slave	pSlave	=	NULL;
	OV_INSTPTR_modbusTcpLib_IOChannel pinst = Ov_StaticPtrCast(modbusTcpLib_IOChannel, pobj);
	OV_INSTPTR_fb_task	pOldTask	=	NULL;
	OV_RESULT	result;
	pSlave = Ov_DynamicPtrCast(modbusTcpLib_Slave, pnewparent);
	if(!pSlave){
		return OV_ERR_BADPATH;
	}
	pOldTask = Ov_GetParent(fb_tasklist, pinst);
	Ov_Unlink(fb_tasklist, pOldTask, pinst);
	result = Ov_LinkPlaced(fb_tasklist, pSlave, pinst, OV_PMH_END);
	if(Ov_Fail(result)){
		Ov_LinkPlaced(fb_tasklist, pOldTask, pinst, OV_PMH_END);
		return result;
	}
	return OV_ERR_OK;
}

OV_DLLFNCEXPORT void modbusTcpLib_IOChannel_setErrorText(
		OV_INSTPTR_modbusTcpLib_IOChannel this
) {
	if(this->v_error){
		switch(this->v_errorCode){
		case 0x01:
			ov_string_setvalue(&this->v_errorText, "ILLEGAL FUNCTION");
			break;
		case 0x02:
			ov_string_setvalue(&this->v_errorText, "ILLEGAL DATA ADDRESS");
			break;
		case 0x03:
			ov_string_setvalue(&this->v_errorText, "ILLEGAL DATA VALUE");
			break;
		case 0x04:
			ov_string_setvalue(&this->v_errorText, "SLAVE DEVICE FAILURE");
			break;
		case 0x05:
			ov_string_setvalue(&this->v_errorText, "ACKNOWLEDGE");
			break;
		case 0x06:
			ov_string_setvalue(&this->v_errorText, "SLAVE DEVICE BUSY");
			break;
		case 0x08:
			ov_string_setvalue(&this->v_errorText, "MEMORY PARITY ERROR");
			break;
		case 0x0A:
			ov_string_setvalue(&this->v_errorText, "GATEWAY PATH UNAVAILABLE");
			break;
		case 0x0B:
			ov_string_setvalue(&this->v_errorText, "GATEWAY TARGET DEVICE FAILED TO RESPOND");
			break;
		default:
			ov_string_setvalue(&this->v_errorText, "unknown error code");
			break;
		}
	} else {
		ov_string_setvalue(&this->v_errorText, "no error");
	}
    return;
}

