
/******************************************************************************
 *
 *   FILE
 *   ----
 *   nodeStoreFunctions.c
 *
 *   History
 *   -------
 *   2014-10-21   File created
 *
 *******************************************************************************
 *
 *   This file is generated by the 'acplt_builder' command
 *
 ******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_opcua
#define OV_COMPILE_LIBRARY_opcua
#endif



#include "libov/ov_macros.h"
#include "ksbase.h"
#include "opcua.h"
#include "opcua_helpers.h"
#include "NoneTicketAuthenticator.h"
#include "libov/ov_path.h"
#include "libov/ov_memstack.h"
#include "ks_logfile.h"

extern OV_INSTPTR_opcua_uaServer opcua_pUaServer;

OV_DLLFNCEXPORT UA_Int32 opcua_nodeStoreFunctions_readNodes(
		void *ensHandle,
		const UA_RequestHeader *requestHeader,
		UA_ReadValueId *readValueIds,
		UA_UInt32 *indices,
		UA_UInt32 indicesSize,
		UA_DataValue *readNodesResults,
		UA_Boolean timeStampToReturn,
		UA_DiagnosticInfo *diagnosticInfos
) {

	OV_TICKET *pTicket = NULL;
	OV_PATH path;
	OV_INSTPTR_ov_object	pobj = NULL;
	OV_VTBLPTR_ov_object	pVtblObj = NULL;
	OV_ACCESS				access;
	OV_ANY					value = {.value.vartype = OV_VT_VOID, .value.valueunion.val_string = NULL, .state=OV_ST_UNKNOWN, .time.secs = 0, .time.usecs = 0};
	OV_ANY					emptyAny = {.value.vartype = OV_VT_VOID, .value.valueunion.val_string = NULL, .state=OV_ST_UNKNOWN, .time.secs = 0, .time.usecs = 0};
	pTicket = ksbase_NoneAuth->v_ticket.vtbl->createticket(NULL, OV_TT_NONE);


	for(OV_UINT i = 0; i<indicesSize;i++){
		KS_logfile_debug(("readNodes: iteration %u, index %u, attributeId %u...", i, indices[i], readValueIds[indices[i]].attributeId));
		switch(readValueIds[indices[i]].attributeId){
		/*******************************************************************************************************************************************
		 * NODEID - every type of node has one. we return the full canonical path to this node (including a part's name)
		 *******************************************************************************************************************************************/
		case UA_ATTRIBUTEID_NODEID:
			ov_memstack_lock();
			readNodesResults[indices[i]].status = opcua_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			readNodesResults[indices[i]].status = opcua_nodeStoreFunctions_getVtblPointerAndCheckAccess(&(path.elements[path.size-1]), pTicket, &pobj, &pVtblObj, &access);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			if(access & OV_AC_READ){
				UA_NodeId	*nodeId;
				OV_STRING 	tempStr1 = NULL;
				OV_STRING 	tempStr2 = NULL;
				nodeId = UA_NodeId_new();
				if(!nodeId){
					readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
					ov_memstack_unlock();
					break;
				}
				nodeId->namespaceIndex = readValueIds[indices[i]].nodeId.namespaceIndex;
				nodeId->identifierType = UA_NODEIDTYPE_STRING;
				switch(path.elements[path.size-1].elemtype){
				case OV_ET_OBJECT:
					nodeId->identifier.string = UA_String_fromChars(ov_path_getcanonicalpath(pobj, 2));
					if(nodeId->identifier.string.length == 0 && nodeId->identifier.string.data != UA_EMPTY_ARRAY_SENTINEL){
						readNodesResults[indices[i]].status = UA_STATUSCODE_BADOUTOFMEMORY;
					} else {
						readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
					}

					break;
				case OV_ET_VARIABLE:
				case OV_ET_MEMBER:
				case OV_ET_OPERATION:
					tempStr1 = ov_path_getcanonicalpath(path.elements[path.size-1].pobj, 2);
					if(!tempStr1){
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
						break;
					}
					if(!path.elements[path.size-1].elemunion.pobj){
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
						break;
					}
					tempStr2 = ov_memstack_alloc((strlen(tempStr1) + 1 + strlen(path.elements[path.size-1].elemunion.pobj->v_identifier) + 1) * sizeof(char));
					if(!tempStr1){
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
						break;
					}
					sprintf(tempStr2, "%s.%s", tempStr1, path.elements[path.size-1].elemunion.pobj->v_identifier);
					nodeId->identifier.string = UA_String_fromChars(tempStr2);
					if(nodeId->identifier.string.length == 0 && nodeId->identifier.string.data != UA_EMPTY_ARRAY_SENTINEL){
						readNodesResults[indices[i]].status = UA_STATUSCODE_BADOUTOFMEMORY;
					} else {
						readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
					}
					break;
				case OV_ET_PARENTLINK:
					tempStr1 = ov_path_getcanonicalpath(path.elements[path.size-1].pobj, 2);
					if(!tempStr1){
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
						break;
					}
					if(!path.elements[path.size-1].elemunion.passoc){
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
						break;
					}
					tempStr2 = ov_memstack_alloc((strlen(tempStr1) + 1 + strlen(path.elements[path.size-1].elemunion.passoc->v_parentrolename) + 1) * sizeof(char));
					if(!tempStr1){
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
						break;
					}
					sprintf(tempStr2, "%s.%s", tempStr1, path.elements[path.size-1].elemunion.passoc->v_parentrolename);
					nodeId->identifier.string = UA_String_fromChars(tempStr2);
					if(nodeId->identifier.string.length == 0 && nodeId->identifier.string.data != UA_EMPTY_ARRAY_SENTINEL){
						readNodesResults[indices[i]].status = UA_STATUSCODE_BADOUTOFMEMORY;
					} else {
						readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
					}
					break;
				case OV_ET_CHILDLINK:
					tempStr1 = ov_path_getcanonicalpath(path.elements[path.size-1].pobj, 2);
					if(!tempStr1){
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
						break;
					}
					if(!path.elements[path.size-1].elemunion.passoc){
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
						break;
					}
					tempStr2 = ov_memstack_alloc((strlen(tempStr1) + 1 + strlen(path.elements[path.size-1].elemunion.passoc->v_childrolename) + 1) * sizeof(char));
					if(!tempStr1){
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
						break;
					}
					sprintf(tempStr2, "%s.%s", tempStr1, path.elements[path.size-1].elemunion.passoc->v_childrolename);
					nodeId->identifier.string = UA_String_fromChars(tempStr2);
					if(nodeId->identifier.string.length == 0 && nodeId->identifier.string.data != UA_EMPTY_ARRAY_SENTINEL){
						readNodesResults[indices[i]].status = UA_STATUSCODE_BADOUTOFMEMORY;
					} else {
						readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
					}
					break;
				default:
					readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADOBJTYPE);
					break;
				}
				readNodesResults[indices[i]].value.type = &UA_TYPES[UA_TYPES_NODEID];
				readNodesResults[indices[i]].value.arrayLength = 0;
				readNodesResults[indices[i]].value.data = nodeId;
				readNodesResults[indices[i]].value.arrayDimensionsSize = 0;
				readNodesResults[indices[i]].value.arrayDimensions = NULL;
				readNodesResults[indices[i]].hasStatus = UA_TRUE;
				readNodesResults[indices[i]].hasValue = UA_TRUE;
			} else {
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_NOACCESS);
			}
			ov_memstack_unlock();
			break;
			/***************************************************************************************************************************************************
			 * NODECLASS - every type of node has one. we differentiate between Obejcts, Objecttypes (classes), variableTypes (instance of ov/variable) and
			 * 		referenceTypes (instances of ov/assiciation)
			 ***************************************************************************************************************************************************/
		case UA_ATTRIBUTEID_NODECLASS:
			ov_memstack_lock();
			readNodesResults[indices[i]].status = opcua_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			readNodesResults[indices[i]].status = opcua_nodeStoreFunctions_getVtblPointerAndCheckAccess(&(path.elements[path.size-1]), pTicket, &pobj, &pVtblObj, &access);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			if(access & OV_AC_READ){
				UA_NodeClass 	*nodeClass;
				nodeClass = UA_NodeClass_new();
				if(!nodeClass){
					readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
					ov_memstack_unlock();
					break;
				}
				switch(path.elements[path.size-1].elemtype){
				case OV_ET_OBJECT:
					if(Ov_GetParent(ov_instantiation, pobj) == pclass_ov_class){
						*nodeClass = UA_NODECLASS_OBJECTTYPE;
					} else if(Ov_GetParent(ov_instantiation, pobj) == pclass_ov_variable){
						*nodeClass = UA_NODECLASS_VARIABLETYPE;
					} else if(Ov_GetParent(ov_instantiation, pobj) == pclass_ov_association){
						*nodeClass = UA_NODECLASS_REFERENCETYPE;
					} else if(Ov_GetParent(ov_instantiation, pobj) == pclass_opcua_arguments){
						*nodeClass = UA_NODECLASS_VARIABLE;
					} else if(Ov_CanCastTo(opcua_methodNode, pobj)){
						*nodeClass = UA_NODECLASS_METHOD;
					} else{
						*nodeClass = UA_NODECLASS_OBJECT;
					}
					break;
				case OV_ET_VARIABLE:
				case OV_ET_MEMBER:
					*nodeClass = UA_NODECLASS_VARIABLE;
					break;
				case OV_ET_OPERATION:
					*nodeClass = UA_NODECLASS_METHOD;
					break;
				case OV_ET_CHILDLINK:
				case OV_ET_PARENTLINK:
				default:
					*nodeClass = UA_NODECLASS_UNSPECIFIED;
					break;
				}
				readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
				readNodesResults[indices[i]].value.type = &UA_TYPES[UA_TYPES_INT32];
				readNodesResults[indices[i]].value.arrayLength = 0;
				readNodesResults[indices[i]].value.data = nodeClass;
				readNodesResults[indices[i]].value.arrayDimensionsSize = 0;
				readNodesResults[indices[i]].value.arrayDimensions = NULL;
				readNodesResults[indices[i]].hasStatus = UA_TRUE;
				readNodesResults[indices[i]].hasValue = UA_TRUE;
			} else {
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_NOACCESS);
			}
			ov_memstack_unlock();
			break;
			/***************************************************************************************************************************************************
			 * BROWSENAME and DISPLYNAME - every type of node has these two. For us they're the same
			 * we return the objects identifier
			 ***************************************************************************************************************************************************/
		case UA_ATTRIBUTEID_BROWSENAME:
		case UA_ATTRIBUTEID_DISPLAYNAME:
			ov_memstack_lock();
			readNodesResults[indices[i]].status = opcua_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			readNodesResults[indices[i]].status = opcua_nodeStoreFunctions_getVtblPointerAndCheckAccess(&(path.elements[path.size-1]), pTicket, &pobj, &pVtblObj, &access);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			if(access & OV_AC_READ){
				if(pobj){
					readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
					if(readValueIds[indices[i]].attributeId == UA_ATTRIBUTEID_BROWSENAME){
						UA_QualifiedName* qName = UA_QualifiedName_new();
						qName->name = UA_String_fromChars(pobj->v_identifier);
						if(Ov_GetClassPtr(pobj) != pclass_opcua_arguments){
							qName->namespaceIndex = opcua_pUaServer->v_NameSpaceIndex;
						} else {
							qName->namespaceIndex = 0;
						}
						readNodesResults[indices[i]].value.type = &UA_TYPES[UA_TYPES_QUALIFIEDNAME];
						readNodesResults[indices[i]].value.data = qName;
					} else {
						UA_LocalizedText* lText = UA_LocalizedText_new();
						lText->locale = UA_String_fromChars("en");
						lText->text = UA_String_fromChars(pobj->v_identifier);
						readNodesResults[indices[i]].value.type = &UA_TYPES[UA_TYPES_LOCALIZEDTEXT];
						readNodesResults[indices[i]].value.data = lText;
					}
					readNodesResults[indices[i]].value.arrayLength = 0;
					readNodesResults[indices[i]].value.arrayDimensionsSize = 0;
					readNodesResults[indices[i]].value.arrayDimensions = NULL;
					readNodesResults[indices[i]].hasStatus = UA_TRUE;
					readNodesResults[indices[i]].hasValue = UA_TRUE;
					readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
				} else {
					readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADOBJTYPE);
				}
			} else {
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_NOACCESS);
			}
			ov_memstack_unlock();
			break;
			/**********************************************************************************************************************************************************
			 * DESCRIPTION - every type of node has one. We rturn the objects comment (from the class / variable)
			 **********************************************************************************************************************************************************/
		case UA_ATTRIBUTEID_DESCRIPTION:
			ov_memstack_lock();
			readNodesResults[indices[i]].status = opcua_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			readNodesResults[indices[i]].status = opcua_nodeStoreFunctions_getVtblPointerAndCheckAccess(&(path.elements[path.size-1]), pTicket, &pobj, &pVtblObj, &access);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			if(access & OV_AC_READ){
				if(pobj){
					OV_STRING tempString = pVtblObj->m_getcomment(pobj, &(path.elements[path.size-1]));
					UA_LocalizedText* lText = UA_LocalizedText_new();
					lText->locale = UA_String_fromChars("en");
					if(tempString){
						lText->text = UA_String_fromChars(tempString);
					} else {
						lText->text = UA_String_fromChars("");
					}
					readNodesResults[indices[i]].value.type = &UA_TYPES[UA_TYPES_LOCALIZEDTEXT];
					readNodesResults[indices[i]].value.data = lText;
					readNodesResults[indices[i]].value.arrayLength = 0;
					readNodesResults[indices[i]].value.arrayDimensionsSize = 0;
					readNodesResults[indices[i]].value.arrayDimensions = NULL;
					readNodesResults[indices[i]].hasStatus = UA_TRUE;
					readNodesResults[indices[i]].hasValue = UA_TRUE;
					readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
				}
			} else {
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_NOACCESS);
			}
			ov_memstack_unlock();
			break;
			/**********************************************************************************************************************************************************
			 * WRITEMASK and USERWRITEMAS - every type of node has these two. For objects we return writable names (a rename will do it). Nothing more
			 **********************************************************************************************************************************************************/
		case UA_ATTRIBUTEID_WRITEMASK:
		case UA_ATTRIBUTEID_USERWRITEMASK:
		{
			UA_UInt32 *writeMask;
			ov_memstack_lock();
			readNodesResults[indices[i]].status = opcua_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			if(readValueIds[indices[i]].attributeId == UA_ATTRIBUTEID_WRITEMASK){
				readNodesResults[indices[i]].status = opcua_nodeStoreFunctions_getVtblPointerAndCheckAccess(&(path.elements[path.size-1]), NULL, &pobj, &pVtblObj, &access);
			} else {
				readNodesResults[indices[i]].status = opcua_nodeStoreFunctions_getVtblPointerAndCheckAccess(&(path.elements[path.size-1]), pTicket, &pobj, &pVtblObj, &access);
			}
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			writeMask = UA_UInt32_new();
			if(!writeMask){
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
				ov_memstack_unlock();
				break;
			}
			*writeMask = 0;
			if(path.elements[path.size-1].elemtype != OV_ET_VARIABLE){
				if(access & OV_AC_WRITE){
					*writeMask |= (1<<2);	/*	BrowseName	*/
					*writeMask |= (1<<6);	/*	DisplayName	*/
				}
				if(access & OV_AC_RENAMEABLE){
					*writeMask |= (1<<14);	/*	NodeId	*/
				}
			}
			readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
			readNodesResults[indices[i]].value.type = &UA_TYPES[UA_TYPES_UINT32];
			readNodesResults[indices[i]].value.arrayLength = 0;
			readNodesResults[indices[i]].value.data = writeMask;
			readNodesResults[indices[i]].value.arrayDimensionsSize = 0;
			readNodesResults[indices[i]].value.arrayDimensions = NULL;
			readNodesResults[indices[i]].hasStatus = UA_TRUE;
			readNodesResults[indices[i]].hasValue = UA_TRUE;
			ov_memstack_unlock();
		}
		break;
		/*********************************************************************************************************************************************
		 * ISABSTRACT - Objecttypes, VariableTypes and ReferenceTypes have it. ov only knows abstract Objecttypes which is returned. Other types return FALSE
		 *********************************************************************************************************************************************/
		case UA_ATTRIBUTEID_ISABSTRACT:
		{
			UA_Boolean *isAbstract;
			ov_memstack_lock();
			readNodesResults[indices[i]].status = opcua_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			readNodesResults[indices[i]].status = opcua_nodeStoreFunctions_getVtblPointerAndCheckAccess(&(path.elements[path.size-1]), pTicket, &pobj, &pVtblObj, &access);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			if(path.elements[path.size-1].elemtype == OV_ET_OBJECT){
				if(Ov_GetParent(ov_instantiation, pobj) == pclass_ov_class){
					isAbstract = UA_Boolean_new();
					if(!isAbstract){
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
						ov_memstack_unlock();
						break;
					}
					if(!(Ov_StaticPtrCast(ov_class, pobj)->v_classprops & OV_CP_INSTANTIABLE)){
						*isAbstract = UA_TRUE; /*	is instantiable is the negation of isAbstract	*/
					} else {
						*isAbstract = UA_FALSE;
					}
				} else if(Ov_GetParent(ov_instantiation, pobj) == pclass_ov_variable){
					isAbstract = UA_Boolean_new();
					if(!isAbstract){
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
						ov_memstack_unlock();
						break;
					}
					*isAbstract = UA_FALSE;
				} else if(Ov_GetParent(ov_instantiation, pobj) == pclass_ov_association){
					isAbstract = UA_Boolean_new();
					if(!isAbstract){
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
						ov_memstack_unlock();
						break;
					}
					*isAbstract = UA_FALSE;
				} else {
					readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADOBJTYPE);
					ov_memstack_unlock();
					break;
				}
			} else {
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADOBJTYPE);
				ov_memstack_unlock();
				break;
			}
			readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
			readNodesResults[indices[i]].value.type = &UA_TYPES[UA_TYPES_BOOLEAN];
			readNodesResults[indices[i]].value.arrayLength = 0;
			readNodesResults[indices[i]].value.data = isAbstract;
			readNodesResults[indices[i]].value.arrayDimensionsSize = 0;
			readNodesResults[indices[i]].value.arrayDimensions = NULL;
			readNodesResults[indices[i]].hasStatus = UA_TRUE;
			readNodesResults[indices[i]].hasValue = UA_TRUE;
			ov_memstack_unlock();
		}
		break;
		/*********************************************************************************************************************************************
		 * SYMMETRIC - References have it. ov only knows directed references, so we return FALSE
		 *********************************************************************************************************************************************/
		case UA_ATTRIBUTEID_SYMMETRIC:
		{
			UA_Boolean *isSymmetric;
			ov_memstack_lock();
			readNodesResults[indices[i]].status = opcua_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			readNodesResults[indices[i]].status = opcua_nodeStoreFunctions_getVtblPointerAndCheckAccess(&(path.elements[path.size-1]), pTicket, &pobj, &pVtblObj, &access);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			if(path.elements[path.size-1].elemtype == OV_ET_OBJECT){
				if(Ov_GetParent(ov_instantiation, pobj) == pclass_ov_association){
					isSymmetric = UA_Boolean_new();
					if(!isSymmetric){
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
						break;
					}
					*isSymmetric = UA_FALSE;	/*	all ov_associations have a direction	*/
				} else {
					readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADOBJTYPE);
					ov_memstack_unlock();
					break;
				}
			} else {
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADOBJTYPE);
				ov_memstack_unlock();
				break;
			}
			readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
			readNodesResults[indices[i]].value.type = &UA_TYPES[UA_TYPES_BOOLEAN];
			readNodesResults[indices[i]].value.arrayLength = 0;
			readNodesResults[indices[i]].value.data = isSymmetric;
			readNodesResults[indices[i]].value.arrayDimensionsSize = 0;
			readNodesResults[indices[i]].value.arrayDimensions = NULL;
			readNodesResults[indices[i]].hasStatus = UA_TRUE;
			readNodesResults[indices[i]].hasValue = UA_TRUE;
			ov_memstack_unlock();
		}
		break;
		/*********************************************************************************************************************************************
		 * INVERSENAME - Reference have it. but ov does not know it
		 *********************************************************************************************************************************************/
		case UA_ATTRIBUTEID_INVERSENAME:	/*	optional and not really a meaningfull mirror in ov (as we define a reference as an assiciation whereas UA defines a reference as one end of an association)	*/
			readNodesResults[indices[i]].status = UA_STATUSCODE_BADNOTIMPLEMENTED;
			break;
			/*********************************************************************************************************************************************
			 * CONTAINSNOLOOPS - Views have it. ov has no views
			 *********************************************************************************************************************************************/
		case UA_ATTRIBUTEID_CONTAINSNOLOOPS:	/*	ov has no view nodes	*/
			readNodesResults[indices[i]].status = UA_STATUSCODE_BADNOTIMPLEMENTED;
			break;
			/*********************************************************************************************************************************************
			 * EVENTNOTIFIER - Objects have it. ov does not support notification, so we return 0
			 *********************************************************************************************************************************************/
		case UA_ATTRIBUTEID_EVENTNOTIFIER:
		{
			UA_Byte *eventNotifer;
			ov_memstack_lock();
			readNodesResults[indices[i]].status = opcua_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			eventNotifer = UA_Byte_new();
			if(!eventNotifer){
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
				ov_memstack_unlock();
				break;
			}
			*eventNotifer = 0;

			readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
			readNodesResults[indices[i]].value.type = &UA_TYPES[UA_TYPES_BYTE];
			readNodesResults[indices[i]].value.arrayLength = 0;
			readNodesResults[indices[i]].value.data = eventNotifer;
			readNodesResults[indices[i]].value.arrayDimensionsSize = 0;
			readNodesResults[indices[i]].value.arrayDimensions = NULL;
			readNodesResults[indices[i]].hasStatus = UA_TRUE;
			readNodesResults[indices[i]].hasValue = UA_TRUE;
			ov_memstack_unlock();
		}
		break;
		/*********************************************************************************************************************************************
		 * VALUE - Variables and VariableTypes have it. First return the current value the latter return the default value
		 *********************************************************************************************************************************************/
		case UA_ATTRIBUTEID_VALUE:
			ov_memstack_lock();
			readNodesResults[indices[i]].status = opcua_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			pobj = path.elements[path.size-1].pobj;
			Ov_GetVTablePtr(ov_object, pVtblObj, pobj);
			if((!pVtblObj) || (ov_activitylock)){
				pVtblObj = pclass_ov_object->v_pvtable;
			}
			access = (pVtblObj)->m_getaccess(path.elements[path.size-1].pobj, &(path.elements[path.size-1]), pTicket);
			if(access & OV_AC_READ){
				switch(path.elements[path.size-1].elemtype) {
				case OV_ET_MEMBER:
				case OV_ET_VARIABLE:
					readNodesResults[indices[i]].status = ov_resultToUaStatusCode((pVtblObj->m_getvar)(pobj, &(path.elements[path.size-1]), &value));
					value.value.vartype &= OV_VT_KSMASK;
					if(readNodesResults[indices[i]].status == UA_STATUSCODE_GOOD){
						readNodesResults[indices[i]].status = ov_AnyToVariant(&value, &(readNodesResults[indices[i]].value));
						readNodesResults[indices[i]].hasStatus = UA_TRUE;
						readNodesResults[indices[i]].hasValue = UA_TRUE;
						value = emptyAny;
					}
					break;
				case OV_ET_OBJECT:
					/*	Variables are defined by instances of ov/variable	*/
					if(Ov_GetParent(ov_instantiation, pobj) == pclass_ov_variable){
						readNodesResults[indices[i]].status = ov_AnyToVariant(ov_variable_initialvalue_get(Ov_StaticPtrCast(ov_variable,pobj)), &(readNodesResults[indices[i]].value));
						readNodesResults[indices[i]].hasStatus = UA_TRUE;
						readNodesResults[indices[i]].hasValue = UA_TRUE;
					} else if(Ov_GetParent(ov_instantiation, pobj) == pclass_opcua_arguments){
						size_t numberofArgs = 0;
						UA_Argument *argArray = NULL;
						readNodesResults[indices[i]].status = opcua_nodeStoreFunctions_getCallArgs((OV_INSTPTR_opcua_arguments)pobj, &numberofArgs, &argArray);
						readNodesResults[indices[i]].value.type = &UA_TYPES[UA_TYPES_ARGUMENT];
						readNodesResults[indices[i]].value.arrayLength = numberofArgs;
						readNodesResults[indices[i]].value.data = argArray;
						readNodesResults[indices[i]].hasStatus = UA_TRUE;
						readNodesResults[indices[i]].hasValue = UA_TRUE;
					} else {
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADPATH);
					}
					break;
				default:
					readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADPATH);
					break;
				}
				ov_memstack_unlock();
			} else {
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_NOACCESS);
				ov_memstack_unlock();
			}
			break;
			/*********************************************************************************************************************************************
			 * DATATYPE - Variables and VariableTypes have it.
			 *********************************************************************************************************************************************/
		case UA_ATTRIBUTEID_DATATYPE:
		{
			UA_NodeId *dataType = NULL;
			ov_memstack_lock();
			readNodesResults[indices[i]].status = opcua_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			pobj = path.elements[path.size-1].pobj;
			Ov_GetVTablePtr(ov_object, pVtblObj, pobj);
			if((!pVtblObj) || (ov_activitylock)){
				pVtblObj = pclass_ov_object->v_pvtable;
			}
			access = (pVtblObj)->m_getaccess(path.elements[path.size-1].pobj, &(path.elements[path.size-1]), pTicket);
			if(access & OV_AC_READ){
				switch(path.elements[path.size-1].elemtype) {
				case OV_ET_MEMBER:
				case OV_ET_VARIABLE:
					pobj = Ov_StaticPtrCast(ov_object, path.elements[path.size-1].elemunion.pvar);
					if(Ov_GetParent(ov_instantiation, pobj) == pclass_ov_variable){
						dataType = UA_NodeId_new();
						if(!dataType){
							readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
							break;
						} else {
							readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
							*dataType = ov_varTypeToNodeId(((OV_INSTPTR_ov_variable)pobj)->v_vartype);
						}
					}
					break;
				case OV_ET_OBJECT:
					/*	Variables are defined by instances of ov/variable	*/
					if(Ov_GetParent(ov_instantiation, pobj) == pclass_ov_variable){
						dataType = UA_NodeId_new();
						if(!dataType){
							readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
							break;
						} else {
							readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
							*dataType = ov_varTypeToNodeId(ov_variable_vartype_get(Ov_StaticPtrCast(ov_variable,pobj)));
						}
					} else if(Ov_GetParent(ov_instantiation, pobj) == pclass_opcua_arguments){
						dataType = UA_NodeId_new();
						if(!dataType){
							readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
						} else {
							readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
							dataType->identifierType = UA_NODEIDTYPE_NUMERIC;
							dataType->namespaceIndex = 0;
							dataType->identifier.numeric = 296;
						}
						break;
					} else {
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADPATH);
						break;
					}
				default:
					readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADPATH);
					break;
				}
			} else {
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_NOACCESS);
			}
			if(readNodesResults[indices[i]].status == UA_STATUSCODE_GOOD){
				readNodesResults[indices[i]].value.type = &UA_TYPES[UA_TYPES_NODEID];
				readNodesResults[indices[i]].value.arrayLength = 0;
				readNodesResults[indices[i]].value.data = dataType;
				readNodesResults[indices[i]].value.arrayDimensionsSize = 0;
				readNodesResults[indices[i]].value.arrayDimensions = NULL;
				readNodesResults[indices[i]].hasStatus = UA_TRUE;
				readNodesResults[indices[i]].hasValue = UA_TRUE;
			}
			ov_memstack_unlock();
		}
		break;
		/*********************************************************************************************************************************************
		 * VALUERANK - Variables and VariableTypes have it. returns the number of dimensions a variable has (scalar, one dimensional array, or both possible)
		 *********************************************************************************************************************************************/
		case UA_ATTRIBUTEID_VALUERANK:
		{
			UA_Int32 *valueRank = NULL;
			ov_memstack_lock();
			readNodesResults[indices[i]].status = opcua_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			pobj = path.elements[path.size-1].pobj;
			Ov_GetVTablePtr(ov_object, pVtblObj, pobj);
			if((!pVtblObj) || (ov_activitylock)){
				pVtblObj = pclass_ov_object->v_pvtable;
			}
			access = (pVtblObj)->m_getaccess(path.elements[path.size-1].pobj, &(path.elements[path.size-1]), pTicket);
			if(access & OV_AC_READ){
				switch(path.elements[path.size-1].elemtype) {
				case OV_ET_MEMBER:
				case OV_ET_VARIABLE:
					pobj = Ov_StaticPtrCast(ov_object, path.elements[path.size-1].elemunion.pvar);
					if(Ov_GetParent(ov_instantiation, pobj) == pclass_ov_variable){
						valueRank = UA_Int32_new();
						if(!valueRank){
							readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
							break;
						}
						switch((((OV_INSTPTR_ov_variable)pobj)->v_vartype) & OV_VT_KSMASK){
						case OV_VT_ANY:
						case OV_VT_VOID:
							*valueRank = -3;	/*	scalar or one dimension	*/
							readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
							break;
						default:
							if((((OV_INSTPTR_ov_variable)pobj)->v_vartype) & OV_VT_ISVECTOR){
								*valueRank = 1;	/*	one dimension	*/
								readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
							} else {
								*valueRank = -1;	/*	scalar	*/
								readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
							}
							break;
						}
					}
					break;
				case OV_ET_OBJECT:
					if(Ov_GetParent(ov_instantiation, pobj) == pclass_ov_variable){
						valueRank = UA_Int32_new();
						if(!valueRank){
							readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
							break;
						}
						switch((((OV_INSTPTR_ov_variable)pobj)->v_vartype) & OV_VT_KSMASK){
						case OV_VT_ANY:
						case OV_VT_VOID:
							*valueRank = -3;	/*	scalar or one dimension	*/
							readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
							break;
						default:
							if((((OV_INSTPTR_ov_variable)pobj)->v_vartype) & OV_VT_ISVECTOR){
								*valueRank = 1;	/*	one dimension	*/
								readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
							} else {
								*valueRank = -1;	/*	scalar	*/
								readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
							}
							break;
						}
					} else if(Ov_GetParent(ov_instantiation, pobj) == pclass_opcua_arguments){
						valueRank = UA_Int32_new();
						if(!valueRank){
							readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
							break;
						}
						*valueRank = 1;	/*	one dimension	*/
						readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
						break;
					} else {
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADTYPE);
						break;
					}
					break;
				default:
					readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADPATH);
					break;
				}
			} else {
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_NOACCESS);
			}

			if(readNodesResults[indices[i]].status == UA_STATUSCODE_GOOD){
				readNodesResults[indices[i]].value.type = &UA_TYPES[UA_TYPES_INT32];
				readNodesResults[indices[i]].value.arrayLength = 0;
				readNodesResults[indices[i]].value.data = valueRank;
				readNodesResults[indices[i]].value.arrayDimensionsSize = 0;
				readNodesResults[indices[i]].value.arrayDimensions = NULL;
				readNodesResults[indices[i]].hasStatus = UA_TRUE;
				readNodesResults[indices[i]].hasValue = UA_TRUE;
			}
			ov_memstack_unlock();
		}
		break;
		/*********************************************************************************************************************************************
		 * ARRAYDIMENSIONS - Variables and VariableTypes have it. returns the number elements each dimension of a variable can take
		 *********************************************************************************************************************************************/
		case UA_ATTRIBUTEID_ARRAYDIMENSIONS:
		{
			UA_Int32 *arrayDimensions;
			UA_Int32 arrayLength = 0;
			ov_memstack_lock();
			readNodesResults[indices[i]].status = opcua_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			pobj = path.elements[path.size-1].pobj;
			Ov_GetVTablePtr(ov_object, pVtblObj, pobj);
			if((!pVtblObj) || (ov_activitylock)){
				pVtblObj = pclass_ov_object->v_pvtable;
			}
			access = (pVtblObj)->m_getaccess(path.elements[path.size-1].pobj, &(path.elements[path.size-1]), pTicket);
			if(access & OV_AC_READ){
				switch(path.elements[path.size-1].elemtype) {
				case OV_ET_MEMBER:
				case OV_ET_VARIABLE:
					pobj = Ov_StaticPtrCast(ov_object, path.elements[path.size-1].elemunion.pvar);
					if(Ov_CanCastTo(ov_variable, pobj)){
						switch((((OV_INSTPTR_ov_variable)pobj)->v_vartype) & OV_VT_KSMASK){
						case OV_VT_ANY:
						case OV_VT_VOID:
							arrayLength = 0;
							arrayDimensions = UA_Array_new(arrayLength, &UA_TYPES[UA_TYPES_INT32]);	/*	scalar or one dimension	*/
							break;
						default:
							if(((OV_INSTPTR_ov_variable)pobj)->v_veclen == 1){
								/*	scalar	*/
								arrayLength = 0;
								arrayDimensions = UA_Array_new(arrayLength, &UA_TYPES[UA_TYPES_INT32]);	/*	scalar or one dimension	*/
							} else {
								/*	vector	*/
								arrayLength = 1;
								arrayDimensions = UA_Array_new( arrayLength, &UA_TYPES[UA_TYPES_INT32]);	/*	scalar or one dimension	*/
								if(!arrayDimensions){
									readNodesResults[indices[i]].status = UA_STATUSCODE_BADOUTOFMEMORY;
									break;
								} else {
									readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
								}
								readNodesResults[indices[i]].status = UA_Array_copy(&(((OV_INSTPTR_ov_variable)pobj)->v_veclen), arrayLength, (void**)&arrayDimensions, &UA_TYPES[UA_TYPES_INT32]);
								break;
							}
						}
					}
					break;
				case OV_ET_OBJECT:
					pobj = Ov_StaticPtrCast(ov_object, path.elements[path.size-1].pobj);
					if(Ov_CanCastTo(ov_variable, pobj)){
						switch((((OV_INSTPTR_ov_variable)pobj)->v_vartype) & OV_VT_KSMASK){
						case OV_VT_ANY:
						case OV_VT_VOID:
							arrayLength = 0;
							arrayDimensions = UA_Array_new(arrayLength, &UA_TYPES[UA_TYPES_INT32]);	/*	scalar or one dimension	*/
							break;
						default:
							if(((OV_INSTPTR_ov_variable)pobj)->v_veclen == 1){
								/*	scalar	*/
								arrayLength = 0;
								arrayDimensions = UA_Array_new(arrayLength, &UA_TYPES[UA_TYPES_INT32]);	/*	scalar or one dimension	*/
							} else {
								/*	vector	*/
								arrayLength = 1;
								arrayDimensions = UA_Array_new(arrayLength, &UA_TYPES[UA_TYPES_INT32]);	/*	scalar or one dimension	*/
								if(!arrayDimensions){
									readNodesResults[indices[i]].status = UA_STATUSCODE_BADOUTOFMEMORY;
									break;
								} else {
									readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
								}
								readNodesResults[indices[i]].status = UA_Array_copy(&(((OV_INSTPTR_ov_variable)pobj)->v_veclen), arrayLength, (void**)&arrayDimensions, &UA_TYPES[UA_TYPES_INT32]);
								break;
							}
						}
					}else if(Ov_GetParent(ov_instantiation, pobj) == pclass_opcua_arguments){
						arrayDimensions = 0;
					} else {
						readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADTYPE);
						break;
					}
					break;
				default:
					readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADPATH);
					break;
				}
				if(readNodesResults[indices[i]].status == UA_STATUSCODE_GOOD){
					readNodesResults[indices[i]].value.type = &UA_TYPES[UA_TYPES_INT32];
					readNodesResults[indices[i]].value.arrayLength = arrayLength;
					readNodesResults[indices[i]].value.data = arrayDimensions;
					readNodesResults[indices[i]].value.arrayDimensionsSize = 0;
					readNodesResults[indices[i]].value.arrayDimensions = NULL;
					readNodesResults[indices[i]].hasStatus = UA_TRUE;
					readNodesResults[indices[i]].hasValue = UA_TRUE;
				}
				ov_memstack_unlock();
			} else {
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_NOACCESS);
				ov_memstack_unlock();
			}
		}
		break;
		/*****************************************************************************************************************************************************
		 * ACCESSLEVEL and USERACCESSLEVEL - variables have it. We return the rights of current read and current write according to the ov-access flags
		 * 		all other types of access are unknown to ov and so denied
		 ****************************************************************************************************************************************************/
		case UA_ATTRIBUTEID_ACCESSLEVEL:
		case UA_ATTRIBUTEID_USERACCESSLEVEL:
		{
			UA_Byte *accessLevel;
			ov_memstack_lock();
			readNodesResults[indices[i]].status = opcua_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			if(readValueIds[indices[i]].attributeId == UA_ATTRIBUTEID_ACCESSLEVEL){
				readNodesResults[indices[i]].status = opcua_nodeStoreFunctions_getVtblPointerAndCheckAccess(&(path.elements[path.size-1]), NULL, &pobj, &pVtblObj, &access);
			} else {
				readNodesResults[indices[i]].status = opcua_nodeStoreFunctions_getVtblPointerAndCheckAccess(&(path.elements[path.size-1]), pTicket, &pobj, &pVtblObj, &access);
			}
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			accessLevel = UA_Byte_new();
			if(!accessLevel){
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
				ov_memstack_unlock();
				break;
			}
			*accessLevel = 0;
			if(access & OV_AC_READ){
				*accessLevel |= (1<<0);
			}
			if(access & OV_AC_WRITE){
				*accessLevel |= (1<<1);
			}

			readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
			readNodesResults[indices[i]].value.type = &UA_TYPES[UA_TYPES_BYTE];
			readNodesResults[indices[i]].value.arrayLength = 0;
			readNodesResults[indices[i]].value.data = accessLevel;
			readNodesResults[indices[i]].value.arrayDimensionsSize = 0;
			readNodesResults[indices[i]].value.arrayDimensions = NULL;
			readNodesResults[indices[i]].hasStatus = UA_TRUE;
			readNodesResults[indices[i]].hasValue = UA_TRUE;
			ov_memstack_unlock();
		}
		break;

		/********************************************************************************************************************************************************
		 * MINIMUMSAMPLINGINTERVAL - variables have it. ov has no means to get such a value from a variables.
		 * 		despite we can determine cyctimes of fbs or comtasks, this is not visible in the ov metamodel
		 ********************************************************************************************************************************************************/
		case UA_ATTRIBUTEID_MINIMUMSAMPLINGINTERVAL:
		{
			UA_Double *interval;
			ov_memstack_lock();
			readNodesResults[indices[i]].status = opcua_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			interval = UA_Double_new();
			if(!interval){
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
				ov_memstack_unlock();
				break;
			}
			*interval =  -1;

			readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
			readNodesResults[indices[i]].value.type = &UA_TYPES[UA_TYPES_DOUBLE];
			readNodesResults[indices[i]].value.arrayLength = 0;
			readNodesResults[indices[i]].value.data = interval;
			readNodesResults[indices[i]].value.arrayDimensionsSize = 0;
			readNodesResults[indices[i]].value.arrayDimensions = NULL;
			readNodesResults[indices[i]].hasStatus = UA_TRUE;
			readNodesResults[indices[i]].hasValue = UA_TRUE;
			ov_memstack_unlock();
		}
		break;
		/********************************************************************************************************************************************************
		* HISTORIZING - variables have it. ov has no means to get such a value from a variables.
		* 		despite we can have histories using the ov/kshistlib this is not part of the ov-metamodel
		*********************************************************************************************************************************************************/
		case UA_ATTRIBUTEID_HISTORIZING:
		{
			UA_Boolean *historizing;
			ov_memstack_lock();
			readNodesResults[indices[i]].status = opcua_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			historizing = UA_Boolean_new();
			if(!historizing){
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
				ov_memstack_unlock();
				break;
			}
			*historizing = UA_FALSE;

			readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
			readNodesResults[indices[i]].value.type = &UA_TYPES[UA_TYPES_BOOLEAN];
			readNodesResults[indices[i]].value.arrayLength = 0;
			readNodesResults[indices[i]].value.data = historizing;
			readNodesResults[indices[i]].value.arrayDimensionsSize = 0;
			readNodesResults[indices[i]].value.arrayDimensions = NULL;
			readNodesResults[indices[i]].hasStatus = UA_TRUE;
			readNodesResults[indices[i]].hasValue = UA_TRUE;
			ov_memstack_unlock();
		}
		break;
		/****************************************************************************************************************************************************
		 * EXECUTABLE and USEREXECUTABLE - methods have it. methods (or operations) in ov are generally not accessible from the outside world
		 * 		despite services are accessible from the outside world, they are specific instances of user-defined classes and not part of the ov-metamodel
		 ****************************************************************************************************************************************************/
		case UA_ATTRIBUTEID_EXECUTABLE:
		case UA_ATTRIBUTEID_USEREXECUTABLE:
		{
			UA_Boolean *executable;
			ov_memstack_lock();
			readNodesResults[indices[i]].status = opcua_nodeStoreFunctions_resolveNodeIdToPath(readValueIds[indices[i]].nodeId, &path);
			if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD){
				ov_memstack_unlock();
				break;
			}
			if(path.elements[path.size-1].elemtype == OV_ET_OPERATION){
				executable = UA_Boolean_new();
				if(!executable){
					readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
					ov_memstack_unlock();
					break;
				}
				*executable = UA_FALSE;
				readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
				readNodesResults[indices[i]].value.type = &UA_TYPES[UA_TYPES_BOOLEAN];
				readNodesResults[indices[i]].value.arrayLength = 0;
				readNodesResults[indices[i]].value.data = executable;
				readNodesResults[indices[i]].value.arrayDimensionsSize = 0;
				readNodesResults[indices[i]].value.arrayDimensions = NULL;
				readNodesResults[indices[i]].hasStatus = UA_TRUE;
				readNodesResults[indices[i]].hasValue = UA_TRUE;
				ov_memstack_unlock();
			} else if(path.elements[path.size-1].elemtype == OV_ET_OBJECT && Ov_CanCastTo(opcua_methodNode, path.elements[path.size-1].pobj)){
				/*	we have a methodNode	*/
				OV_INSTPTR_opcua_methodNode pMethod = Ov_StaticPtrCast(opcua_methodNode, path.elements[path.size-1].pobj);
				executable = UA_Boolean_new();
				if(!executable){
					readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_HEAPOUTOFMEMORY);
					ov_memstack_unlock();
					break;
				}
				*executable = pMethod->v_callable;
				readNodesResults[indices[i]].status = UA_STATUSCODE_GOOD;
				readNodesResults[indices[i]].value.type = &UA_TYPES[UA_TYPES_BOOLEAN];
				readNodesResults[indices[i]].value.arrayLength = 0;
				readNodesResults[indices[i]].value.data = executable;
				readNodesResults[indices[i]].value.arrayDimensionsSize = 0;
				readNodesResults[indices[i]].value.arrayDimensions = NULL;
				readNodesResults[indices[i]].hasStatus = UA_TRUE;
				readNodesResults[indices[i]].hasValue = UA_TRUE;
				ov_memstack_unlock();
			} else {
				readNodesResults[indices[i]].status = ov_resultToUaStatusCode(OV_ERR_BADOBJTYPE);
				ov_memstack_unlock();
				break;
			}
		}
		break;
		/*****************************************************************************************************************************************************
		 * wtf???
		 ****************************************************************************************************************************************************/
		default:
			KS_logfile_info(("opcua: got a read-request with bad attributeid (%#08x)", readValueIds[indices[i]].attributeId));
			readNodesResults[indices[i]].status = UA_STATUSCODE_BADATTRIBUTEIDINVALID;
			break;
		}

		if(readNodesResults[indices[i]].status != UA_STATUSCODE_GOOD) {
			readNodesResults[indices[i]].hasStatus = UA_TRUE;
			readNodesResults[indices[i]].hasValue = UA_FALSE;
		}
	}
	KS_logfile_debug(("Done."));
	return UA_STATUSCODE_GOOD;
}

