
/******************************************************************************
*
*   FILE
*   ----
*   setVar.c
*
*   History
*   -------
*   2013-05-14   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_ksapi
#define OV_COMPILE_LIBRARY_ksapi
#endif


#include "ksapi.h"
#include "libov/ov_macros.h"
#include "ksapi_commonFuncs.h"
#include "ks_logfile.h"
#include "ksbase_helper.h"


void ksapi_setVar_callback(const OV_INSTPTR_ov_domain this, const OV_INSTPTR_ov_domain that);


OV_DLLFNCEXPORT OV_RESULT ksapi_setVar_constructor(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
     OV_RESULT    result;

    /* do what the base class does first */
    result = ksapi_variableOperation_constructor(pobj);
    if(Ov_Fail(result))
         return result;

    /* do what */

    return OV_ERR_OK;
}

OV_DLLFNCEXPORT void ksapi_setVar_destructor(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
    /* destroy object */
    ksapi_variableOperation_destructor(pobj);

    return;
}

OV_DLLFNCEXPORT void ksapi_setVar_startup(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */

    /* do what the base class does first */
    ksapi_variableOperation_startup(pobj);

    /* do what */

    return;
}

OV_DLLFNCEXPORT void ksapi_setVar_shutdown(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */

    /* do what */

    /* set the object's state to "shut down" */
    ksapi_KSApiCommon_shutdown(pobj);

    return;
}

OV_DLLFNCEXPORT void ksapi_setVar_submit(
	OV_INSTPTR_ksapi_KSApiCommon          pobj
) {
    OV_INSTPTR_ksapi_setVar	pthis = Ov_StaticPtrCast(ksapi_setVar, pobj);
	OV_INSTPTR_ksbase_ClientBase pClient = NULL;
    OV_VTBLPTR_ksbase_ClientBase pVtblClient = NULL;
    OV_INSTPTR_ksapi_Variable pCurrVar = NULL;
    OV_RESULT result;
    OV_SETVAR_ITEM* items = NULL;
    OV_UINT numberOfItems = 1;

    result = ksapi_KSApiCommon_prepareSubmit(pobj, &pClient, &pVtblClient);
    if(Ov_Fail(result))
    	return;

    items = Ov_HeapMalloc(numberOfItems * sizeof(OV_SETVAR_ITEM));
    if(!items)
    {
    	pthis->v_status = KSAPI_COMMON_INTERNALERROR;
    	pthis->v_result = OV_ERR_HEAPOUTOFMEMORY;
    	return;
    }
    if(pthis->v_path)
    {
    	items[0].path_and_name = pthis->v_path;	/*	see comment below	*/
    	items[0].var_current_props = pthis->v_varValue;
    }
    else
    {
    	KS_logfile_error(("%s: submit: own Variable has empty path", pobj->v_identifier));
    	pthis->v_status = KSAPI_COMMON_INTERNALERROR;
    	pthis->v_result = result;
    	Ov_HeapFree(items);
    	return;
    }
    /*	iterate over variable objects in containment and linked ones and add them to the package	*/
    Ov_ForEachChildEx(ov_containment, pthis, pCurrVar, ksapi_Variable)
    {
    	if(!pCurrVar->v_order)
    	{/*	variable not processed yet	*/
    		numberOfItems++;
    		items = Ov_HeapRealloc(items, numberOfItems * sizeof(OV_SETVAR_ITEM));
    		if(!items)
    		{
    			pthis->v_status = KSAPI_COMMON_INTERNALERROR;
    			pthis->v_result = OV_ERR_HEAPOUTOFMEMORY;
    			return;
    		}
    		if(pCurrVar->v_path)
    		{
    			items[numberOfItems-1].path_and_name = pCurrVar->v_path;	/*	the string will not be changed, so we do not need to copy it	*/
    			items[numberOfItems-1].var_current_props = pCurrVar->v_varValue; /*	we do not need to copy either	*/
    			pCurrVar->v_order = numberOfItems;
    		}
    		else
    		{
    			KS_logfile_error(("%s: submit: Variable %s has empty path", pobj->v_identifier, pCurrVar->v_identifier));
    			pthis->v_status = KSAPI_COMMON_INTERNALERROR;
    			pthis->v_result = result;
    			Ov_HeapFree(items);
    			return;
    		}
    	}
    }

    Ov_ForEachChild(ksapi_operationToVariable, pthis, pCurrVar)
    {
    	if(!pCurrVar->v_order)
    	{	/*	variable not processed yet	*/
    		numberOfItems++;
    		items = Ov_HeapRealloc(items, numberOfItems * sizeof(OV_SETVAR_ITEM));
    		if(!items)
    		{
    			pthis->v_status = KSAPI_COMMON_INTERNALERROR;
    			pthis->v_result = OV_ERR_HEAPOUTOFMEMORY;
    			return;
    		}
    		if(pCurrVar->v_path)
    		{
    			items[numberOfItems-1].path_and_name = pCurrVar->v_path;	/*	the string will not be changed, so we do not need to copy it	*/
    			items[numberOfItems-1].var_current_props = pCurrVar->v_varValue; /*	we do not need to copy either	*/
    			pCurrVar->v_order = numberOfItems;
    		}
    		else
    		{
    			KS_logfile_error(("%s: submit: Variable %s has empty path", pobj->v_identifier, pCurrVar->v_identifier));
    			pthis->v_status = KSAPI_COMMON_INTERNALERROR;
    			pthis->v_result = result;
    			Ov_HeapFree(items);
    			return;
    		}
    	}
    }


    /*	do the actual submit	*/
    pVtblClient->m_requestSetVar(pClient, NULL, numberOfItems, items, (OV_INSTPTR_ov_domain) pthis,
    			&ksapi_setVar_callback);

    if(!(pClient->v_state & KSBASE_CLST_ERROR))
    	pthis->v_status = KSAPI_COMMON_WAITINGFORANSWER;
    else
    	pthis->v_status = KSAPI_COMMON_INTERNALERROR;

    Ov_HeapFree(items);

	return;
}

OV_DLLFNCEXPORT void ksapi_setVar_setandsubmit(
    OV_INSTPTR_ksapi_setVar          pobj,
	OV_STRING 									serverHost,
	OV_STRING 									serverName,
	OV_STRING 									path,
	OV_ANY	 									setVar
) {
    OV_RESULT result;

    result = ksapi_KSApiCommon_genSetForSubmit(Ov_StaticPtrCast(ksapi_KSApiCommon, pobj), serverHost, serverName, path);
    if(Ov_Fail(result))
    	return;

    result = Ov_SetAnyValue(&(pobj->v_varValue), &setVar);
    if(Ov_Fail(result))
    {
    	pobj->v_status = KSAPI_COMMON_INTERNALERROR;
    	pobj->v_result = result;
    	return;
    }

    ksapi_setVar_submit(Ov_StaticPtrCast(ksapi_KSApiCommon,pobj));
	return;
}


void ksapi_setVar_callback(const OV_INSTPTR_ov_domain this, const OV_INSTPTR_ov_domain that)
{
	OV_INSTPTR_ksapi_setVar thisSV = Ov_StaticPtrCast(ksapi_setVar, this);
	OV_INSTPTR_ksbase_ClientBase pClient = Ov_StaticPtrCast(ksbase_ClientBase, that);
	OV_INSTPTR_ksapi_Variable pCurrVar = NULL;
	OV_VTBLPTR_ksbase_ClientBase pVtblClient = NULL;
	OV_UINT itemsLength;
	OV_RESULT* itemsResults = NULL;
	OV_RESULT result;

	if(!this || !that)
	{
		KS_logfile_error(("callback issued with NULL pointers. aborting."));
		return;
	}

	Ov_GetVTablePtr(ksbase_ClientBase, pVtblClient, pClient);

	if(!pVtblClient)
	{
		KS_logfile_error(("%s callback: could not determine Vtable of Client %s. aborting",
				this->v_identifier, that->v_identifier));
		thisSV->v_status = KSAPI_COMMON_INTERNALERROR;
		thisSV->v_result = OV_ERR_BADOBJTYPE;
		return;
	}
	ov_memstack_lock();
	result = pVtblClient->m_processSetVar(pClient, NULL, (OV_RESULT*) &(thisSV->v_result), &itemsLength, &itemsResults);
	if(Ov_Fail(result))
	{
		thisSV->v_status = KSAPI_COMMON_INTERNALERROR;
		thisSV->v_result = result;
		ov_memstack_unlock();
		return;
	}

	if(Ov_Fail(thisSV->v_result))
	{
		thisSV->v_status = KSAPI_COMMON_EXTERNALERROR;
		ov_memstack_unlock();
		return;
	}

	thisSV->v_varRes = itemsResults[0];
	thisSV->v_status = KSAPI_COMMON_REQUESTCOMPLETED;
	/*	iterate over variable objects in containment and linked ones and fill in the results	*/
	Ov_ForEachChildEx(ov_containment, thisSV, pCurrVar, ksapi_Variable)
	{
		if(pCurrVar->v_order)
		{
			if(pCurrVar->v_order <= itemsLength)
			{
				pCurrVar->v_varRes = itemsResults[pCurrVar->v_order-1];
				pCurrVar->v_order = 0;	/*	reset order	*/
			}
			else
			{
				pCurrVar->v_varRes = OV_ERR_BADPLACEMENT;
			}
		}
	}

	Ov_ForEachChild(ksapi_operationToVariable, thisSV, pCurrVar)
	{
		if(pCurrVar->v_order)
		{
			if(pCurrVar->v_order <= itemsLength)

			{
				pCurrVar->v_varRes = itemsResults[pCurrVar->v_order-1];
				pCurrVar->v_order = 0;	/*	reset order	*/
			}
			else
			{
				pCurrVar->v_varRes = OV_ERR_BADPLACEMENT;
			}
		}
	}

	ov_memstack_unlock();
	return;
}
