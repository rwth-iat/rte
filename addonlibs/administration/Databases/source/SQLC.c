
/******************************************************************************
*
*   FILE
*   ----
*   SQLC.c
*
*   History
*   -------
*   2018-08-23   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_Databases
#define OV_COMPILE_LIBRARY_Databases
#endif


#include "Databases.h"
#include "libov/ov_macros.h"

struct table{
	OV_STRING tableName;
	OV_STRING_VEC columnNames;
	OV_UINT_VEC dataTypes; // 1:STRING / BOOLEAN, 2:INT, 3:DOUBLE
	OV_UINT_VEC unusedRows;
	OV_UINT_VEC usedRows;
	void*** table;
};

void* newTable(){
	struct table* newTable = (struct table*)ov_database_malloc(sizeof(struct table));
	newTable->tableName = NULL;
	newTable->columnNames.veclen = 0;
	newTable->columnNames.value = NULL;
	newTable->dataTypes.veclen = 0;
	newTable->dataTypes.value = NULL;
	newTable->unusedRows.veclen = 0;
	newTable->unusedRows.value = NULL;
	newTable->usedRows.veclen = 0;
	newTable->usedRows.value = NULL;
	newTable->table = NULL;
	return (void*)newTable;
}


OV_RESULT WriteTableInFile(OV_INSTPTR_Databases_SQLC pinst, OV_STRING tableName, OV_STRING fileName){

	struct table *tmpTable = NULL;
	for (OV_UINT i = 0; i < pinst->v_dbNumberOfTables; i ++){
		if (ov_string_compare(pinst->v_db[i].tableName, tableName) == OV_STRCMP_EQUAL){
			tmpTable = &pinst->v_db[i];
			break;
		}
	}
	if (tmpTable == NULL){
		return OV_ERR_BADPARAM;
	}

	FILE *fp;
	fp = fopen(fileName, "a");
	if (fp == NULL){
		ov_logfile_error("could not open file");
		return OV_ERR_GENERIC;
	}

	fprintf(fp, "Tablename: %s\n", tmpTable->tableName);
	for (OV_UINT i = 0; i < tmpTable->usedRows.veclen; i++){
		if (tmpTable->usedRows.value[i] == 0){
			continue;
		}
		for (OV_UINT j = 0; j < tmpTable->columnNames.veclen; j++){
			if (j != 0){
				fprintf(fp, "\t");
			}
			if (tmpTable->table[i][j] == NULL){
				fprintf(fp, "-");
			}else{
				switch(tmpTable->dataTypes.value[j]){
					case 1:// STRING / BOOLEAN
						fprintf(fp, "%s", *(OV_STRING*)(tmpTable->table[i][j]));
						break;
					case 2:// INT
						fprintf(fp, "%i", *(OV_INT*)(tmpTable->table[i][j]));
						break;
					case 3:// DOUBLE
						fprintf(fp, "%lf", *(OV_DOUBLE*)(tmpTable->table[i][j]));
						break;
				}
			}
		}
		fprintf(fp, "\n");
	}

	fclose(fp);
	return OV_ERR_OK;
}


OV_RESULT initTable(struct table* table, OV_STRING tableName, OV_STRING_VEC ColumnNames, OV_UINT_VEC dataTypes){
	if (table->table != NULL || table->tableName != 0 || table->unusedRows.veclen > 0 || table->usedRows.veclen > 0 || table->columnNames.veclen > 0 || table->dataTypes.veclen > 0){
		ov_logfile_error("table is not empty");
		return OV_ERR_BADPARAM;
	}

	Ov_SetDynamicVectorLength(&table->columnNames, ColumnNames.veclen, STRING);
	for (OV_UINT i = 0; i < ColumnNames.veclen; i++){
		ov_string_setvalue(&table->columnNames.value[i], ColumnNames.value[i]);
	}
	Ov_SetDynamicVectorLength(&table->dataTypes, dataTypes.veclen, UINT);
	for (OV_UINT i = 0; i < dataTypes.veclen; i++){
		table->dataTypes.value[i] = dataTypes.value[i];
	}
	ov_string_setvalue(&table->tableName, tableName);

	return OV_ERR_OK;
}

OV_RESULT deleteTableMembers(struct table* table){
	if (table == NULL){
		return OV_ERR_OK;
	}

	for (OV_UINT i = 0; i < table->usedRows.veclen; i++){
		if (table->usedRows.value[i] == 0){
			continue;
		}
		for (OV_UINT j = 0; j < table->columnNames.veclen; j++){
			if (table->table[i][j] == NULL){
				continue;
			}
			switch(table->dataTypes.value[j]){
				case 1:// STRING / BOOLEAN
					ov_string_setvalue((OV_STRING*)table->table[i][j], NULL);
					break;
				case 2:// INT
				case 3:// DOUBLE
					break;
			}
			ov_database_free(table->table[i][j]);
			table->table[i][j] = NULL;
		}
		ov_database_free(table->table[i]);
		table->table[i] = NULL;
	}
	Ov_SetDynamicVectorLength(&table->usedRows, 0, UINT);
	Ov_SetDynamicVectorLength(&table->unusedRows, 0, UINT);
	ov_string_setvalue(&table->tableName, NULL);
	ov_database_free(table->table);
	table->table = NULL;
	Ov_SetDynamicVectorLength(&table->columnNames, 0, STRING);
	Ov_SetDynamicVectorLength(&table->dataTypes, 0, UINT);
	return OV_ERR_OK;
}

OV_RESULT InsertRowIntoTable(OV_INSTPTR_Databases_SQLC pinst, struct table* table, OV_UINT tableNumber, OV_STRING_VEC values){
	if (table == NULL){
		ov_logfile_error("table not exist");
		return OV_ERR_BADPARAM;
	}
	if (table->columnNames.veclen != values.veclen){
		ov_logfile_error("value size not equal to column size");
		return OV_ERR_BADPARAM;
	}

	// check if there is an unused row
	for (OV_UINT i = 0; i < table->usedRows.veclen; i++){
		if (table->usedRows.value[i] == 0){
			continue;
		}
		for (OV_UINT j = 0; j < table->columnNames.veclen; j++){
			if (j == table->columnNames.veclen -1){
				if (values.value[j] == NULL && table->table[i][j] == NULL){
					return OV_ERR_ALREADYEXISTS;
				}else{
					if (table->table[i][j] == NULL){
						break;
					}
					switch(table->dataTypes.value[j]){
						case 1:// STRING / BOOLEAN
							if (ov_string_compare(*(OV_STRING*)table->table[i][j], values.value[j]) == OV_STRCMP_EQUAL){
								return OV_ERR_ALREADYEXISTS;
							}
							break;
						case 2:// INT
							if (*(OV_INT*)table->table[i][j] == atoi(values.value[j])){
								return OV_ERR_ALREADYEXISTS;
							}
							break;
						case 3:// DOUBLE
							if (abs(*(OV_DOUBLE*)table->table[i][j] - atof(values.value[j])) > pinst->v_precision){
								return OV_ERR_ALREADYEXISTS;
							}
							break;
					}
				}
			}else{
				if (values.value[j] == NULL && table->table[i][j] == NULL){
					continue;
				}
				if (table->table[i][j] == NULL){
					break;
				}
				OV_BOOL match = FALSE;
				switch(table->dataTypes.value[j]){
					case 1:// STRING / BOOLEAN
						if (ov_string_compare(*(OV_STRING*)table->table[i][j], values.value[j]) == OV_STRCMP_EQUAL){
							match = TRUE;
						}
						break;
					case 2:// INT
						if (*(OV_INT*)table->table[i][j] == atoi(values.value[j])){
							match = TRUE;
						}
						break;
					case 3:// DOUBLE
						if (abs(*(OV_DOUBLE*)table->table[i][j] - atof(values.value[j])) > pinst->v_precision){
							match = TRUE;
						}
						break;
				}
				if (match == FALSE){
					break;
				}
			}
		}
	}

	if (table->unusedRows.veclen > 0){
		// set values
		for (OV_UINT i = 0; i < table->columnNames.veclen; i++){
			if (values.value[i] == NULL){
				continue;
			}
			switch(table->dataTypes.value[i]){
				case 1:// STRING / BOOLEAN
					table->table[table->unusedRows.value[table->unusedRows.veclen-1]][i] = ov_database_malloc(sizeof(OV_STRING));
					ov_string_setvalue((OV_STRING*)table->table[table->unusedRows.value[table->unusedRows.veclen-1]][i], values.value[i]);
					break;
				case 2:// INT
					table->table[table->unusedRows.value[table->unusedRows.veclen-1]][i] = ov_database_malloc(sizeof(OV_INT));
					*((OV_INT*)table->table[table->unusedRows.value[table->unusedRows.veclen-1]][i]) = atoi(values.value[i]);
					break;
				case 3:// DOUBLE
					table->table[table->unusedRows.value[table->unusedRows.veclen-1]][i] = ov_database_malloc(sizeof(OV_DOUBLE));
					*((OV_DOUBLE*)table->table[table->unusedRows.value[table->unusedRows.veclen-1]][i]) = atof(values.value[i]);
					break;
			}
		}
		table->usedRows.value[table->unusedRows.value[table->unusedRows.veclen-1]] = 1;
		Ov_SetDynamicVectorLength(&table->unusedRows, table->unusedRows.veclen-1, UINT);
	}else{
		// get memory for new row
		void*** tmpTable = ov_database_realloc(table->table, sizeof(void**)*(table->usedRows.veclen+1));
		if (tmpTable == NULL){
			ov_logfile_error("no free memory to insert row for table");
			return OV_ERR_GENERIC;
		}
		// get memory for new Columns
		tmpTable[table->usedRows.veclen] = ov_database_malloc(sizeof(void*)*table->columnNames.veclen);
		if (tmpTable[table->usedRows.veclen] == NULL){
			ov_logfile_error("no free memory to add columns for table");
			ov_database_free(tmpTable);
			return OV_ERR_GENERIC;
		}
		// set values
		for (OV_UINT i = 0; i < table->columnNames.veclen; i++){
			tmpTable[table->usedRows.veclen][i] = NULL;
			if (values.value[i] == NULL){
				continue;
			}
			switch(table->dataTypes.value[i]){
				case 1:// STRING / BOOLEAN
					tmpTable[table->usedRows.veclen][i] = ov_database_malloc(sizeof(OV_STRING));
					ov_string_setvalue((OV_STRING*)tmpTable[table->usedRows.veclen][i], values.value[i]);
					break;
				case 2:// INT
					tmpTable[table->usedRows.veclen][i] = ov_database_malloc(sizeof(OV_INT));
					*((OV_INT*)tmpTable[table->usedRows.veclen][i]) = atoi(values.value[i]);
					break;
				case 3:// DOUBLE
					tmpTable[table->usedRows.veclen][i] = ov_database_malloc(sizeof(OV_DOUBLE));
					*((OV_DOUBLE*)tmpTable[table->usedRows.veclen][i]) = atof(values.value[i]);
				break;
			}
		}

		Ov_SetDynamicVectorLength(&table->usedRows, table->usedRows.veclen+1, UINT);
		table->usedRows.value[table->usedRows.veclen-1] = 1;
		table->table = tmpTable;
	}
	pinst->v_tableRows.value[tableNumber] = pinst->v_db[tableNumber].usedRows.veclen;

	return OV_ERR_OK;
}

OV_RESULT DeleteRowInTable(OV_INSTPTR_Databases_SQLC pinst, struct table* table, OV_UINT tableNumber, OV_STRING_VEC values){
	if (table == NULL){
		ov_logfile_error("table not exist");
		return OV_ERR_GENERIC;
	}
	if (table->columnNames.veclen != values.veclen){
		ov_logfile_error("value size not equal to column size");
		return OV_ERR_BADPARAM;
	}

	OV_UINT_VEC matchingRows;
	matchingRows.veclen = 0;
	matchingRows.value = NULL;
	Ov_SetDynamicVectorLength(&matchingRows, table->usedRows.veclen, UINT);
	OV_UINT numberOfMatchingRows = 0;

	// find rows
	for (OV_UINT i = 0; i < table->usedRows.veclen; i++){
		if (table->usedRows.value[i] == 0){
			continue;
		}
		for (OV_UINT j = 0; j < table->columnNames.veclen; j++){
			if (j == table->columnNames.veclen -1){
				if (values.value[j] == NULL){
					matchingRows.value[numberOfMatchingRows] = i;
					numberOfMatchingRows = numberOfMatchingRows + 1;
				}else{
					if (table->table[i][j] == NULL){
						break;
					}
					switch(table->dataTypes.value[j]){
						case 1:// STRING / BOOLEAN
							if (ov_string_compare(*(OV_STRING*)table->table[i][j], values.value[j]) == OV_STRCMP_EQUAL){
								matchingRows.value[numberOfMatchingRows] = i;
								numberOfMatchingRows = numberOfMatchingRows + 1;
							}
							break;
						case 2:// INT
							if (*(OV_INT*)table->table[i][j] == atoi(values.value[j])){
								matchingRows.value[numberOfMatchingRows] = i;
								numberOfMatchingRows = numberOfMatchingRows + 1;
							}
							break;
						case 3:// DOUBLE
							if (abs(*(OV_DOUBLE*)table->table[i][j] - atof(values.value[j])) > pinst->v_precision){
								matchingRows.value[numberOfMatchingRows] = i;
								numberOfMatchingRows = numberOfMatchingRows + 1;
							}
							break;
					}
				}
			}else{
				if (values.value[j] == NULL){
					continue;
				}
				if (table->table[i][j] == NULL){
					break;
				}
				OV_BOOL match = FALSE;
				switch(table->dataTypes.value[j]){
					case 1:// STRING / BOOLEAN
						if (ov_string_compare(*(OV_STRING*)table->table[i][j], values.value[j]) == OV_STRCMP_EQUAL){
							match = TRUE;
						}
						break;
					case 2:// INT
						if (*(OV_INT*)table->table[i][j] == atoi(values.value[j])){
							match = TRUE;
						}
						break;
					case 3:// DOUBLE
						if (abs(*(OV_DOUBLE*)table->table[i][j] - atof(values.value[j])) > pinst->v_precision){
							match = TRUE;
						}
						break;
				}
				if (match == FALSE){
					break;
				}
			}
		}
	}

	if (numberOfMatchingRows == 0){
		Ov_SetDynamicVectorLength(&matchingRows, 0, UINT);
		return OV_ERR_BADPARAM;
	}

	for (OV_UINT i = 0; i < matchingRows.veclen; i++){
		if(numberOfMatchingRows == 0){
			break;
		}
		for (OV_UINT j = 0; j < table->columnNames.veclen; j++){
			if (table->table[matchingRows.value[matchingRows.value[i]]][j] == NULL){
				continue;
			}
			switch(table->dataTypes.value[j]){
				case 1:// STRING / BOOLEAN
					ov_string_setvalue((OV_STRING*)table->table[matchingRows.value[i]][j], NULL);
					break;
				case 2:// INT
				case 3:// DOUBLE
					break;
			}
			ov_database_free(table->table[matchingRows.value[i]][j]);
		}
		table->usedRows.value[matchingRows.value[i]] = 0;
		Ov_SetDynamicVectorLength(&table->unusedRows, table->unusedRows.veclen+1, UINT);
		table->unusedRows.value[table->unusedRows.veclen-1] = matchingRows.value[i];
		numberOfMatchingRows = numberOfMatchingRows - 1;
	}
	Ov_SetDynamicVectorLength(&matchingRows, 0, UINT);

	pinst->v_tableRows.value[tableNumber] = pinst->v_db[tableNumber].usedRows.veclen;

	return OV_ERR_OK;
}

OV_RESULT UpdateRowInTable(OV_INSTPTR_Databases_SQLC pinst, struct table* table, OV_STRING_VEC findRowValues, OV_STRING_VEC updateColumns, OV_STRING_VEC updateValues){
	if (table == NULL){
		ov_logfile_error("table not exist");
		return OV_ERR_GENERIC;
	}
	if (table->columnNames.veclen != findRowValues.veclen){
		ov_logfile_error("findRowValues size not equal to column size");
		return OV_ERR_BADPARAM;
	}
	if (updateColumns.veclen != updateValues.veclen){
		ov_logfile_error("updateColumn and updateValues size must be equal");
		return OV_ERR_BADPARAM;
	}

	OV_UINT_VEC matchingRows;
	matchingRows.veclen = 0;
	matchingRows.value = NULL;
	Ov_SetDynamicVectorLength(&matchingRows, table->usedRows.veclen, UINT);
	OV_UINT numberOfMatchingRows = 0;

	// find rows
	for (OV_UINT i = 0; i < table->usedRows.veclen; i++){
		if (table->usedRows.value[i] == 0){
			continue;
		}
		for (OV_UINT j = 0; j < table->columnNames.veclen; j++){
			if (j == table->columnNames.veclen -1){
				if (findRowValues.value[j] == NULL){
					matchingRows.value[numberOfMatchingRows] = i;
					numberOfMatchingRows = numberOfMatchingRows + 1;
				}else{
					if (table->table[i][j] == NULL){
						break;
					}
					switch(table->dataTypes.value[j]){
						case 1:// STRING / BOOLEAN
							if (ov_string_compare(*(OV_STRING*)table->table[i][j], findRowValues.value[j]) == OV_STRCMP_EQUAL){
								matchingRows.value[numberOfMatchingRows] = i;
								numberOfMatchingRows = numberOfMatchingRows + 1;
							}
							break;
						case 2:// INT
							if (*(OV_INT*)table->table[i][j] == atoi(findRowValues.value[j])){
								matchingRows.value[numberOfMatchingRows] = i;
								numberOfMatchingRows = numberOfMatchingRows + 1;
							}
							break;
						case 3:// DOUBLE
							if (abs(*(OV_DOUBLE*)table->table[i][j] - atof(findRowValues.value[j])) > pinst->v_precision){
								matchingRows.value[numberOfMatchingRows] = i;
								numberOfMatchingRows = numberOfMatchingRows + 1;
							}
							break;
					}
				}
			}else{
				if (findRowValues.value[j] == NULL){
					continue;
				}
				if (table->table[i][j] == NULL){
					break;
				}
				OV_BOOL match = FALSE;
				switch(table->dataTypes.value[j]){
					case 1:// STRING / BOOLEAN
						if (ov_string_compare(*(OV_STRING*)table->table[i][j], findRowValues.value[j]) == OV_STRCMP_EQUAL){
							match = TRUE;
						}
						break;
					case 2:// INT
						if (*(OV_INT*)table->table[i][j] == atoi(findRowValues.value[j])){
							match = TRUE;
						}
						break;
					case 3:// DOUBLE
						if (abs(*(OV_DOUBLE*)table->table[i][j] - atof(findRowValues.value[j])) > pinst->v_precision){
							match = TRUE;
						}
						break;
				}
				if (match == FALSE){
					break;
				}
			}
		}
	}

	if (numberOfMatchingRows == 0){
		Ov_SetDynamicVectorLength(&matchingRows, 0, UINT);
		return OV_ERR_BADPARAM;
	}

	for (OV_UINT i = 0; i < numberOfMatchingRows; i++){
		for (OV_UINT j = 0; j < table->columnNames.veclen; j++){
			for (OV_UINT k = 0; k < updateColumns.veclen; k++){
				if (ov_string_compare(table->columnNames.value[j], updateColumns.value[k]) == OV_STRCMP_EQUAL){
					switch(table->dataTypes.value[i]){
						case 1:// STRING / BOOLEAN
							if (table->table[matchingRows.value[i]][j] == NULL){
								table->table[matchingRows.value[i]][j] = ov_database_malloc(sizeof(OV_STRING));
							}
							ov_string_setvalue((OV_STRING*)table->table[matchingRows.value[i]][j], updateValues.value[k]);
							break;
						case 2:// INT
							if (table->table[matchingRows.value[i]][j] == NULL){
								table->table[matchingRows.value[i]][j] = ov_database_malloc(sizeof(OV_INT));
							}
							*((OV_INT*)table->table[matchingRows.value[i]][j]) = atoi(updateValues.value[k]);
							break;
						case 3:// DOUBLE
							if (table->table[matchingRows.value[i]][j] == NULL){
								table->table[matchingRows.value[i]][j] = ov_database_malloc(sizeof(OV_DOUBLE));
							}
							*((OV_DOUBLE*)table->table[matchingRows.value[i]][j]) = atof(updateValues.value[k]);
							break;
					}
					break;
				}
			}
		}
	}
	Ov_SetDynamicVectorLength(&matchingRows, 0, UINT);

	return OV_ERR_OK;
}


// findRowRelation: 0:==, 1:<, 2:<=, 3:!=, 4:>=, 5:>
OV_RESULT SelectTable(OV_INSTPTR_Databases_SQLC pinst, struct table* table, OV_STRING_VEC findRowValues, OV_STRING_VEC selectedColumns, OV_STRING_VEC* result){
	if (table == NULL){
		ov_logfile_error("table not exist");
		return OV_ERR_GENERIC;
	}
	if (table->columnNames.veclen != findRowValues.veclen){
		ov_logfile_error("findRowValues size is not equal to column size");
		return OV_ERR_BADPARAM;
	}

	OV_UINT_VEC matchingRows;
	matchingRows.veclen = 0;
	matchingRows.value = NULL;
	Ov_SetDynamicVectorLength(&matchingRows, table->usedRows.veclen, UINT);
	OV_UINT numberOfMatchingRows = 0;

	OV_UINT_VEC tmpcolumnNumbers;
	tmpcolumnNumbers.veclen = 0;
	tmpcolumnNumbers.value = NULL;
	Ov_SetDynamicVectorLength(&tmpcolumnNumbers, table->columnNames.veclen, UINT);
	OV_UINT foundColumn = 0;
	OV_UINT i = 0;
	OV_UINT j = 0;

	for (i = 0; i < selectedColumns.veclen; i++){
		for (j = 0; j < table->columnNames.veclen; j++){
			if (ov_string_compare(table->columnNames.value[j], selectedColumns.value[i]) == OV_STRCMP_EQUAL){
				tmpcolumnNumbers.value[j] = 1;
				foundColumn = foundColumn + 1;
				break;
			}
		}
	}

	OV_UINT_VEC columnNumbers;
	columnNumbers.veclen = 0;
	columnNumbers.value = NULL;
	Ov_SetDynamicVectorLength(&columnNumbers, foundColumn, UINT);
	foundColumn = 0;
	for (i = 0; i < tmpcolumnNumbers.veclen; i++){
		if (tmpcolumnNumbers.value[i] == 1){
			columnNumbers.value[foundColumn] = i;
			foundColumn = foundColumn + 1;
		}
	}
	Ov_SetDynamicVectorLength(&tmpcolumnNumbers, 0, UINT);
	OV_BOOL noMatching = FALSE;
	// find rows
	for (i = 0; i < table->usedRows.veclen; i++){
		if (table->usedRows.value[i] == 0){
			continue;
		}
		for (j = 0; j < columnNumbers.veclen; j++){
			if (table->table[i][columnNumbers.value[j]] == NULL){
				noMatching = TRUE;
				break;
			}
		}
		if (noMatching == TRUE){
			noMatching = FALSE;
			continue;
		}
		for (OV_UINT j = 0; j < table->columnNames.veclen; j++){
			if (j == table->columnNames.veclen -1){
				if (findRowValues.value[j] == NULL){
					matchingRows.value[numberOfMatchingRows] = i;
					numberOfMatchingRows = numberOfMatchingRows + 1;
				}else{
					if (table->table[i][j] == NULL){
						break;
					}
					switch(table->dataTypes.value[j]){
						case 1:// STRING / BOOLEAN
							if (ov_string_compare(*(OV_STRING*)table->table[i][j], findRowValues.value[j]) == OV_STRCMP_EQUAL){
								matchingRows.value[numberOfMatchingRows] = i;
								numberOfMatchingRows = numberOfMatchingRows + 1;
							}
							break;
						case 2:// INT
							if (*(OV_INT*)table->table[i][j] == atoi(findRowValues.value[j])){
								matchingRows.value[numberOfMatchingRows] = i;
								numberOfMatchingRows = numberOfMatchingRows + 1;
							}
							break;
						case 3:// DOUBLE
							if (abs(*(OV_DOUBLE*)table->table[i][j] - atof(findRowValues.value[j])) < pinst->v_precision){
								matchingRows.value[numberOfMatchingRows] = i;
								numberOfMatchingRows = numberOfMatchingRows + 1;
							}
						break;
					}
				}
			}else{
				if (findRowValues.value[j] == NULL){
					continue;
				}
				if (table->table[i][j] == NULL){
					break;
				}
				OV_BOOL match = FALSE;
				switch(table->dataTypes.value[j]){
					case 1:// STRING / BOOLEAN
						if (ov_string_compare(*(OV_STRING*)table->table[i][j], findRowValues.value[j]) == OV_STRCMP_EQUAL){
							match = TRUE;
						}
						break;
					case 2:// INT
						if (*(OV_INT*)table->table[i][j] == atoi(findRowValues.value[j])){
							match = TRUE;
						}
						break;
					case 3:// DOUBLE
						if (abs(*(OV_DOUBLE*)table->table[i][j] - atof(findRowValues.value[j])) < pinst->v_precision){
							match = TRUE;
						}
					break;
				}
				if (match == FALSE){
					break;
				}
			}
		}
	}

	// find distinct elements
	OV_UINT_VEC matchingRowsDistinct;
	matchingRowsDistinct.veclen = 0;
	matchingRowsDistinct.value = NULL;
	OV_BOOL distinct = FALSE;
	for (i = 0; i < numberOfMatchingRows; i++){
		for (j = i+1; j < numberOfMatchingRows; j++){
			distinct = FALSE;
			for (OV_UINT k = 0; k < columnNumbers.veclen; k++){
				switch(table->dataTypes.value[k]){
					case 1:// STRING / BOOLEAN
						if (ov_string_compare(*(OV_STRING*)table->table[matchingRows.value[i]][columnNumbers.value[k]], *(OV_STRING*)table->table[matchingRows.value[j]][columnNumbers.value[k]]) != OV_STRCMP_EQUAL){
							distinct = TRUE;
						}
						break;
					case 2:// INT
						if (*(OV_INT*)table->table[matchingRows.value[i]][columnNumbers.value[k]] != *(OV_INT*)table->table[matchingRows.value[j]][columnNumbers.value[k]]){
							distinct = TRUE;
						}
						break;
					case 3:// DOUBLE
						if (abs(*(OV_DOUBLE*)table->table[matchingRows.value[i]][columnNumbers.value[k]] - *(OV_DOUBLE*)table->table[matchingRows.value[j]][columnNumbers.value[k]]) > pinst->v_precision){
							distinct = TRUE;
						}
					break;
				}
				if (distinct == TRUE){
					break;
				}
			}
			if (distinct == FALSE){
				break;
			}
		}
		if (j == numberOfMatchingRows){
			Ov_SetDynamicVectorLength(&matchingRowsDistinct, matchingRowsDistinct.veclen+1, UINT);
			matchingRowsDistinct.value[matchingRowsDistinct.veclen-1] = matchingRows.value[i];
		}
	}


	// create response
	for (i = 0; i < matchingRowsDistinct.veclen; i++){
		Ov_SetDynamicVectorLength(result, result->veclen+columnNumbers.veclen, STRING);
		for (j = 0; j < columnNumbers.veclen; j++){
			switch(table->dataTypes.value[j]){
				case 1:// STRING / BOOLEAN
					ov_string_setvalue(&result->value[result->veclen-(columnNumbers.veclen-j)], *(OV_STRING*)table->table[matchingRowsDistinct.value[i]][columnNumbers.value[j]]);
					break;
				case 2:// INT
					ov_string_print(&result->value[result->veclen-(columnNumbers.veclen-j)], "%i", *(OV_UINT*)table->table[matchingRowsDistinct.value[i]][columnNumbers.value[j]]);
					break;
				case 3:// DOUBLE
					ov_string_print(&result->value[result->veclen-(columnNumbers.veclen-j)], "%lf", *(OV_DOUBLE*)table->table[matchingRowsDistinct.value[i]][columnNumbers.value[j]]);
				break;
			}
		}
	}
	Ov_SetDynamicVectorLength(&columnNumbers, 0, UINT);
	Ov_SetDynamicVectorLength(&matchingRows, 0, UINT);
	Ov_SetDynamicVectorLength(&matchingRowsDistinct, 0, UINT);

	return OV_ERR_OK;
}

// findRowRelation: 0:==, 1:<, 2:<=, 3:!=, 4:>=, 5:>
OV_RESULT SelectTable2(OV_INSTPTR_Databases_SQLC pinst, struct table* table, OV_STRING_VEC findRowValues, OV_UINT_VEC findRowRelation, OV_STRING_VEC selectedColumns, OV_STRING_VEC* result){
	if (table == NULL){
		ov_logfile_error("table not exist");
		return OV_ERR_GENERIC;
	}
	if (findRowValues.veclen % table->columnNames.veclen != 0 || findRowRelation.veclen % table->columnNames.veclen != 0 || findRowValues.veclen != findRowRelation.veclen){
		ov_logfile_error("findRowValues size or findRowRelation size is not a multiple of column size or they have not the same length");
		return OV_ERR_BADPARAM;
	}

	OV_UINT_VEC matchingRows;
	matchingRows.veclen = 0;
	matchingRows.value = NULL;
	Ov_SetDynamicVectorLength(&matchingRows, table->usedRows.veclen, UINT);
	OV_UINT numberOfMatchingRows = 0;

	OV_UINT_VEC tmpcolumnNumbers;
	tmpcolumnNumbers.veclen = 0;
	tmpcolumnNumbers.value = NULL;
	Ov_SetDynamicVectorLength(&tmpcolumnNumbers, table->columnNames.veclen, UINT);
	OV_UINT foundColumn = 0;
	OV_UINT i = 0;
	OV_UINT j = 0;

	for (i = 0; i < selectedColumns.veclen; i++){
		for (j = 0; j < table->columnNames.veclen; j++){
			if (ov_string_compare(table->columnNames.value[j], selectedColumns.value[i]) == OV_STRCMP_EQUAL){
				tmpcolumnNumbers.value[j] = 1;
				foundColumn = foundColumn + 1;
				break;
			}
		}
	}

	OV_UINT_VEC columnNumbers;
	columnNumbers.veclen = 0;
	columnNumbers.value = NULL;
	Ov_SetDynamicVectorLength(&columnNumbers, foundColumn, UINT);
	foundColumn = 0;
	for (i = 0; i < tmpcolumnNumbers.veclen; i++){
		if (tmpcolumnNumbers.value[i] == 1){
			columnNumbers.value[foundColumn] = i;
			foundColumn = foundColumn + 1;
		}
	}
	Ov_SetDynamicVectorLength(&tmpcolumnNumbers, 0, UINT);
	OV_BOOL noMatching = FALSE;
	// find rows
	for (i = 0; i < table->usedRows.veclen; i++){
		if (table->usedRows.value[i] == 0){
			continue;
		}
		for (j = 0; j < columnNumbers.veclen; j++){
			if (table->table[i][columnNumbers.value[j]] == NULL){
				noMatching = TRUE;
				break;
			}
		}
		if (noMatching == TRUE){
			noMatching = FALSE;
			continue;
		}
		for (OV_UINT k = 0; k < findRowValues.veclen / table->columnNames.veclen; k++){
			for (OV_UINT j = 0; j < table->columnNames.veclen; j++){
				if (j == table->columnNames.veclen -1){
					if (findRowValues.value[j+table->columnNames.veclen*k] == NULL){
						matchingRows.value[numberOfMatchingRows] = i;
						numberOfMatchingRows = numberOfMatchingRows + 1;
					}else{
						if (table->table[i][j] == NULL){
							break;
						}
						switch(table->dataTypes.value[j]){
							case 1:// STRING / BOOLEAN
								switch (findRowRelation.value[j+table->columnNames.veclen*k]){ // 0:==, 1:<, 2:<=, 3:!=, 4:>=, 5:>
									case 0:
										if (ov_string_compare(*(OV_STRING*)table->table[i][j], findRowValues.value[j+table->columnNames.veclen*k]) == OV_STRCMP_EQUAL){
											matchingRows.value[numberOfMatchingRows] = i;
											numberOfMatchingRows = numberOfMatchingRows + 1;
										}
									break;
									case 1:
									case 2:
									case 3:
									case 4:
									case 5:
									break;
								}
								break;
							case 2:// INT
								switch (findRowRelation.value[j+table->columnNames.veclen*k]){ // 0:==, 1:<, 2:<=, 3:!=, 4:>=, 5:>
									case 0:
										if (*(OV_INT*)table->table[i][j] == atoi(findRowValues.value[j+table->columnNames.veclen*k])){
											matchingRows.value[numberOfMatchingRows] = i;
											numberOfMatchingRows = numberOfMatchingRows + 1;
										}
									break;
									case 1:
										if (*(OV_INT*)table->table[i][j] < atoi(findRowValues.value[j+table->columnNames.veclen*k])){
											matchingRows.value[numberOfMatchingRows] = i;
											numberOfMatchingRows = numberOfMatchingRows + 1;
										}
									break;
									case 2:
										if (*(OV_INT*)table->table[i][j] <= atoi(findRowValues.value[j+table->columnNames.veclen*k])){
											matchingRows.value[numberOfMatchingRows] = i;
											numberOfMatchingRows = numberOfMatchingRows + 1;
										}
									break;
									case 3:
										if (*(OV_INT*)table->table[i][j] != atoi(findRowValues.value[j+table->columnNames.veclen*k])){
											matchingRows.value[numberOfMatchingRows] = i;
											numberOfMatchingRows = numberOfMatchingRows + 1;
										}
									break;
									case 4:
										if (*(OV_INT*)table->table[i][j] >= atoi(findRowValues.value[j+table->columnNames.veclen*k])){
											matchingRows.value[numberOfMatchingRows] = i;
											numberOfMatchingRows = numberOfMatchingRows + 1;
										}
										break;
									case 5:
										if (*(OV_INT*)table->table[i][j] > atoi(findRowValues.value[j+table->columnNames.veclen*k])){
											matchingRows.value[numberOfMatchingRows] = i;
											numberOfMatchingRows = numberOfMatchingRows + 1;
										}
									break;
								}
								break;
							case 3:// DOUBLE
								switch (findRowRelation.value[j+table->columnNames.veclen*k]){ // 0:==, 1:<, 2:<=, 3:!=, 4:>=, 5:>
									case 0:
										if (abs(*(OV_DOUBLE*)table->table[i][j] - atof(findRowValues.value[j+table->columnNames.veclen*k])) < pinst->v_precision){
											matchingRows.value[numberOfMatchingRows] = i;
											numberOfMatchingRows = numberOfMatchingRows + 1;
										}
									break;
									case 1:
										if (*(OV_DOUBLE*)table->table[i][j] < atof(findRowValues.value[j+table->columnNames.veclen*k])){
											matchingRows.value[numberOfMatchingRows] = i;
											numberOfMatchingRows = numberOfMatchingRows + 1;
										}
									break;
									case 2:
										if (*(OV_DOUBLE*)table->table[i][j] < atof(findRowValues.value[j+table->columnNames.veclen*k]) || abs(*(OV_DOUBLE*)table->table[i][j] - atof(findRowValues.value[j+table->columnNames.veclen*k])) < pinst->v_precision){
											matchingRows.value[numberOfMatchingRows] = i;
											numberOfMatchingRows = numberOfMatchingRows + 1;
										}
									break;
									case 3:
										if (abs(*(OV_DOUBLE*)table->table[i][j] - atof(findRowValues.value[j+table->columnNames.veclen*k])) > pinst->v_precision){
											matchingRows.value[numberOfMatchingRows] = i;
											numberOfMatchingRows = numberOfMatchingRows + 1;
										}
									break;
									case 4:
										if (*(OV_DOUBLE*)table->table[i][j] >= atof(findRowValues.value[j+table->columnNames.veclen*k])){
											matchingRows.value[numberOfMatchingRows] = i;
											numberOfMatchingRows = numberOfMatchingRows + 1;
										}
									break;
									case 5:
										if (*(OV_DOUBLE*)table->table[i][j] > atof(findRowValues.value[j+table->columnNames.veclen*k]) || abs(*(OV_DOUBLE*)table->table[i][j] - atof(findRowValues.value[j+table->columnNames.veclen*k])) < pinst->v_precision){
											matchingRows.value[numberOfMatchingRows] = i;
											numberOfMatchingRows = numberOfMatchingRows + 1;
										}
									break;
								}
							break;
						}
					}
				}else{
					if (findRowValues.value[j+table->columnNames.veclen*k] == NULL){
						continue;
					}
					if (table->table[i][j] == NULL){
						break;
					}
					OV_BOOL match = FALSE;
					switch(table->dataTypes.value[j]){
						case 1:// STRING / BOOLEAN
							switch (findRowRelation.value[j+table->columnNames.veclen*k]){ // 0:==, 1:<, 2:<=, 3:!=, 4:>=, 5:>
								case 0:
									if (ov_string_compare(*(OV_STRING*)table->table[i][j], findRowValues.value[j+table->columnNames.veclen*k]) == OV_STRCMP_EQUAL){
										match = TRUE;
									}
								break;
								case 1:
								case 2:
								case 3:
								case 4:
								case 5:
								break;
							}
							break;
						case 2:// INT
							switch (findRowRelation.value[j+table->columnNames.veclen*k]){ // 0:==, 1:<, 2:<=, 3:!=, 4:>=, 5:>
								case 0:
									if (*(OV_INT*)table->table[i][j] == atoi(findRowValues.value[j+table->columnNames.veclen*k])){
										match = TRUE;
									}
								break;
								case 1:
									if (*(OV_INT*)table->table[i][j] < atoi(findRowValues.value[j+table->columnNames.veclen*k])){
										match = TRUE;
									}
								break;
								case 2:
									if (*(OV_INT*)table->table[i][j] <= atoi(findRowValues.value[j+table->columnNames.veclen*k])){
										match = TRUE;
									}
								break;
								case 3:
									if (*(OV_INT*)table->table[i][j] != atoi(findRowValues.value[j+table->columnNames.veclen*k])){
										match = TRUE;
									}
								break;
								case 4:
									if (*(OV_INT*)table->table[i][j] >= atoi(findRowValues.value[j+table->columnNames.veclen*k])){
										match = TRUE;
									}
									break;
								case 5:
									if (*(OV_INT*)table->table[i][j] > atoi(findRowValues.value[j+table->columnNames.veclen*k])){
										match = TRUE;
									}
								break;
							}
							break;
						case 3:// DOUBLE
							switch (findRowRelation.value[j+table->columnNames.veclen*k]){ // 0:==, 1:<, 2:<=, 3:!=, 4:>=, 5:>
								case 0:
									if (abs(*(OV_DOUBLE*)table->table[i][j] - atof(findRowValues.value[j+table->columnNames.veclen*k])) < pinst->v_precision){
										match = TRUE;
									}
								break;
								case 1:
									if (*(OV_DOUBLE*)table->table[i][j] < atof(findRowValues.value[j+table->columnNames.veclen*k])){
										match = TRUE;
									}
								break;
								case 2:
									if (*(OV_DOUBLE*)table->table[i][j] < atof(findRowValues.value[j+table->columnNames.veclen*k]) || abs(*(OV_DOUBLE*)table->table[i][j] - atof(findRowValues.value[j+table->columnNames.veclen*k])) < pinst->v_precision){
										match = TRUE;
									}
								break;
								case 3:
									if (abs(*(OV_DOUBLE*)table->table[i][j] - atof(findRowValues.value[j+table->columnNames.veclen*k])) > pinst->v_precision){
										match = TRUE;
									}
								break;
								case 4:
									if (*(OV_DOUBLE*)table->table[i][j] >= atof(findRowValues.value[j+table->columnNames.veclen*k])){
										match = TRUE;
									}
								break;
								case 5:
									if (*(OV_DOUBLE*)table->table[i][j] > atof(findRowValues.value[j+table->columnNames.veclen*k]) || abs(*(OV_DOUBLE*)table->table[i][j] - atof(findRowValues.value[j+table->columnNames.veclen*k])) < pinst->v_precision){
										match = TRUE;
									}
								break;
							}
						break;
					}
					if (match == FALSE){
						break;
					}
				}
			}
		}
	}

	// find distinct elements
	OV_UINT_VEC matchingRowsDistinct;
	matchingRowsDistinct.veclen = 0;
	matchingRowsDistinct.value = NULL;
	OV_BOOL distinct = FALSE;
	for (i = 0; i < numberOfMatchingRows; i++){
		for (j = i+1; j < numberOfMatchingRows; j++){
			distinct = FALSE;
			for (OV_UINT k = 0; k < columnNumbers.veclen; k++){
				switch(table->dataTypes.value[k]){
					case 1:// STRING / BOOLEAN
						if (ov_string_compare(*(OV_STRING*)table->table[matchingRows.value[i]][columnNumbers.value[k]], *(OV_STRING*)table->table[matchingRows.value[j]][columnNumbers.value[k]]) != OV_STRCMP_EQUAL){
							distinct = TRUE;
						}
						break;
					case 2:// INT
						if (*(OV_INT*)table->table[matchingRows.value[i]][columnNumbers.value[k]] != *(OV_INT*)table->table[matchingRows.value[j]][columnNumbers.value[k]]){
							distinct = TRUE;
						}
						break;
					case 3:// DOUBLE
						if (abs(*(OV_DOUBLE*)table->table[matchingRows.value[i]][columnNumbers.value[k]] - *(OV_DOUBLE*)table->table[matchingRows.value[j]][columnNumbers.value[k]]) > pinst->v_precision){
							distinct = TRUE;
						}
					break;
				}
				if (distinct == TRUE){
					break;
				}
			}
			if (distinct == FALSE){
				break;
			}
		}
		if (j == numberOfMatchingRows){
			Ov_SetDynamicVectorLength(&matchingRowsDistinct, matchingRowsDistinct.veclen+1, UINT);
			matchingRowsDistinct.value[matchingRowsDistinct.veclen-1] = matchingRows.value[i];
		}
	}


	// create response
	for (i = 0; i < matchingRowsDistinct.veclen; i++){
		Ov_SetDynamicVectorLength(result, result->veclen+columnNumbers.veclen, STRING);
		for (j = 0; j < columnNumbers.veclen; j++){
			switch(table->dataTypes.value[j]){
				case 1:// STRING / BOOLEAN
					ov_string_setvalue(&result->value[result->veclen-(columnNumbers.veclen-j)], *(OV_STRING*)table->table[matchingRowsDistinct.value[i]][columnNumbers.value[j]]);
					break;
				case 2:// INT
					ov_string_print(&result->value[result->veclen-(columnNumbers.veclen-j)], "%i", *(OV_UINT*)table->table[matchingRowsDistinct.value[i]][columnNumbers.value[j]]);
					break;
				case 3:// DOUBLE
					ov_string_print(&result->value[result->veclen-(columnNumbers.veclen-j)], "%lf", *(OV_DOUBLE*)table->table[matchingRowsDistinct.value[i]][columnNumbers.value[j]]);
				break;
			}
		}
	}
	Ov_SetDynamicVectorLength(&columnNumbers, 0, UINT);
	Ov_SetDynamicVectorLength(&matchingRows, 0, UINT);
	Ov_SetDynamicVectorLength(&matchingRowsDistinct, 0, UINT);

	return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLC_query_set(
    OV_INSTPTR_Databases_SQLC          pobj,
    const OV_STRING  value
) {
    return ov_string_setvalue(&pobj->v_query,value);
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLC_io_set(
    OV_INSTPTR_Databases_SQLC          pobj,
    const OV_BOOL  value
) {
    pobj->v_io = value;
    return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLC_print_set(
    OV_INSTPTR_Databases_SQLC          pobj,
    const OV_BOOL  value
) {
	if (value == TRUE){
		if (pobj->v_table != NULL){
			WriteTableInFile(pobj, pobj->v_table, "table_log.txt");
		}
	}
    return OV_ERR_OK;
}

OV_DLLFNCEXPORT void Databases_SQLC_shutdown(
	OV_INSTPTR_ov_object 	pobj
) {
    /*
    *   local variables
    */
    //OV_INSTPTR_Databases_SQLC pinst = Ov_StaticPtrCast(Databases_SQLC, pobj);

    /* do what */

    /* set the object's state to "shut down" */
    ov_object_shutdown(pobj);

    return;
}

OV_DLLFNCEXPORT void Databases_SQLC_startup(
	OV_INSTPTR_ov_object 	pobj
) {
    /*
    *   local variables
    */
    //OV_INSTPTR_Databases_SQLC pinst = Ov_StaticPtrCast(Databases_SQLC, pobj);

    /* do what the base class does first */
    ov_object_startup(pobj);

    /* do what */

    return;
}


OV_DLLFNCEXPORT OV_RESULT Databases_SQLC_connect(OV_INSTPTR_openAASDiscoveryServer_Wrapper this) {
    /*    
    *   local variables
    */

	OV_RESULT result = OV_ERR_OK;
	OV_INSTPTR_Databases_SQLC pinst = Ov_StaticPtrCast(Databases_SQLC, this);
	if (pinst->v_State == 1){
		return OV_ERR_OK;
	}
	if (pinst->v_db != NULL){
		ov_logfile_error("an table already exist, first disconnect");
		return OV_ERR_GENERIC;
	}

	pinst->v_db = (struct table*)ov_database_malloc(sizeof(struct table)*9);
	if (pinst->v_db == NULL){
		ov_logfile_error("no free memory to create table list");
		return OV_ERR_GENERIC;
	}
	for (OV_UINT i = 0; i < 9; i++){
		pinst->v_db[i].tableName = NULL;
		pinst->v_db[i].table = NULL;
		pinst->v_db[i].columnNames.veclen = 0;
		pinst->v_db[i].columnNames.value = NULL;
		pinst->v_db[i].dataTypes.veclen = 0;
		pinst->v_db[i].dataTypes.value = NULL;
		pinst->v_db[i].unusedRows.veclen = 0;
		pinst->v_db[i].unusedRows.value = NULL;
		pinst->v_db[i].usedRows.veclen = 0;
		pinst->v_db[i].usedRows.value = NULL;
	}
	Ov_SetDynamicVectorLength(&pinst->v_tableRows, 9, UINT);
	pinst->v_dbNumberOfTables = 0;

	// Table SecurityData: ComponentID, Certificate, SecurityKey
	OV_STRING_VEC columnNames;
	columnNames.veclen = 0;
	columnNames.value = NULL;
	Ov_SetDynamicVectorLength(&columnNames, 3, STRING);
	OV_UINT_VEC dataTypes;
	dataTypes.veclen = 0;
	dataTypes.value = NULL;
	Ov_SetDynamicVectorLength(&dataTypes, 3, UINT);
	ov_string_setvalue(&columnNames.value[0], "ComponentID");
	ov_string_setvalue(&columnNames.value[1], "Certificate");
	ov_string_setvalue(&columnNames.value[2], "SecurityKey");
	dataTypes.value[0] = 1;
	dataTypes.value[1] = 1;
	dataTypes.value[2] = 1;
	result = initTable(&pinst->v_db[0], "SecurityData", columnNames, dataTypes);
	if (result != OV_ERR_OK){
		goto FINALIZE;
	}
	Ov_SetDynamicVectorLength(&columnNames, 0, STRING);
	pinst->v_dbNumberOfTables = 1;

	OV_STRING_VEC values;
	values.veclen = 0;
	values.value = NULL;
	Ov_SetDynamicVectorLength(&values, 3, STRING);
	ov_string_setvalue(&values.value[0], "DiscoveryServer");
	ov_string_setvalue(&values.value[1], "CertificateOfDS");
	ov_string_setvalue(&values.value[2], NULL);
	result = InsertRowIntoTable(pinst, &pinst->v_db[0], 0, values);
	if (result != OV_ERR_OK){
		goto FINALIZE;
	}
	Ov_SetDynamicVectorLength(&values, 0, STRING);


	// Table Endpoints: ComponentID, ProtocolType, EndpointString
	Ov_SetDynamicVectorLength(&columnNames, 3, STRING);
	Ov_SetDynamicVectorLength(&dataTypes, 3, UINT);
	ov_string_setvalue(&columnNames.value[0], "ComponentID");
	ov_string_setvalue(&columnNames.value[1], "ProtocolType");
	ov_string_setvalue(&columnNames.value[2], "EndpointString");
	dataTypes.value[0] = 1;
	dataTypes.value[1] = 1;
	dataTypes.value[2] = 1;
	result = initTable(&pinst->v_db[1],"Endpoints", columnNames, dataTypes);
	if (result != OV_ERR_OK){
		goto FINALIZE;
	}
	Ov_SetDynamicVectorLength(&columnNames, 0, STRING);
	pinst->v_dbNumberOfTables = 2;


	// Table PropertyID: ComponentID, Value
	Ov_SetDynamicVectorLength(&columnNames, 2, STRING);
	Ov_SetDynamicVectorLength(&dataTypes, 2, UINT);
	ov_string_setvalue(&columnNames.value[0], "ComponentID");
	ov_string_setvalue(&columnNames.value[1], "Value");
	dataTypes.value[0] = 1;
	dataTypes.value[1] = 1;
	result = initTable(&pinst->v_db[2],"PropertyID", columnNames, dataTypes);
	if (result != OV_ERR_OK){
		goto FINALIZE;
	}
	Ov_SetDynamicVectorLength(&columnNames, 0, STRING);
	pinst->v_dbNumberOfTables = 3;


	// Table CarrierID: ComponentID, Value
	Ov_SetDynamicVectorLength(&columnNames, 2, STRING);
	Ov_SetDynamicVectorLength(&dataTypes, 2, UINT);
	ov_string_setvalue(&columnNames.value[0], "ComponentID");
	ov_string_setvalue(&columnNames.value[1], "Value");
	dataTypes.value[0] = 1;
	dataTypes.value[1] = 1;
	result = initTable(&pinst->v_db[3],"CarrierID", columnNames, dataTypes);
	if (result != OV_ERR_OK){
		goto FINALIZE;
	}
	Ov_SetDynamicVectorLength(&columnNames, 0, STRING);
	pinst->v_dbNumberOfTables = 4;


	// Table ExpressionSemantic: ComponentID, Value
	Ov_SetDynamicVectorLength(&columnNames, 2, STRING);
	Ov_SetDynamicVectorLength(&dataTypes, 2, UINT);
	ov_string_setvalue(&columnNames.value[0], "ComponentID");
	ov_string_setvalue(&columnNames.value[1], "Value");
	dataTypes.value[0] = 1;
	dataTypes.value[1] = 1;
	result = initTable(&pinst->v_db[4],"ExpressionSemantic", columnNames, dataTypes);
	if (result != OV_ERR_OK){
		goto FINALIZE;
	}
	Ov_SetDynamicVectorLength(&columnNames, 0, STRING);
	pinst->v_dbNumberOfTables = 5;


	// Table Relation: ComponentID, Value
	Ov_SetDynamicVectorLength(&columnNames, 2, STRING);
	Ov_SetDynamicVectorLength(&dataTypes, 2, UINT);
	ov_string_setvalue(&columnNames.value[0], "ComponentID");
	ov_string_setvalue(&columnNames.value[1], "Value");
	dataTypes.value[0] = 1;
	dataTypes.value[1] = 1;
	result = initTable(&pinst->v_db[5],"Relation", columnNames, dataTypes);
	if (result != OV_ERR_OK){
		goto FINALIZE;
	}
	Ov_SetDynamicVectorLength(&columnNames, 0, STRING);
	pinst->v_dbNumberOfTables = 6;


	// Table SubModel: ComponentID, Value
	Ov_SetDynamicVectorLength(&columnNames, 2, STRING);
	Ov_SetDynamicVectorLength(&dataTypes, 2, UINT);
	ov_string_setvalue(&columnNames.value[0], "ComponentID");
	ov_string_setvalue(&columnNames.value[1], "Value");
	dataTypes.value[0] = 1;
	dataTypes.value[1] = 1;
	result = initTable(&pinst->v_db[6],"SubModel", columnNames, dataTypes);
	if (result != OV_ERR_OK){
		goto FINALIZE;
	}
	Ov_SetDynamicVectorLength(&columnNames, 0, STRING);
	pinst->v_dbNumberOfTables = 7;


	// Table statements_TextBoolean: ComponentID, CarrierID, PropertyID, ExpressionSemantic, Relation, Value, SubModel
	Ov_SetDynamicVectorLength(&columnNames, 7, STRING);
	Ov_SetDynamicVectorLength(&dataTypes, 7, UINT);
	ov_string_setvalue(&columnNames.value[0], "ComponentID");
	ov_string_setvalue(&columnNames.value[1], "CarrierID");
	ov_string_setvalue(&columnNames.value[2], "PropertyID");
	ov_string_setvalue(&columnNames.value[3], "ExpressionSemantic");
	ov_string_setvalue(&columnNames.value[4], "Relation");
	ov_string_setvalue(&columnNames.value[5], "Value");
	ov_string_setvalue(&columnNames.value[6], "SubModel");
	dataTypes.value[0] = 1;
	dataTypes.value[1] = 1;
	dataTypes.value[2] = 1;
	dataTypes.value[3] = 1;
	dataTypes.value[4] = 1;
	dataTypes.value[5] = 1;
	dataTypes.value[6] = 1;
	result = initTable(&pinst->v_db[7],"statements_TextBoolean", columnNames, dataTypes);
	if (result != OV_ERR_OK){
		goto FINALIZE;
	}
	Ov_SetDynamicVectorLength(&columnNames, 0, STRING);
	pinst->v_dbNumberOfTables = 8;

	// Table statements_Numeric: ComponentID, CarrierID, PropertyID, ExpressionSemantic, Relation, Value, SubModel
	Ov_SetDynamicVectorLength(&columnNames, 7, STRING);
	Ov_SetDynamicVectorLength(&dataTypes, 7, UINT);
	ov_string_setvalue(&columnNames.value[0], "ComponentID");
	ov_string_setvalue(&columnNames.value[1], "CarrierID");
	ov_string_setvalue(&columnNames.value[2], "PropertyID");
	ov_string_setvalue(&columnNames.value[3], "ExpressionSemantic");
	ov_string_setvalue(&columnNames.value[4], "Relation");
	ov_string_setvalue(&columnNames.value[5], "Value");
	ov_string_setvalue(&columnNames.value[6], "SubModel");
	dataTypes.value[0] = 1;
	dataTypes.value[1] = 1;
	dataTypes.value[2] = 1;
	dataTypes.value[3] = 1;
	dataTypes.value[4] = 1;
	dataTypes.value[5] = 2;
	dataTypes.value[6] = 1;
	result = initTable(&pinst->v_db[8],"statements_Numeric", columnNames, dataTypes);
	if (result != OV_ERR_OK){
		goto FINALIZE;
	}
	Ov_SetDynamicVectorLength(&columnNames, 0, STRING);
	pinst->v_dbNumberOfTables = 9;

	FINALIZE:
	if (result != OV_ERR_OK){
		for (OV_UINT i = 0; i < pinst->v_dbNumberOfTables; i++){
			deleteTableMembers(&pinst->v_db[i]);
		}
		pinst->v_dbNumberOfTables = 0;
		ov_database_free(&pinst->v_db);
		Ov_SetDynamicVectorLength(&pinst->v_tableRows, 0, UINT);
		return OV_ERR_GENERIC;
	}

	pinst->v_State = 1;

    return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLC_disconnect(OV_INSTPTR_openAASDiscoveryServer_Wrapper this) {
    /*    
    *   local variables
    */
	OV_INSTPTR_Databases_SQLC pinst = Ov_StaticPtrCast(Databases_SQLC, this);
	if (pinst->v_State != 1){
		return OV_ERR_OK;
	}

	for (OV_UINT i = 0; i < pinst->v_dbNumberOfTables; i++){
		deleteTableMembers(&pinst->v_db[i]);
	}
	ov_database_free(pinst->v_db);
	pinst->v_db = NULL;

	pinst->v_State = 2;
    return OV_ERR_OK;
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLC_insertData(OV_INSTPTR_openAASDiscoveryServer_DBWrapper this, const OV_STRING table, const OV_STRING* fields, OV_UINT fieldsLen, const OV_STRING* values, OV_UINT valuesLen) {
    /*    
    *   local variables
    */

	OV_RESULT result = OV_ERR_OK;
	OV_INSTPTR_Databases_SQLC pinst = Ov_StaticPtrCast(Databases_SQLC, this);


	OV_UINT tableNumber = 99;
	for (OV_UINT i = 0; i < pinst->v_dbNumberOfTables; i ++){
		if (ov_string_compare(pinst->v_db[i].tableName, table) == OV_STRCMP_EQUAL){
			tableNumber = i;
			break;
		}
	}
	if (tableNumber == 99){
		return OV_ERR_BADPARAM;
	}

	// TODO: Easier model
	OV_STRING_VEC insertValues;
	insertValues.veclen = 0;
	insertValues.value = NULL;
	Ov_SetDynamicVectorLength(&insertValues, pinst->v_db[tableNumber].columnNames.veclen, STRING);
	for (OV_UINT i = 0; i < pinst->v_db[tableNumber].columnNames.veclen; i++){
		insertValues.value[i] = NULL;
		for (OV_UINT j = 0; j < fieldsLen; j++){
			if (ov_string_compare(pinst->v_db[tableNumber].columnNames.value[i], fields[j]) == OV_STRCMP_EQUAL){
				ov_string_setvalue(&insertValues.value[i], values[j]);
				break;
			}
		}
	}
	result = InsertRowIntoTable(pinst, &pinst->v_db[tableNumber], tableNumber,  insertValues);
	Ov_SetDynamicVectorLength(&insertValues, 0, STRING);
    return result;
}


OV_DLLFNCEXPORT OV_RESULT Databases_SQLC_selectData(OV_INSTPTR_openAASDiscoveryServer_DBWrapper this, const OV_STRING table, const OV_STRING* fields, OV_UINT fieldsLen, const OV_STRING* whereFields, OV_UINT whereFieldsLen, OV_STRING* whereValues, OV_UINT whereValuesLen, OV_STRING_VEC* result) {
    /*
    *   local variables
    */

	OV_RESULT resultOV = OV_ERR_OK;
	OV_INSTPTR_Databases_SQLC pinst = Ov_StaticPtrCast(Databases_SQLC, this);


	OV_UINT tableNumber = 99;
	for (OV_UINT i = 0; i < pinst->v_dbNumberOfTables; i ++){
		if (ov_string_compare(pinst->v_db[i].tableName, table) == OV_STRCMP_EQUAL){
			tableNumber = i;
			break;
		}
	}
	if (tableNumber == 99){
		return OV_ERR_BADPARAM;
	}

	// TODO: Easier model
	OV_STRING_VEC findRowValues;
	findRowValues.veclen = 0;
	findRowValues.value = NULL;
	Ov_SetDynamicVectorLength(&findRowValues, pinst->v_db[tableNumber].columnNames.veclen, STRING);
	for (OV_UINT i = 0; i < pinst->v_db[tableNumber].columnNames.veclen; i++){
		findRowValues.value[i] = NULL;
		for (OV_UINT j = 0; j < whereFieldsLen; j++){
			if (ov_string_compare(pinst->v_db[tableNumber].columnNames.value[i], whereFields[j]) == OV_STRCMP_EQUAL){
				ov_string_setvalue(&findRowValues.value[i], whereValues[j]);
				break;
			}
		}
	}

	OV_STRING_VEC selectColumns;
	selectColumns.veclen = 0;
	selectColumns.value = NULL;
	Ov_SetDynamicVectorLength(&selectColumns, fieldsLen, STRING);
	for (OV_UINT i = 0; i < fieldsLen; i++){
		ov_string_setvalue(&selectColumns.value[i], fields[i]);
	}

	resultOV = SelectTable(pinst, &pinst->v_db[tableNumber], findRowValues, selectColumns, result);
	Ov_SetDynamicVectorLength(&selectColumns, 0, STRING);
	Ov_SetDynamicVectorLength(&findRowValues, 0, STRING);
	return resultOV;
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLC_deleteData(OV_INSTPTR_openAASDiscoveryServer_DBWrapper this, const OV_STRING table, const OV_STRING* fields, OV_UINT fieldsLen, const OV_STRING* values, OV_UINT valuesLen) {
    /*    
    *   local variables
    */

	OV_RESULT result = OV_ERR_OK;
	OV_INSTPTR_Databases_SQLC pinst = Ov_StaticPtrCast(Databases_SQLC, this);


	OV_UINT tableNumber = 99;
	for (OV_UINT i = 0; i < pinst->v_dbNumberOfTables; i ++){
		if (ov_string_compare(pinst->v_db[i].tableName, table) == OV_STRCMP_EQUAL){
			tableNumber = i;
			break;
		}
	}
	if (tableNumber == 99){
		return OV_ERR_BADPARAM;
	}

	// TODO: Easier model
	OV_STRING_VEC deleteValues;
	deleteValues.veclen = 0;
	deleteValues.value = NULL;
	Ov_SetDynamicVectorLength(&deleteValues, pinst->v_db[tableNumber].columnNames.veclen, STRING);
	for (OV_UINT i = 0; i < pinst->v_db[tableNumber].columnNames.veclen; i++){
		deleteValues.value[i] = NULL;
		for (OV_UINT j = 0; j < fieldsLen; j++){
			if (ov_string_compare(pinst->v_db[tableNumber].columnNames.value[i], fields[j]) == OV_STRCMP_EQUAL){
				ov_string_setvalue(&deleteValues.value[i], values[j]);
				break;
			}
		}
	}
	result = DeleteRowInTable(pinst, &pinst->v_db[tableNumber], tableNumber, deleteValues);
	Ov_SetDynamicVectorLength(&deleteValues, 0, STRING);
    return result;
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLC_updateData(OV_INSTPTR_openAASDiscoveryServer_DBWrapper this, const OV_STRING table, const OV_STRING* fields, OV_UINT fieldsLen, const OV_STRING* fieldValues, OV_UINT fieldValuesLen, const OV_STRING* whereFields, OV_UINT whereFieldsLen, OV_STRING* whereValues, OV_UINT whereValuesLen) {
    /*    
    *   local variables
    */

	OV_RESULT result = OV_ERR_OK;
	OV_INSTPTR_Databases_SQLC pinst = Ov_StaticPtrCast(Databases_SQLC, this);


	OV_UINT tableNumber = 99;
	for (OV_UINT i = 0; i < pinst->v_dbNumberOfTables; i ++){
		if (ov_string_compare(pinst->v_db[i].tableName, table) == OV_STRCMP_EQUAL){
			tableNumber = i;
			break;
		}
	}
	if (tableNumber == 99){
		return OV_ERR_BADPARAM;
	}

	// TODO: Easier model
	OV_STRING_VEC findValues;
	findValues.veclen = 0;
	findValues.value = NULL;
	Ov_SetDynamicVectorLength(&findValues, pinst->v_db[tableNumber].columnNames.veclen, STRING);
	for (OV_UINT i = 0; i < pinst->v_db[tableNumber].columnNames.veclen; i++){
		findValues.value[i] = NULL;
		for (OV_UINT j = 0; j < whereFieldsLen; j++){
			if (ov_string_compare(pinst->v_db[tableNumber].columnNames.value[i], whereFields[j]) == OV_STRCMP_EQUAL){
				ov_string_setvalue(&findValues.value[i], whereValues[j]);
				break;
			}
		}
	}
	OV_STRING_VEC updateColumn;
	updateColumn.veclen = 0;
	updateColumn.value = NULL;
	Ov_SetDynamicVectorLength(&updateColumn, fieldsLen, STRING);
	for (OV_UINT i = 0; i < fieldsLen; i++){
		ov_string_setvalue(&updateColumn.value[i], fields[i]);
	}
	OV_STRING_VEC updateValues;
	updateValues.veclen = 0;
	updateValues.value = NULL;
	Ov_SetDynamicVectorLength(&updateValues, fieldValuesLen, STRING);
	for (OV_UINT i = 0; i < fieldValuesLen; i++){
		ov_string_setvalue(&updateValues.value[i], fieldValues[i]);
	}

	result = UpdateRowInTable(pinst,  &pinst->v_db[tableNumber], findValues, updateColumn, updateValues);
	Ov_SetDynamicVectorLength(&findValues, 0, STRING);
	Ov_SetDynamicVectorLength(&updateColumn, 0, STRING);
	Ov_SetDynamicVectorLength(&updateValues, 0, STRING);
	return result;
}

struct compareResult{
	OV_UINT pointerNumber;
	OV_UINT componentCount;
};

int compare( const void* a, const void* b){
	return (((struct compareResult*)a)->componentCount - ((struct compareResult*)b)->componentCount);
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLC_getComponentID2(OV_INSTPTR_openAASDiscoveryServer_DBWrapper this, const OV_STRING_VEC* table, const DB_QUERY* db_query, OV_UINT querySize, OV_STRING_VEC* result) {
    /*
    *   local variables
    */

	OV_RESULT resultOV = OV_ERR_OK;
	OV_INSTPTR_Databases_SQLC pinst = Ov_StaticPtrCast(Databases_SQLC, this);

	OV_UINT_VEC tableNumber;
	tableNumber.veclen = 0;
	tableNumber.value = NULL;
	Ov_SetDynamicVectorLength(&tableNumber, querySize, UINT);
	for (OV_UINT i = 0; i < querySize; i++){
		tableNumber.value[i] = 99;
	}

	for (OV_UINT i = 0; i < querySize; i++){
		for (OV_UINT j = 0; j < pinst->v_dbNumberOfTables; j ++){
			if (ov_string_compare(pinst->v_db[j].tableName, table[i].value[0]) == OV_STRCMP_EQUAL){
				tableNumber.value[i] = j;
				break;
			}
		}
	}
	for (OV_UINT i = 0; i < tableNumber.veclen; i++){
		if (tableNumber.value[i] == 99){
			return OV_ERR_BADPARAM;
		}
	}


	// TODO: Easier model
	OV_STRING_VEC findRowValues[querySize];
	OV_UINT_VEC findRowRelation[querySize];
	for (OV_UINT i = 0; i < querySize; i++){
		findRowValues[i].veclen = 0;
		findRowValues[i].value = NULL;
		findRowRelation[i].veclen = 0;
		findRowRelation[i].value = NULL;
		if (db_query[i].value.veclen > 0){
			Ov_SetDynamicVectorLength(&findRowValues[i], pinst->v_db[tableNumber.value[i]].columnNames.veclen, STRING);
			Ov_SetDynamicVectorLength(&findRowRelation[i], pinst->v_db[tableNumber.value[i]].columnNames.veclen, UINT);
			for (OV_UINT j = 0; j < pinst->v_db[tableNumber.value[i]].columnNames.veclen; j++){
				findRowValues[i].value[j] = NULL;
				for (OV_UINT k = 0; k < db_query[i].column.veclen; k++){
					if (ov_string_compare(pinst->v_db[tableNumber.value[i]].columnNames.value[j], db_query[i].column.value[k]) == OV_STRCMP_EQUAL){
						ov_string_setvalue(&(findRowValues[i].value[j]), db_query[i].value.value[k]);
						findRowRelation[i].value[j] = 0;
						break;
					}
				}
			}
		}else if (db_query[i].value_optional.veclen > 0){
			Ov_SetDynamicVectorLength(&findRowValues[i], db_query[i].value_optional.veclen / db_query[i].column.veclen * pinst->v_db[tableNumber.value[i]].columnNames.veclen , STRING);
			Ov_SetDynamicVectorLength(&findRowRelation[i], db_query[i].value_optional.veclen / db_query[i].column.veclen * pinst->v_db[tableNumber.value[i]].columnNames.veclen, UINT);
			for (OV_UINT j = 0; j < findRowValues[i].veclen / pinst->v_db[tableNumber.value[i]].columnNames.veclen; j++){
				for (OV_UINT k = 0; k < pinst->v_db[tableNumber.value[i]].columnNames.veclen; k++){
					for (OV_UINT l = 0; l < db_query[i].column.veclen; l++){
						if (ov_string_compare(pinst->v_db[tableNumber.value[i]].columnNames.value[k], db_query[i].column.value[l]) == OV_STRCMP_EQUAL){
							ov_string_setvalue(&(findRowValues[i].value[j*pinst->v_db[tableNumber.value[i]].columnNames.veclen+k]), db_query[i].value_optional.value[j*db_query[i].column.veclen+l]);
							// findRowRelation: 0:==, 1:<, 2:<=, 3:!=, 4:>=, 5:>
							if (ov_string_compare(db_query[i].value_optional_relation.value[j*db_query[i].column.veclen+l], "==") == OV_STRCMP_EQUAL){
								findRowRelation[i].value[j*pinst->v_db[tableNumber.value[i]].columnNames.veclen+k] = 0;
							}else if (ov_string_compare(db_query[i].value_optional_relation.value[j*db_query[i].column.veclen+l], "<") == OV_STRCMP_EQUAL){
								findRowRelation[i].value[j*pinst->v_db[tableNumber.value[i]].columnNames.veclen+k] = 1;
							}else if (ov_string_compare(db_query[i].value_optional_relation.value[j*db_query[i].column.veclen+l], "<=") == OV_STRCMP_EQUAL){
								findRowRelation[i].value[j*pinst->v_db[tableNumber.value[i]].columnNames.veclen+k] = 2;
							}else if (ov_string_compare(db_query[i].value_optional_relation.value[j*db_query[i].column.veclen+l], "!=") == OV_STRCMP_EQUAL){
								findRowRelation[i].value[j*pinst->v_db[tableNumber.value[i]].columnNames.veclen+k] = 3;
							}else if (ov_string_compare(db_query[i].value_optional_relation.value[j*db_query[i].column.veclen+l], ">=") == OV_STRCMP_EQUAL){
								findRowRelation[i].value[j*pinst->v_db[tableNumber.value[i]].columnNames.veclen+k] = 4;
							}else if (ov_string_compare(db_query[i].value_optional_relation.value[j*db_query[i].column.veclen+l], ">") == OV_STRCMP_EQUAL){
								findRowRelation[i].value[j*pinst->v_db[tableNumber.value[i]].columnNames.veclen+k] = 5;
							}else{
								findRowRelation[i].value[j*pinst->v_db[tableNumber.value[i]].columnNames.veclen+k] = 0;
							}
							break;
						}
					}
				}
			}
		}

	}

	OV_STRING_VEC selectColumns;
	selectColumns.veclen = 0;
	selectColumns.value = NULL;
	Ov_SetDynamicVectorLength(&selectColumns, 1, STRING);
	ov_string_setvalue(&selectColumns.value[0], "ComponentID");

	// find matching rows
	OV_STRING_VEC tmpResults[querySize];
	struct compareResult* tmpResultsCount = NULL;
	tmpResultsCount = (struct compareResult*)ov_database_malloc(sizeof(struct compareResult)*querySize);
	for (OV_UINT i = 0; i < querySize; i++){
		tmpResults[i].veclen = 0;
		tmpResults[i].value = NULL;
		resultOV = SelectTable2(pinst, &pinst->v_db[tableNumber.value[i]], findRowValues[i], findRowRelation[i], selectColumns, &tmpResults[i]);
		tmpResultsCount[i].componentCount = tmpResults[i].veclen;
		tmpResultsCount[i].pointerNumber = i;
	}

	if (querySize > 1){
		qsort(tmpResultsCount, querySize, sizeof(struct compareResult), compare);

		OV_UINT_VEC equalResults;
		equalResults.value = NULL;
		equalResults.veclen = 0;
		Ov_SetDynamicVectorLength(&equalResults, tmpResultsCount[0].componentCount, UINT);
		OV_UINT equalResultsCount = 0;
		OV_BOOL foundEqualValue = FALSE;
		for (OV_UINT i = 0; i < tmpResultsCount[0].componentCount; i++){
			equalResults.value[i] = 0;
			for (OV_UINT j = 1; j < querySize; j++){
				foundEqualValue = FALSE;
				for (OV_UINT k = 0; k < tmpResultsCount[j].componentCount; k++){
					if (ov_string_compare(((OV_STRING_VEC*)tmpResults)[tmpResultsCount[0].pointerNumber].value[i], ((OV_STRING_VEC*)tmpResults)[tmpResultsCount[j].pointerNumber].value[k]) == OV_STRCMP_EQUAL){
						foundEqualValue = TRUE;
						break;
					}
				}
				if (foundEqualValue == FALSE){
					break;
				}
				if (j == querySize-1){
					equalResults.value[i] = 1;
					equalResultsCount = equalResultsCount + 1;
				}
			}
		}
		Ov_SetDynamicVectorLength(result, equalResultsCount, STRING);
		OV_UINT resultCount = 0;
		for (OV_UINT i = 0; i < tmpResultsCount[0].componentCount; i++){
			if (equalResults.value[i] == 1){
				result->value[resultCount] = NULL;
				ov_string_setvalue(&result->value[resultCount], ((OV_STRING_VEC*)tmpResults)[tmpResultsCount[0].pointerNumber].value[i]);
				resultCount = resultCount + 1;
			}
		}
		Ov_SetDynamicVectorLength(&equalResults, 0, UINT);
	}else{
		Ov_SetDynamicVectorLength(result, tmpResults[0].veclen, STRING);
		for (OV_UINT i = 0; i < tmpResults[0].veclen; i++){
				result->value[i] = NULL;
				ov_string_setvalue(&result->value[i], tmpResults[0].value[i]);
		}
	}

	for (OV_UINT i = 0; i < querySize; i++){
		Ov_SetDynamicVectorLength(&findRowValues[i], 0, STRING);
		Ov_SetDynamicVectorLength(&findRowRelation[i], 0, UINT);
		Ov_SetDynamicVectorLength(&tmpResults[i], 0, STRING);
	}

	Ov_SetDynamicVectorLength(&tableNumber, 0, UINT);
	Ov_SetDynamicVectorLength(&selectColumns, 0, STRING);
	ov_database_free(tmpResultsCount);
    return resultOV;
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLC_getComponentID(OV_INSTPTR_openAASDiscoveryServer_DBWrapper this, const OV_STRING_VEC* table, const DB_QUERY* db_query, OV_UINT querySize, OV_STRING_VEC* result) {
    /*
    *   local variables
    */
	Databases_SQLC_getComponentID2(this, table, db_query, querySize, result);
	return OV_ERR_OK;

	OV_RESULT resultOV = OV_ERR_OK;
	OV_INSTPTR_Databases_SQLC pinst = Ov_StaticPtrCast(Databases_SQLC, this);

	OV_UINT_VEC tableNumber;
	tableNumber.veclen = 0;
	tableNumber.value = NULL;
	Ov_SetDynamicVectorLength(&tableNumber, querySize, UINT);
	for (OV_UINT i = 0; i < querySize; i++){
		tableNumber.value[i] = 99;
	}

	for (OV_UINT i = 0; i < querySize; i++){
		for (OV_UINT j = 0; j < pinst->v_dbNumberOfTables; j ++){
			if (ov_string_compare(pinst->v_db[j].tableName, table[i].value[0]) == OV_STRCMP_EQUAL){
				tableNumber.value[i] = j;
				break;
			}
		}
	}
	for (OV_UINT i = 0; i < tableNumber.veclen; i++){
		if (tableNumber.value[i] == 99){
			return OV_ERR_BADPARAM;
		}
	}


	// TODO: Easier model
	OV_STRING_VEC findRowValues[querySize];
	for (OV_UINT i = 0; i < querySize; i++){
		findRowValues[i].veclen = 0;
		findRowValues[i].value = NULL;
		if (db_query[i].value.veclen > 0){
			Ov_SetDynamicVectorLength(&findRowValues[i], pinst->v_db[tableNumber.value[i]].columnNames.veclen, STRING);
			for (OV_UINT j = 0; j < pinst->v_db[tableNumber.value[i]].columnNames.veclen; j++){
				findRowValues[i].value[j] = NULL;
				for (OV_UINT k = 0; k < db_query[i].column.veclen; k++){
					if (ov_string_compare(pinst->v_db[tableNumber.value[i]].columnNames.value[j], db_query[i].column.value[k]) == OV_STRCMP_EQUAL){
						ov_string_setvalue(&(findRowValues[i].value[j]), db_query[i].value.value[k]);
						break;
					}
				}
			}
		}
	}

	OV_STRING_VEC selectColumns;
	selectColumns.veclen = 0;
	selectColumns.value = NULL;
	Ov_SetDynamicVectorLength(&selectColumns, 1, STRING);
	ov_string_setvalue(&selectColumns.value[0], "ComponentID");

	// find matching rows
	OV_STRING_VEC tmpResults[querySize];
	struct compareResult* tmpResultsCount = NULL;
	tmpResultsCount = (struct compareResult*)ov_database_malloc(sizeof(struct compareResult)*querySize);
	for (OV_UINT i = 0; i < querySize; i++){
		tmpResults[i].veclen = 0;
		tmpResults[i].value = NULL;
		resultOV = SelectTable(pinst, &pinst->v_db[tableNumber.value[i]], findRowValues[i], selectColumns, &tmpResults[i]);
		tmpResultsCount[i].componentCount = tmpResults[i].veclen;
		tmpResultsCount[i].pointerNumber = i;
	}

	if (querySize > 1){
		qsort(tmpResultsCount, querySize, sizeof(struct compareResult), compare);

		OV_UINT_VEC equalResults;
		equalResults.value = NULL;
		equalResults.veclen = 0;
		Ov_SetDynamicVectorLength(&equalResults, tmpResultsCount[0].componentCount, UINT);
		OV_UINT equalResultsCount = 0;
		OV_BOOL foundEqualValue = FALSE;
		for (OV_UINT i = 0; i < tmpResultsCount[0].componentCount; i++){
			equalResults.value[i] = 0;
			for (OV_UINT j = 1; j < querySize; j++){
				foundEqualValue = FALSE;
				for (OV_UINT k = 0; k < tmpResultsCount[j].componentCount; k++){
					if (ov_string_compare(((OV_STRING_VEC*)tmpResults)[tmpResultsCount[0].pointerNumber].value[i], ((OV_STRING_VEC*)tmpResults)[tmpResultsCount[j].pointerNumber].value[k]) == OV_STRCMP_EQUAL){
						foundEqualValue = TRUE;
						break;
					}
				}
				if (foundEqualValue == FALSE){
					break;
				}
				if (j == querySize-1){
					equalResults.value[i] = 1;
					equalResultsCount = equalResultsCount + 1;
				}
			}
		}
		Ov_SetDynamicVectorLength(result, equalResultsCount, STRING);
		OV_UINT resultCount = 0;
		for (OV_UINT i = 0; i < tmpResultsCount[0].componentCount; i++){
			if (equalResults.value[i] == 1){
				result->value[resultCount] = NULL;
				ov_string_setvalue(&result->value[resultCount], ((OV_STRING_VEC*)tmpResults)[tmpResultsCount[0].pointerNumber].value[i]);
				resultCount = resultCount + 1;
			}
		}
		Ov_SetDynamicVectorLength(&equalResults, 0, UINT);
	}else{
		Ov_SetDynamicVectorLength(result, tmpResults[0].veclen, STRING);
		for (OV_UINT i = 0; i < tmpResults[0].veclen; i++){
				result->value[i] = NULL;
				ov_string_setvalue(&result->value[i], tmpResults[0].value[i]);
		}
	}

	for (OV_UINT i = 0; i < querySize; i++){
		Ov_SetDynamicVectorLength(&findRowValues[i], 0, STRING);
		Ov_SetDynamicVectorLength(&tmpResults[i], 0, STRING);
	}

	Ov_SetDynamicVectorLength(&tableNumber, 0, UINT);
	Ov_SetDynamicVectorLength(&selectColumns, 0, STRING);
	ov_database_free(tmpResultsCount);
    return resultOV;
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLC_getFittingStatements(OV_INSTPTR_openAASDiscoveryServer_DBWrapper this, const OV_STRING_VEC* table, const OV_STRING ComponentID, const DB_QUERY* db_query, OV_UINT querySize, OV_STRING_VEC* result) {
    /*    
    *   local variables
    */

	OV_RESULT resultOV = OV_ERR_OK;
	OV_INSTPTR_Databases_SQLC pinst = Ov_StaticPtrCast(Databases_SQLC, this);

	OV_UINT_VEC tableNumber;
	tableNumber.veclen = 0;
	tableNumber.value = NULL;
	Ov_SetDynamicVectorLength(&tableNumber, querySize, UINT);
	for (OV_UINT i = 0; i < querySize; i++){
		tableNumber.value[i] = 99;
	}

	for (OV_UINT i = 0; i < querySize; i++){
		for (OV_UINT j = 0; j < pinst->v_dbNumberOfTables; j ++){
			if (ov_string_compare(pinst->v_db[j].tableName, table[i].value[0]) == OV_STRCMP_EQUAL){
				tableNumber.value[i] = j;
				break;
			}
		}
	}
	for (OV_UINT i = 0; i < tableNumber.veclen; i++){
		if (tableNumber.value[i] == 99){
			return OV_ERR_BADPARAM;
		}
	}


	// TODO: Easier model
	OV_STRING_VEC findRowValues[querySize];
	OV_UINT_VEC findRowRelation[querySize];
	for (OV_UINT i = 0; i < querySize; i++){
		findRowValues[i].veclen = 0;
		findRowValues[i].value = NULL;
		findRowRelation[i].veclen = 0;
		findRowRelation[i].value = NULL;
		if (db_query[i].value.veclen > 0){
			Ov_SetDynamicVectorLength(&findRowValues[i], pinst->v_db[tableNumber.value[i]].columnNames.veclen, STRING);
			Ov_SetDynamicVectorLength(&findRowRelation[i], pinst->v_db[tableNumber.value[i]].columnNames.veclen, UINT);
			for (OV_UINT j = 0; j < pinst->v_db[tableNumber.value[i]].columnNames.veclen; j++){
				if (j == 0){
					ov_string_setvalue(&(findRowValues[i].value[j]), ComponentID);
					continue;
				}
				findRowValues[i].value[j] = NULL;
				for (OV_UINT k = 0; k < db_query[i].column.veclen; k++){
					if (ov_string_compare(pinst->v_db[tableNumber.value[i]].columnNames.value[j], db_query[i].column.value[k]) == OV_STRCMP_EQUAL){
						ov_string_setvalue(&(findRowValues[i].value[j]), db_query[i].value.value[k]);
						findRowRelation[i].value[j] = 0;
						break;
					}
				}
			}
		}else if (db_query[i].value_optional.veclen > 0){
			Ov_SetDynamicVectorLength(&findRowValues[i], db_query[i].value_optional.veclen / db_query[i].column.veclen * pinst->v_db[tableNumber.value[i]].columnNames.veclen , STRING);
			Ov_SetDynamicVectorLength(&findRowRelation[i], db_query[i].value_optional.veclen / db_query[i].column.veclen * pinst->v_db[tableNumber.value[i]].columnNames.veclen, UINT);
			for (OV_UINT j = 0; j < findRowValues[i].veclen / pinst->v_db[tableNumber.value[i]].columnNames.veclen; j++){
				for (OV_UINT k = 0; k < pinst->v_db[tableNumber.value[i]].columnNames.veclen; k++){
					if (k == 0){
						ov_string_setvalue(&(findRowValues[i].value[j*pinst->v_db[tableNumber.value[i]].columnNames.veclen+k]), ComponentID);
						continue;
					}
					for (OV_UINT l = 0; l < db_query[i].column.veclen; l++){
						if (ov_string_compare(pinst->v_db[tableNumber.value[i]].columnNames.value[k], db_query[i].column.value[l]) == OV_STRCMP_EQUAL){
							ov_string_setvalue(&(findRowValues[i].value[j*pinst->v_db[tableNumber.value[i]].columnNames.veclen+k]), db_query[i].value_optional.value[j*db_query[i].column.veclen+l]);
							// findRowRelation: 0:==, 1:<, 2:<=, 3:!=, 4:>=, 5:>
							if (ov_string_compare(db_query[i].value_optional_relation.value[j*db_query[i].column.veclen+l], "==") == OV_STRCMP_EQUAL){
								findRowRelation[i].value[j*pinst->v_db[tableNumber.value[i]].columnNames.veclen+k] = 0;
							}else if (ov_string_compare(db_query[i].value_optional_relation.value[j*db_query[i].column.veclen+l], "<") == OV_STRCMP_EQUAL){
								findRowRelation[i].value[j*pinst->v_db[tableNumber.value[i]].columnNames.veclen+k] = 1;
							}else if (ov_string_compare(db_query[i].value_optional_relation.value[j*db_query[i].column.veclen+l], "<=") == OV_STRCMP_EQUAL){
								findRowRelation[i].value[j*pinst->v_db[tableNumber.value[i]].columnNames.veclen+k] = 2;
							}else if (ov_string_compare(db_query[i].value_optional_relation.value[j*db_query[i].column.veclen+l], "!=") == OV_STRCMP_EQUAL){
								findRowRelation[i].value[j*pinst->v_db[tableNumber.value[i]].columnNames.veclen+k] = 3;
							}else if (ov_string_compare(db_query[i].value_optional_relation.value[j*db_query[i].column.veclen+l], ">=") == OV_STRCMP_EQUAL){
								findRowRelation[i].value[j*pinst->v_db[tableNumber.value[i]].columnNames.veclen+k] = 4;
							}else if (ov_string_compare(db_query[i].value_optional_relation.value[j*db_query[i].column.veclen+l], ">") == OV_STRCMP_EQUAL){
								findRowRelation[i].value[j*pinst->v_db[tableNumber.value[i]].columnNames.veclen+k] = 5;
							}else{
								findRowRelation[i].value[j*pinst->v_db[tableNumber.value[i]].columnNames.veclen+k] = 0;
							}
							break;
						}
					}
				}
			}
		}

	}

	OV_STRING_VEC selectColumns;
	selectColumns.veclen = 0;
	selectColumns.value = NULL;
	Ov_SetDynamicVectorLength(&selectColumns, 7, STRING);
	ov_string_setvalue(&selectColumns.value[0], "ComponentID");
	ov_string_setvalue(&selectColumns.value[1], "CarrierID");
	ov_string_setvalue(&selectColumns.value[2], "PropertyID");
	ov_string_setvalue(&selectColumns.value[3], "ExpressionSemantic");
	ov_string_setvalue(&selectColumns.value[4], "Relation");
	ov_string_setvalue(&selectColumns.value[5], "Value");
	ov_string_setvalue(&selectColumns.value[6], "SubModel");

	// find matching rows
	OV_STRING_VEC tmpResults[querySize];
	struct compareResult* tmpResultsCount = NULL;
	tmpResultsCount = (struct compareResult*)ov_database_malloc(sizeof(struct compareResult)*querySize);
	for (OV_UINT i = 0; i < querySize; i++){
		tmpResults[i].veclen = 0;
		tmpResults[i].value = NULL;
		resultOV = SelectTable2(pinst, &pinst->v_db[tableNumber.value[i]], findRowValues[i], findRowRelation[i], selectColumns, &tmpResults[i]);
		tmpResultsCount[i].componentCount = tmpResults[i].veclen;
		tmpResultsCount[i].pointerNumber = i;
	}

	if (querySize > 1){
		qsort(tmpResultsCount, querySize, sizeof(struct compareResult), compare);

		OV_UINT_VEC equalResults;
		equalResults.value = NULL;
		equalResults.veclen = 0;
		Ov_SetDynamicVectorLength(&equalResults, tmpResultsCount[0].componentCount/7, UINT);
		OV_UINT equalResultsCount = 0;
		OV_BOOL foundEqualValue = FALSE;
		for (OV_UINT i = 0; i < tmpResultsCount[0].componentCount/7; i++){
			equalResults.value[i] = 0;
			foundEqualValue = TRUE;
			for (OV_UINT j = 1; j < querySize; j++){
				for (OV_UINT k = 0; k < tmpResultsCount[j].componentCount/7; k++){
					foundEqualValue = TRUE;
					if (ov_string_compare(((OV_STRING_VEC*)tmpResults)[tmpResultsCount[0].pointerNumber].value[i*7+0], ((OV_STRING_VEC*)tmpResults)[tmpResultsCount[j].pointerNumber].value[k*7+0]) != OV_STRCMP_EQUAL ||
					ov_string_compare(((OV_STRING_VEC*)tmpResults)[tmpResultsCount[0].pointerNumber].value[i*7+1], ((OV_STRING_VEC*)tmpResults)[tmpResultsCount[j].pointerNumber].value[k*7+1]) != OV_STRCMP_EQUAL ||
					ov_string_compare(((OV_STRING_VEC*)tmpResults)[tmpResultsCount[0].pointerNumber].value[i*7+2], ((OV_STRING_VEC*)tmpResults)[tmpResultsCount[j].pointerNumber].value[k*7+2]) != OV_STRCMP_EQUAL ||
					ov_string_compare(((OV_STRING_VEC*)tmpResults)[tmpResultsCount[0].pointerNumber].value[i*7+3], ((OV_STRING_VEC*)tmpResults)[tmpResultsCount[j].pointerNumber].value[k*7+3]) != OV_STRCMP_EQUAL ||
					ov_string_compare(((OV_STRING_VEC*)tmpResults)[tmpResultsCount[0].pointerNumber].value[i*7+4], ((OV_STRING_VEC*)tmpResults)[tmpResultsCount[j].pointerNumber].value[k*7+4]) != OV_STRCMP_EQUAL ||
					ov_string_compare(((OV_STRING_VEC*)tmpResults)[tmpResultsCount[0].pointerNumber].value[i*7+5], ((OV_STRING_VEC*)tmpResults)[tmpResultsCount[j].pointerNumber].value[k*7+5]) != OV_STRCMP_EQUAL ||
					ov_string_compare(((OV_STRING_VEC*)tmpResults)[tmpResultsCount[0].pointerNumber].value[i*7+6], ((OV_STRING_VEC*)tmpResults)[tmpResultsCount[j].pointerNumber].value[k*7+6]) != OV_STRCMP_EQUAL){
						foundEqualValue = FALSE;
					}
					if (foundEqualValue == TRUE){
						break;
					}
				}
				if (foundEqualValue == FALSE){
					break;
				}
				if (j == querySize-1){
					equalResults.value[i] = 1;
					equalResultsCount = equalResultsCount + 1;
				}
			}
		}
		Ov_SetDynamicVectorLength(result, equalResultsCount, STRING);
		OV_UINT resultCount = 0;
		OV_STRING tmpString = NULL;
		for (OV_UINT i = 0; i < tmpResultsCount[0].componentCount/7; i++){
			if (equalResults.value[i] == 1){

				result->value[resultCount] = NULL;
				tmpString = NULL;
				ov_string_setvalue(&tmpString, "\"CarrierID\":\"");
				ov_string_append(&tmpString, ((OV_STRING_VEC*)tmpResults)[tmpResultsCount[0].pointerNumber].value[1+resultCount*7]);
				ov_string_append(&tmpString, "\", \"PropertyID\":\"");
				ov_string_append(&tmpString, ((OV_STRING_VEC*)tmpResults)[tmpResultsCount[0].pointerNumber].value[2+resultCount*7]);
				ov_string_append(&tmpString, "\", \"ExpressionSemantic\":\"");
				ov_string_append(&tmpString, ((OV_STRING_VEC*)tmpResults)[tmpResultsCount[0].pointerNumber].value[3+resultCount*7]);
				ov_string_append(&tmpString, "\", \"Relation\":\"");
				ov_string_append(&tmpString, ((OV_STRING_VEC*)tmpResults)[tmpResultsCount[0].pointerNumber].value[4+resultCount*7]);
				ov_string_append(&tmpString, "\", \"Value\":\"");
				ov_string_append(&tmpString, ((OV_STRING_VEC*)tmpResults)[tmpResultsCount[0].pointerNumber].value[5+resultCount*7]);
				ov_string_append(&tmpString, "\", \"SubModel\":\"");
				ov_string_append(&tmpString, ((OV_STRING_VEC*)tmpResults)[tmpResultsCount[0].pointerNumber].value[6+resultCount*7]);
				ov_string_append(&tmpString, "\"");
				ov_string_setvalue(&result->value[resultCount], tmpString);
				ov_string_setvalue(&tmpString, NULL);
				resultCount = resultCount + 1;
			}
		}
		Ov_SetDynamicVectorLength(&equalResults, 0, UINT);
	}else{
		Ov_SetDynamicVectorLength(result, tmpResults[0].veclen/7, STRING);
		OV_UINT tmpCount = 0;
		OV_STRING tmpString = NULL;
		for (OV_UINT j = 0; j < tmpResults[0].veclen/7; j++){
			tmpString = NULL;
			ov_string_setvalue(&tmpString, "\"CarrierID\":\"");
			ov_string_append(&tmpString, tmpResults[0].value[1+j*7]);
			ov_string_append(&tmpString, "\", \"PropertyID\":\"");
			ov_string_append(&tmpString, tmpResults[0].value[2+j*7]);
			ov_string_append(&tmpString, "\", \"ExpressionSemantic\":\"");
			ov_string_append(&tmpString, tmpResults[0].value[3+j*7]);
			ov_string_append(&tmpString, "\", \"Relation\":\"");
			ov_string_append(&tmpString, tmpResults[0].value[4+j*7]);
			ov_string_append(&tmpString, "\", \"Value\":\"");
			ov_string_append(&tmpString, tmpResults[0].value[5+j*7]);
			ov_string_append(&tmpString, "\", \"SubModel\":\"");
			ov_string_append(&tmpString, tmpResults[0].value[6+j*7]);
			ov_string_append(&tmpString, "\"");
			ov_string_setvalue(&result->value[tmpCount], tmpString);
			tmpCount = tmpCount + 1;
			ov_string_setvalue(&tmpString, NULL);
		}
	}

	for (OV_UINT i = 0; i < querySize; i++){
		Ov_SetDynamicVectorLength(&findRowValues[i], 0, STRING);
		Ov_SetDynamicVectorLength(&findRowRelation[i], 0, UINT);
		Ov_SetDynamicVectorLength(&tmpResults[i], 0, STRING);
	}

	Ov_SetDynamicVectorLength(&tableNumber, 0, UINT);
	Ov_SetDynamicVectorLength(&selectColumns, 0, STRING);
	return resultOV;
}

OV_DLLFNCEXPORT OV_RESULT Databases_SQLC_execQuery(OV_INSTPTR_openAASDiscoveryServer_DBWrapper this, const OV_STRING query) {

    return OV_ERR_OK;
}

