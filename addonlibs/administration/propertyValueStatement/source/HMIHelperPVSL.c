
/******************************************************************************
*
*   FILE
*   ----
*   HMIHelperPVSL.c
*
*   History
*   -------
*   2017-06-23   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_propertyValueStatement
#define OV_COMPILE_LIBRARY_propertyValueStatement
#endif


#include "propertyValueStatement.h"
#include "libov/ov_macros.h"
#include "libov/ov_time.h"
#include "libov/ov_path.h"


OV_DLLFNCEXPORT void propertyValueStatement_HMIHelperPVSL_typemethod(
	OV_INSTPTR_fb_functionblock	pfb,
	OV_TIME						*pltc
) {
    /*    
    *   local variables
    */
    OV_INSTPTR_propertyValueStatement_HMIHelperPVSL pinst = Ov_StaticPtrCast(propertyValueStatement_HMIHelperPVSL, pfb);
	OV_INSTPTR_ov_object pobj = NULL;
	OV_INSTPTR_propertyValueStatement_PropertyValueStatementList pList = NULL;
	OV_INSTPTR_propertyValueStatement_PropertyValueStatement ppvs = NULL;

	ov_string_setvalue(&pinst->v_CarrierIdSpecification, "");
	ov_string_setvalue(&pinst->v_CarrierIdType, "");
	ov_string_setvalue(&pinst->v_PropertyIdSpecification, "");
	ov_string_setvalue(&pinst->v_PropertyIdType, "");
	ov_string_setvalue(&pinst->v_ExpressionLogic, "");
	ov_string_setvalue(&pinst->v_ExpressionSemantic, "");
	ov_string_setvalue(&pinst->v_ValueTimeStamp, "");
	ov_string_setvalue(&pinst->v_Name, "");
	ov_string_setvalue(&pinst->v_Value, "");
	ov_string_setvalue(&pinst->v_ErrorText, "");
	pinst->v_Error = FALSE;


	OV_UINT len = 0;
	OV_STRING *pathList = NULL;
	OV_STRING path = NULL;
	pathList = ov_string_split(pinst->v_Path, "/", &len);
	for (OV_UINT i = 4; i < len; i++){
		if (i == 4)
			ov_string_setvalue(&path, "/");
		else
			ov_string_append(&path, "/");
		ov_string_append(&path, pathList[i]);
	}

	pobj = ov_path_getobjectpointer(path,2);
	if (!pobj){
		pinst->v_Error = TRUE;
		ov_string_setvalue(&pinst->v_ErrorText, "Could not find an object for this path");
		ov_string_freelist(pathList);
		ov_database_free(path);
		return;
	}
	pList = Ov_DynamicPtrCast(propertyValueStatement_PropertyValueStatementList, pobj);
	if (!pList){
		pinst->v_Error = TRUE;
		ov_string_setvalue(&pinst->v_ErrorText, "Object is not of PVSL-Type");
		ov_string_freelist(pathList);
		ov_database_free(path);
		return;
	}


	OV_INSTPTR_propertyValueStatement_CarrierId pCarrierId = NULL;
	OV_INSTPTR_propertyValueStatement_PropertyId pPropertyId = NULL;
	OV_INSTPTR_propertyValueStatement_ExpressionLogic pExpressionLogic = NULL;
	OV_INSTPTR_propertyValueStatement_ExpressionSemantic pExpressionSemantic = NULL;

	OV_UINT CarrierIdIdType = 0;
	OV_STRING CarrierIdIdString = NULL;
	OV_UINT PropertyIdIdType = 0;
	OV_STRING PropertyIdIdString = NULL;
	OV_UINT ExpressionLogic = 0;
	OV_UINT ExpressionSemantic = 0;

	OV_INSTPTR_ov_object pchild = NULL;
	OV_BOOL CarrierIdFound = FALSE;
	OV_BOOL PropertyIdFound = FALSE;
	OV_BOOL ExpressionLogicFound = FALSE;
	OV_BOOL ExpressionSemanticFound = FALSE;

	Ov_ForEachChild(ov_containment, pList, pchild){
		if (Ov_CanCastTo(propertyValueStatement_CarrierId, pchild)){
			pCarrierId = Ov_DynamicPtrCast(propertyValueStatement_CarrierId, pchild);
			CarrierIdIdType = pCarrierId->v_IdType;
			ov_string_setvalue(&CarrierIdIdString, pCarrierId->v_IdSpec);
			pCarrierId = NULL;
			CarrierIdFound = TRUE;
		}else if(Ov_CanCastTo(propertyValueStatement_PropertyId, pchild)){
			pPropertyId = Ov_DynamicPtrCast(propertyValueStatement_PropertyId, pchild);
			PropertyIdIdType = pPropertyId->v_IdType;
			ov_string_setvalue(&PropertyIdIdString, pPropertyId->v_IdSpec);
			pPropertyId = NULL;
			PropertyIdFound = TRUE;
		}else if(Ov_CanCastTo(propertyValueStatement_ExpressionLogic, pchild)){
			pExpressionLogic = Ov_DynamicPtrCast(propertyValueStatement_ExpressionLogic, pchild);
			ExpressionLogic = pExpressionLogic->v_ExpressionLogicEnum;
			pExpressionLogic = NULL;
			ExpressionLogicFound = TRUE;
		}else if(Ov_CanCastTo(propertyValueStatement_ExpressionSemantic, pchild)){
			pExpressionSemantic = Ov_DynamicPtrCast(propertyValueStatement_ExpressionSemantic, pchild);
			ExpressionSemantic = pExpressionSemantic->v_ExpressionSemanticEnum;
			pExpressionSemantic = NULL;
			ExpressionSemanticFound = TRUE;
		}
	}

	OV_STRING tmpString = NULL;
	OV_UINT i = 0;
	Ov_ForEachChildEx(ov_containment, Ov_DynamicPtrCast(ov_domain,pList), ppvs, propertyValueStatement_PropertyValueStatement){
		if (i != 0){
			ov_string_append(&pinst->v_CarrierIdSpecification, ";");
			ov_string_append(&pinst->v_CarrierIdType, ";");
			ov_string_append(&pinst->v_PropertyIdSpecification, ";");
			ov_string_append(&pinst->v_PropertyIdType, ";");
			ov_string_append(&pinst->v_ExpressionLogic, ";");
			ov_string_append(&pinst->v_ExpressionSemantic, ";");
			ov_string_append(&pinst->v_ValueTimeStamp, ";");
			ov_string_append(&pinst->v_Name, ";");
			ov_string_append(&pinst->v_Value, ";");
		}

		if (i == 0)
			ov_string_setvalue(&pinst->v_Name, ppvs->v_identifier);
		else
			ov_string_append(&pinst->v_Name, ppvs->v_identifier);

		// CarrierId
		if (i == 0){
			if (CarrierIdFound == TRUE){
				ov_string_setvalue(&pinst->v_CarrierIdSpecification, CarrierIdIdString);
				ov_string_print(&tmpString, "%i", CarrierIdIdType);
				ov_string_setvalue(&pinst->v_CarrierIdType, tmpString);
				ov_string_setvalue(&tmpString, NULL);
			}else{
				Ov_ForEachChildEx(ov_containment, Ov_DynamicPtrCast(ov_domain, ppvs), pCarrierId, propertyValueStatement_CarrierId){
					ov_string_setvalue(&pinst->v_CarrierIdSpecification, pCarrierId->v_IdSpec);
					ov_string_print(&tmpString, "%i", pCarrierId->v_IdType);
					ov_string_setvalue(&pinst->v_CarrierIdType, tmpString);
					ov_string_setvalue(&tmpString, NULL);
				}
			}
		}else{
			if (CarrierIdFound == TRUE){
				ov_string_append(&pinst->v_CarrierIdSpecification, CarrierIdIdString);
				ov_string_print(&tmpString, "%i", CarrierIdIdType);
				ov_string_append(&pinst->v_CarrierIdType, tmpString);
				ov_string_setvalue(&tmpString, NULL);
			}else{
				Ov_ForEachChildEx(ov_containment, Ov_DynamicPtrCast(ov_domain, ppvs), pCarrierId, propertyValueStatement_CarrierId){
					ov_string_append(&pinst->v_CarrierIdSpecification, pCarrierId->v_IdSpec);
					ov_string_print(&tmpString, "%i", pCarrierId->v_IdType);
					ov_string_append(&pinst->v_CarrierIdType, tmpString);
					ov_string_setvalue(&tmpString, NULL);
				}
			}
		}

		// PropertyId
		if (i == 0){
			if (PropertyIdFound == TRUE){
				ov_string_setvalue(&pinst->v_PropertyIdSpecification, PropertyIdIdString);
				ov_string_print(&tmpString, "%i", PropertyIdIdType);
				ov_string_setvalue(&pinst->v_PropertyIdType, tmpString);
				ov_string_setvalue(&tmpString, NULL);
			}else{
				Ov_ForEachChildEx(ov_containment, Ov_DynamicPtrCast(ov_domain, ppvs), pPropertyId, propertyValueStatement_PropertyId){
					ov_string_setvalue(&pinst->v_PropertyIdSpecification, pPropertyId->v_IdSpec);
					ov_string_print(&tmpString, "%i", pPropertyId->v_IdType);
					ov_string_setvalue(&pinst->v_PropertyIdType, tmpString);
					ov_string_setvalue(&tmpString, NULL);
				}
			}
		}else{
			if (PropertyIdFound == TRUE){
				ov_string_append(&pinst->v_PropertyIdSpecification, PropertyIdIdString);
				ov_string_print(&tmpString, "%i", PropertyIdIdType);
				ov_string_append(&pinst->v_PropertyIdType, tmpString);
				ov_string_setvalue(&tmpString, NULL);
			}else{
				Ov_ForEachChildEx(ov_containment, Ov_DynamicPtrCast(ov_domain, ppvs), pPropertyId, propertyValueStatement_PropertyId){
					ov_string_append(&pinst->v_PropertyIdSpecification, pPropertyId->v_IdSpec);
					ov_string_print(&tmpString, "%i", pPropertyId->v_IdType);
					ov_string_append(&pinst->v_PropertyIdType, tmpString);
					ov_string_setvalue(&tmpString, NULL);
				}
			}
		}

		// ExpressionLogic
		if (i == 0){
			if (ExpressionLogicFound == TRUE){
				switch(ExpressionLogic){
				case 0:
					ov_string_setvalue(&pinst->v_ExpressionLogic, "GT");
					break;
				case 1:
					ov_string_setvalue(&pinst->v_ExpressionLogic, "GE");
					break;
				case 2:
					ov_string_setvalue(&pinst->v_ExpressionLogic, "EQ");
					break;
				case 3:
					ov_string_setvalue(&pinst->v_ExpressionLogic, "NE");
					break;
				case 4:
					ov_string_setvalue(&pinst->v_ExpressionLogic, "LE");
					break;
				case 5:
					ov_string_setvalue(&pinst->v_ExpressionLogic, "LT");
					break;
				default:
					if (pinst->v_Error == FALSE){
						pinst->v_Error = TRUE;
						ov_string_setvalue(&pinst->v_ErrorText, "ExpressionLogic not supported");
					}
					break;
				}
			}else{
				Ov_ForEachChildEx(ov_containment, Ov_DynamicPtrCast(ov_domain, ppvs), pExpressionLogic, propertyValueStatement_ExpressionLogic){
					switch(pExpressionLogic->v_ExpressionLogicEnum){
					case 0:
						ov_string_setvalue(&pinst->v_ExpressionLogic, "GT");
						break;
					case 1:
						ov_string_setvalue(&pinst->v_ExpressionLogic, "GE");
						break;
					case 2:
						ov_string_setvalue(&pinst->v_ExpressionLogic, "EQ");
						break;
					case 3:
						ov_string_setvalue(&pinst->v_ExpressionLogic, "NE");
						break;
					case 4:
						ov_string_setvalue(&pinst->v_ExpressionLogic, "LE");
						break;
					case 5:
						ov_string_setvalue(&pinst->v_ExpressionLogic, "LT");
						break;
					default:
						if (pinst->v_Error == FALSE){
							pinst->v_Error = TRUE;
							ov_string_setvalue(&pinst->v_ErrorText, "ExpressionLogic not supported");
						}
						break;
					}
				}
			}
		}else{
			if (ExpressionLogicFound == TRUE){
				switch(ExpressionLogic){
				case 0:
					ov_string_append(&pinst->v_ExpressionLogic, "GT");
					break;
				case 1:
					ov_string_append(&pinst->v_ExpressionLogic, "GE");
					break;
				case 2:
					ov_string_append(&pinst->v_ExpressionLogic, "EQ");
					break;
				case 3:
					ov_string_append(&pinst->v_ExpressionLogic, "NE");
					break;
				case 4:
					ov_string_append(&pinst->v_ExpressionLogic, "LE");
					break;
				case 5:
					ov_string_append(&pinst->v_ExpressionLogic, "LT");
					break;
				default:
					if (pinst->v_Error == FALSE){
						pinst->v_Error = TRUE;
						ov_string_setvalue(&pinst->v_ErrorText, "ExpressionLogic not supported");
					}
					break;
				}
			}else{
				Ov_ForEachChildEx(ov_containment, Ov_DynamicPtrCast(ov_domain, ppvs), pExpressionLogic, propertyValueStatement_ExpressionLogic){
					switch(pExpressionLogic->v_ExpressionLogicEnum){
					case 0:
						ov_string_append(&pinst->v_ExpressionLogic, "GT");
						break;
					case 1:
						ov_string_append(&pinst->v_ExpressionLogic, "GE");
						break;
					case 2:
						ov_string_append(&pinst->v_ExpressionLogic, "EQ");
						break;
					case 3:
						ov_string_append(&pinst->v_ExpressionLogic, "NE");
						break;
					case 4:
						ov_string_append(&pinst->v_ExpressionLogic, "LE");
						break;
					case 5:
						ov_string_append(&pinst->v_ExpressionLogic, "LT");
						break;
					default:
						if (pinst->v_Error == FALSE){
							pinst->v_Error = TRUE;
							ov_string_setvalue(&pinst->v_ErrorText, "ExpressionLogic not supported");
						}
						break;
					}
				}
			}
		}

		// ExpressionSemantic
		if (i == 0){
			if (ExpressionSemanticFound == TRUE){
				switch(ExpressionSemantic){
				case 0:
					ov_string_setvalue(&pinst->v_ExpressionSemantic, "A");
					break;
				case 1:
					ov_string_setvalue(&pinst->v_ExpressionSemantic, "S");
					break;
				case 2:
					ov_string_setvalue(&pinst->v_ExpressionSemantic, "M");
					break;
				case 3:
					ov_string_setvalue(&pinst->v_ExpressionSemantic, "R");
					break;
				default:
					if (pinst->v_Error == FALSE){
						pinst->v_Error = TRUE;
						ov_string_setvalue(&pinst->v_ErrorText, "ExpressionSemantic not supported");
					}
					break;
				}
			}else{
				Ov_ForEachChildEx(ov_containment, Ov_DynamicPtrCast(ov_domain, ppvs), pExpressionSemantic, propertyValueStatement_ExpressionSemantic){
					switch(pExpressionSemantic->v_ExpressionSemanticEnum){
					case 0:
						ov_string_setvalue(&pinst->v_ExpressionSemantic, "A");
						break;
					case 1:
						ov_string_setvalue(&pinst->v_ExpressionSemantic, "S");
						break;
					case 2:
						ov_string_setvalue(&pinst->v_ExpressionSemantic, "M");
						break;
					case 3:
						ov_string_setvalue(&pinst->v_ExpressionSemantic, "R");
						break;
					default:
						if (pinst->v_Error == FALSE){
							pinst->v_Error = TRUE;
							ov_string_setvalue(&pinst->v_ErrorText, "ExpressionSemantic not supported");
						}
						break;
					}
				}
			}
		}else{
			if (ExpressionSemanticFound == TRUE){
				switch(ExpressionSemantic){
				case 0:
					ov_string_append(&pinst->v_ExpressionSemantic, "A");
					break;
				case 1:
					ov_string_append(&pinst->v_ExpressionSemantic, "S");
					break;
				case 2:
					ov_string_append(&pinst->v_ExpressionSemantic, "M");
					break;
				case 3:
					ov_string_append(&pinst->v_ExpressionSemantic, "R");
					break;
				default:
					if (pinst->v_Error == FALSE){
						pinst->v_Error = TRUE;
						ov_string_setvalue(&pinst->v_ErrorText, "ExpressionSemantic not supported");
					}
					break;
				}
			}else{
				Ov_ForEachChildEx(ov_containment, Ov_DynamicPtrCast(ov_domain, ppvs), pExpressionSemantic, propertyValueStatement_ExpressionSemantic){
					switch(pExpressionSemantic->v_ExpressionSemanticEnum){
					case 0:
						ov_string_append(&pinst->v_ExpressionSemantic, "A");
						break;
					case 1:
						ov_string_append(&pinst->v_ExpressionSemantic, "S");
						break;
					case 2:
						ov_string_append(&pinst->v_ExpressionSemantic, "M");
						break;
					case 3:
						ov_string_append(&pinst->v_ExpressionSemantic, "R");
						break;
					default:
						if (pinst->v_Error == FALSE){
							pinst->v_Error = TRUE;
							ov_string_setvalue(&pinst->v_ErrorText, "ExpressionSemantic not supported");
						}
						break;
					}
				}
			}
		}

		// ValueTimeStamp
		if (i == 0)
			ov_string_setvalue(&pinst->v_ValueTimeStamp, ov_time_timetoascii_local(&ppvs->v_Value.time));
		else
			ov_string_append(&pinst->v_ValueTimeStamp, ov_time_timetoascii_local(&ppvs->v_Value.time));

		// Value
		switch(ppvs->v_Value.value.vartype & OV_VT_KSMASK){
			case OV_VT_BOOL:
				if (ppvs->v_Value.value.valueunion.val_bool == TRUE)
					if (i == 0)
						ov_string_setvalue(&pinst->v_Value, "TRUE");
					else
						ov_string_append(&pinst->v_Value, "TRUE");
				else
					if (i == 0)
						ov_string_setvalue(&pinst->v_Value, "FALSE");
					else
						ov_string_append(&pinst->v_Value, "FALSE");
			break;
			case OV_VT_STRING:
				if (i == 0)
					ov_string_setvalue(&pinst->v_Value, ppvs->v_Value.value.valueunion.val_string);
				else
					ov_string_append(&pinst->v_Value, ppvs->v_Value.value.valueunion.val_string);
			break;
			case OV_VT_DOUBLE:
			    ov_string_print(&tmpString, "%lf", ppvs->v_Value.value.valueunion.val_double);
			    if (i == 0)
					ov_string_setvalue(&pinst->v_Value, tmpString);
				else
					ov_string_append(&pinst->v_Value, tmpString);
			break;
			case OV_VT_INT:
				ov_string_print(&tmpString, "%i", ppvs->v_Value.value.valueunion.val_int);
				if (i == 0)
					ov_string_setvalue(&pinst->v_Value, tmpString);
				else
					ov_string_append(&pinst->v_Value, tmpString);
			break;
			case OV_VT_UINT:
				ov_string_print(&tmpString, "%u", ppvs->v_Value.value.valueunion.val_uint);
				if (i == 0)
					ov_string_setvalue(&pinst->v_Value, tmpString);
				else
					ov_string_append(&pinst->v_Value, tmpString);
			break;
			case OV_VT_SINGLE:
				ov_string_print(&tmpString, "%f", ppvs->v_Value.value.valueunion.val_single);
				if (i == 0)
					ov_string_setvalue(&pinst->v_Value, tmpString);
				else
					ov_string_append(&pinst->v_Value, tmpString);
			break;
			default:
				if (pinst->v_Error == FALSE){
					pinst->v_Error = TRUE;
					ov_string_setvalue(&pinst->v_ErrorText, "DataTye not supported");
				}
			break;
		}

	i++;
	}

	ov_string_setvalue(&tmpString, NULL);
	ov_string_freelist(pathList);
	ov_string_setvalue(&path, NULL);
    return;
}
