
/******************************************************************************
*
*   FILE
*   ----
*   ComponentManagerTC.c
*
*   History
*   -------
*   2018-05-09   File created
*
*******************************************************************************
*
*   This file is generated by the 'acplt_builder' command
*
******************************************************************************/


#ifndef OV_COMPILE_LIBRARY_openAASDiscoveryServer
#define OV_COMPILE_LIBRARY_openAASDiscoveryServer
#endif


#include "openAASDiscoveryServer.h"
#include "libov/ov_macros.h"
#include "MessageSys_helpers.h"
#include "fb_database.h"
#include "libov/ov_result.h"

OV_DLLFNCEXPORT OV_RESULT openAASDiscoveryServer_ComponentManagerTC_constructor(
	OV_INSTPTR_ov_object 	pobj
) {
    /*    
    *   local variables
    */
    OV_INSTPTR_openAASDiscoveryServer_ComponentManagerTC pinst = Ov_StaticPtrCast(openAASDiscoveryServer_ComponentManagerTC, pobj);
    OV_RESULT    result;

    /* do what the base class does first */
    result = fb_functionblock_constructor(pobj);
    if(Ov_Fail(result))
         return result;

    /* do what */
    pinst->v_iexreq = TRUE;
	pinst->v_actimode = 1;
	OV_INSTPTR_fb_task pTaskParent = NULL;
	pinst->v_messageBoxIsFiFo = TRUE;
	pinst->v_messageBoxSize = 10;
	pTaskParent = (OV_INSTPTR_fb_task)fb_database_geturtask();
	if (pTaskParent != NULL){
		Ov_Link(fb_tasklist, pTaskParent, pinst);
	}
	else {
		ov_logfile_error("Cannot link StateMachine to tasklist", pinst->v_identifier);
	}


    return OV_ERR_OK;
}


static OV_INSTPTR_MessageSys_Message getNextMessage(OV_INSTPTR_openAASDiscoveryServer_ComponentManagerTC this) {
	OV_INSTPTR_ov_object child = NULL;

	//Check if we have a Message if(FiFo) else(Stack)
	if (this->v_messageBoxIsFiFo == TRUE) {
		// Get the first child that can be casted to Message.
		child = Ov_GetFirstChild(ov_containment, &this->p_INBOX);
		while (child && !Ov_CanCastTo(MessageSys_Message , child)) {
			child = Ov_GetNextChild(ov_containment, child);
		}
	} else {
		// Get the last child that can be casted to Message.
		child = Ov_GetLastChild(ov_containment, &this->p_INBOX);
		while (child && !Ov_CanCastTo(MessageSys_Message , child)) {
			child = Ov_GetPreviousChild(ov_containment, child);
		}
	}
	//After getting next child, because it might have been the outbox check if it is a valid child now.
	//If not jump out, because the only childs of ServiceAdministrator are messages or the single outbox.
	if (child == NULL || !Ov_CanCastTo(MessageSys_Message , child)) {
		return NULL;
	}
	return (OV_INSTPTR_MessageSys_Message) child;
}

OV_DLLFNCEXPORT void openAASDiscoveryServer_ComponentManagerTC_cleanupMessageBox(OV_INSTPTR_openAASDiscoveryServer_ComponentManagerTC this) {
	int nMessagesToDelete = 0;
	int nMessagesDeleted = 0;
	OV_INSTPTR_ov_object pChild = NULL;
	OV_INSTPTR_MessageSys_Message pMessageToDelete = NULL;

	// Calculate the number of messages to delete.
	Ov_ForEachChild(ov_containment, &this->p_INBOX, pChild) {
		if (Ov_CanCastTo(MessageSys_Message, pChild)) {
			nMessagesToDelete++;
		}
	}
	nMessagesToDelete = nMessagesToDelete - this->v_messageBoxSize;

	// Delete the messages.
	// TODO: To be optimized.
	while (nMessagesDeleted < nMessagesToDelete) {
		// Find a message to delete.
		pMessageToDelete = NULL;
		Ov_ForEachChild(ov_containment, &this->p_INBOX, pChild) {
			if (!Ov_CanCastTo(MessageSys_Message, pChild)) {
				continue;
			}
			if (this->v_messageBoxIsFiFo) {
				if (pMessageToDelete == NULL || ov_time_compare(&pMessageToDelete->v_creationtime, &pChild->v_creationtime) == OV_TIMECMP_AFTER) {
					pMessageToDelete = (OV_INSTPTR_MessageSys_Message) pChild;
				}
			} else {
				if (pMessageToDelete == NULL || ov_time_compare(&pMessageToDelete->v_creationtime, &pChild->v_creationtime) == OV_TIMECMP_BEFORE) {
					pMessageToDelete = (OV_INSTPTR_MessageSys_Message) pChild;
				}
			}
		}
		// Delete the message.
		Ov_DeleteObject(pMessageToDelete);
		nMessagesDeleted++;
	}
	return;
}



OV_DLLFNCEXPORT void openAASDiscoveryServer_ComponentManagerTC_typemethod(
	OV_INSTPTR_fb_functionblock	pfb,
	OV_TIME						*pltc
) {
    /*    
    *   local variables
    */
	OV_INSTPTR_openAASDiscoveryServer_ComponentManagerTC pinst = Ov_StaticPtrCast(openAASDiscoveryServer_ComponentManagerTC, pfb);
	OV_INSTPTR_MessageSys_Message message = NULL;

	// First clean message box, so only up-to-date messages are handled.
	openAASDiscoveryServer_ComponentManagerTC_cleanupMessageBox(pinst);
	// Get the next message, if any.
	message = getNextMessage(pinst);
	if (message == NULL) {
		// Nothing to do.
		return;
	}
	OV_INSTPTR_openAASDiscoveryServer_TestClient pTC = NULL;
	pTC = Ov_DynamicPtrCast(openAASDiscoveryServer_TestClient, pinst->v_pouterobject);
	if (pTC->v_State != 2 && pTC->v_State != 3 && pTC->v_State != 4 && pTC->v_State != 5){
		while(TRUE){
			Ov_DeleteObject((OV_INSTPTR_ov_object) message);
			message = getNextMessage(pinst);
			if (message == NULL) {
				// Nothing to do.
				return;
			}

		}
	}

	// Decoding the Message
	OV_STRING messageContent = NULL;

	// XML Decoding
	if (strncmp(message->v_msgBody, "<bdy>", 5) != 0){ // <bdy> not found
		Ov_DeleteObject((OV_INSTPTR_ov_object) message);
		ov_logfile_info("ComponentManager: <bdy> not found in msg");
		return;
	}
	OV_UINT messageLength = ov_string_getlength(message->v_msgBody);
	if (strncmp(&message->v_msgBody[messageLength-6], "</bdy>", 6) != 0){ // </bdy> not found
		Ov_DeleteObject((OV_INSTPTR_ov_object) message);
		ov_logfile_info("ComponentManager: </bdy> not found in msg");
		return;
	}
	messageContent = Ov_HeapMalloc((messageLength-11+1)*sizeof(char));
	memcpy(messageContent, (message->v_msgBody+5), messageLength-11);
	messageContent[messageLength-11] = '\0';

	response_data responseData;
	response_data_init(&responseData);
	jsonResponseParse(&responseData, messageContent);
	Ov_HeapFree(messageContent);
	OV_STRING_VEC tags;
	tags.value = NULL;
	tags.veclen = 0;
	OV_STRING_VEC values;
	values.value = NULL;
	values.veclen = 0;
	switch(pTC->v_State){
		case 2: // WaitingForSecurityResponse
			if (responseData.header.messageType != 2){
				// delete all used memory
				Ov_DeleteObject((OV_INSTPTR_ov_object) message);
				return;
			}
			if (responseData.header.errorFlag == TRUE){
				pTC->v_ErrorFlag = TRUE;
				ov_string_setvalue(&pTC->v_ErrorMessage, responseData.header.errorMessage);
				pTC->v_State = 6;
				// delete all used memory
				Ov_DeleteObject((OV_INSTPTR_ov_object) message);
				return;
			}
			// find certificate and securityKey
			// Parsing Body
			Ov_SetDynamicVectorLength(&tags, 2, STRING);
			Ov_SetDynamicVectorLength(&values, 2, STRING);

			ov_string_setvalue(&tags.value[0], "certificate");
			ov_string_setvalue(&tags.value[1], "securityKey");

			jsonGetValuesByTags(tags, responseData.body, 1, &values);
			ov_string_setvalue(&pTC->v_CertificateDS, values.value[0]);
			ov_string_setvalue(&pTC->v_SecurityKey, values.value[1]);
			Ov_SetDynamicVectorLength(&tags, 0, STRING);
			Ov_SetDynamicVectorLength(&values, 0, STRING);
		break;
		case 3: // WaitingForRegistrationResponse
			if (responseData.header.messageType != 4){
				// delete all used memory
				Ov_DeleteObject((OV_INSTPTR_ov_object) message);
				return;
			}
			if (responseData.header.errorFlag == TRUE){
				pTC->v_ErrorFlag = TRUE;
				ov_string_setvalue(&pTC->v_ErrorMessage, responseData.header.errorMessage);
				pTC->v_State = 6;
				// delete all used memory
				Ov_DeleteObject((OV_INSTPTR_ov_object) message);
				return;
			}
		break;
		case 4: // WaitingForUnregistrationResponse
			if (responseData.header.messageType != 6){
				// delete all used memory
				Ov_DeleteObject((OV_INSTPTR_ov_object) message);
				return;
			}
			if (responseData.header.errorFlag == TRUE){
				pTC->v_ErrorFlag = TRUE;
				ov_string_setvalue(&pTC->v_ErrorMessage, responseData.header.errorMessage);
				pTC->v_State = 6;
				// delete all used memory
				Ov_DeleteObject((OV_INSTPTR_ov_object) message);
				return;
			}
		break;
		case 5: // WaitingForSearchResponse
			if (responseData.header.messageType != 8){
				// delete all used memory
				Ov_DeleteObject((OV_INSTPTR_ov_object) message);
				return;
			}
			if (responseData.header.errorFlag == TRUE){
				pTC->v_ErrorFlag = TRUE;
				ov_string_setvalue(&pTC->v_ErrorMessage, responseData.header.errorMessage);
				pTC->v_State = 6;
				// delete all used memory
				Ov_DeleteObject((OV_INSTPTR_ov_object) message);
				return;
			}
			// find aas
			// Parsing Body
			ov_string_setvalue(&pTC->v_AASFound, responseData.body.js);
		break;
	}

	// delete all used memory
	Ov_DeleteObject((OV_INSTPTR_ov_object) message);
	pTC->v_State = 6;

	return;
}
